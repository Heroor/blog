{{
  title: '透析浏览器工作原理',
  poster: '',
  date: '2021-08-05',
  id: '2021-08-05',
  desc: '带你经历从URL到页面渲染的旅程'
}}

## 浏览器架构

### 单进程浏览器时代

2007年之前，浏览器的所有功能模块都运行在同一个进程里，这些模块包含了网络、插件、JavaScript运行环境、渲染引擎和⻚ 面等

一个页面或者插件崩溃，会导致浏览器崩溃；一个页面运行时占满线程，会导致浏览器整体卡顿

### 多进程浏览器时代

浏览器每个tab都是一个单独的渲染进程，一个页面崩溃不会影响其他页面的渲染

稳定安全、关闭页面即可回收内存、利用沙箱环境限制操作硬盘数据

### 现代Chrome架构

1. 浏览器主进程
  负责界面显示、交互、子进程管理、储存
2. GPU进程
  负责渲染浏览器界面、页面CSS/3D特效
3. 网络进程
  负责网络资源的加载
4. 多个渲染进程
  负责渲染页面，每个页面都会拥有独立的沙箱环境的渲染进程
5. 多个插件进程
  每个插件也拥有独立的插件进程，防止插件的崩溃影响页面和浏览器


## 数据是如何交换的

在网络协议 `IP` 的标准下，数据包自由地在服务器与客户端之间传递，`IP地址` 就是设备在网络中的位置信息。

首先，提供服务的应用程序需要在系统中开放一个端口号，数据在发送前，发送者使用 `UDP` 协议事先将数据包加工，添加 `UDP` 头，保存接受者的端口号信息，随后 `IP` 网络层会在数据包上附加发送者和接受者的 `IP地址`，以方便发送与回传，这些信息被放在 `IP头` 中，包含IP版本、源IP地址、目标IP地址、生存时间等信息。

### UDP

`UDP` (User Datagram Protocol) 用户数据包协议传送速度极快，但是不能保证数据的可靠性，因为 `UDP` 不会为发送失败的数据包进行重发操作，也不关注数据包发送之后是否到了达目的地。

### TCP

`TCP` (Transmission Control Protocol) 传输控制协议是用来解决 `UDP` 传输问题的协议，会将丢失的数据包进行重传，同时会在接收数据时，将被拆分的数据包排序并组装还原，而且接受者在接收到数据包后，会向发送者发送确认信息，以此保证数据传输的完整性。

### HTTP

`HTTP` 建立与 `TCP` 链接之上，常用于浏览器向服务器请求数据，浏览器首先使用 `TCP` 协议与服务器建立链接，然后才开始使用 `HTTP` 协议发送消息，包含了请求行、请求头、请求体等内容。

浏览器首先发送 `HTTP` 请求行，就像这样：`GET /images/logo.png HTTP1.1`，包含了请求方法、请求URI、HTTP协议版本；之后便会发送请求头信息，包含一些浏览器信息、操作系统信息、请求配置信息等；`POST` 请求还会发送请求体，也就是浏览器要传输给服务器的数据。

服务器接收到数据包，然后执行拼装、解析、处理等操作，最后返回一个响应的资源或数据给浏览器，包含了响应行、响应头、响应体等信息。

响应行结构如下：`HTTP/1.1 200 OK`，包含了 `HTTP` 版本、状态码等信息；然后发送响应头，包含服务器相关信息、缓存信息、响应数据类型等；最后会发送响应体，包含服务器发送的数据包。

### HTTP 缓存

浏览器在接收到资源后也会对资源进行缓存，下次请求前，浏览器检查本地存在缓存资源并符合可用条件时，会取消请求的发送，优先返回被缓存的资源。

浏览器发出请求时会经过 `CDN` 服务，`CDN` 返回的 `IP` 地址会被浏览器缓存在本地，所以下次请求可以省去 `CDN` 的过程，从而加快请求速度。

当服务器端返回资源时，会断开 `TCP` 连接，这样浏览器每次请求都会重新建立 `TCP` 连接。当服务器设置响应头 `Connection: Keep-Alive` 时可以建立持久连接，也就是不会断开 `TCP` 连接，用来被下次的请求复用；

设置 `Cache-control: max-age: 100` 响应头，可以告知浏览器主动缓存此资源，并允许在过期之前使用；

`ETag` 响应头可以设置资源标识信息，当浏览器发起请求时，如果本地资源过期了，浏览器会携带 `If-None-Match: "<ETag>"` 请求头发起请求，询问服务器此资源是否有更新，当服务器检测到资源没有更新时，会返回 `304` 状态码通知浏览器继续使用本地缓存，如果资源有更新则响应 `200` 和最新的数据。

如果资源不需要缓存，服务器端可以设置 `Catch-control: no-store` 让浏览器不做缓存；设置 `Catch-control: no-cache` 可以让浏览器每次请求都询问服务器是否可以使用本地缓存的资源。

另外，资源在返回给浏览器的途中，如果经历了中间代理服务器，设置响应头 `Catch-control: public`，可以缓存在代理服务器中，以便下次请求时直接被代理服务器返回；`Catch-control: private` 则表示不被中间代理缓存。设置 `Catch-control: s-max-age=100` 响应头可以对代理服务器做过期新鲜度设置，在资源未过期时，浏览器请求资源会被代理服务器直接被返回，从而减少源服务器的压力。


整体请求链路如下：

1. 构建请求信息
2. 查找本地缓存（命中缓存则请求被取消）
3. 查询 `DNS`
4. 准备 `IP` 和端口
5. 等待 `TCP` 队列（只能同时并发6个TCP请求）
6. 建立 `TCP` 连接（经历三次握手的阶段）
7. 发送 `HTTP` 请求数据（请求行、请求头(附加cookie)、请求体）
8. 中间代理服务器（命中缓存则被返回）
9. 服务器返回响应数据（响应行、响应头、响应体）
10. 解析响应头（`310,320` 重定向则重新请求；根据 `Content-Type` 进行渲染文档或下载等操作）
11. 网络进程提交文档给渲染进程（同站点会复用渲染进程）
12. 开始解析渲染页面


## 渲染原理

浏览器解析文档会经历以下过程：

构建 `DOM` 树、算计式样、布局阶段、分层、绘制、分块、光栅化、合成

### 构建 DOM 树

`HTML` 代码被编译为树结构的内容才能被渲染引擎理解，也方便被 `JS` 操作，这个树结构就是 `DOM` 树。

### 生成计算样式

有了 `DOM` 树，浏览器还需要知道节点的样式才能渲染，这就需要对 `CSS` 代码进行解析，生成 `CSSOM` 树。`CSSOM` 的构建不会阻塞 `DOM` 树的解析，但是会阻塞布局树的合成，以及阻塞 `js` 代码的执行（`js` 有操作 `CSSOM` 的能力）。

1. CSS 树

`CSS` 代码来源于：

1. 外联样式 `<link href="dist.css" rel="stylesheet">`
2. 内联样式 `<style>h1 { color: red }</style>`
3. 行内样式 `<h1 style="color: red">hello</h1>`

转换成 `CSSOM` 结构后，需要对 `CSS` 属性的值做标椎化处理，例如将 `red` 转换为浏览器理解的颜色值：`rgb(255, 0, 0)`

2. 计算样式

节点的样式首先会先继承父节点的样式，例如 `font-size`、`color` 等，其次是设置自身默认样式，再然后设置自身命中选择器的样式等，最终会层层合并已有的同名样式得到 `ComputedStyle`（计算样式）。

### 布局阶段

得到 `DOM` 树和计算样式后，浏览器开始布局操作，计算出 `DOM` 树可见元素的几何位置。

1. 布局树

同样，布局也需要创建布局树，也就是把之前解析出来的 `DOM` 树和 `CSSOM` 树结合起来，遍历出其中所有的可见元素，例如：`head` 标签、`display: none` 的标签等，最终会生成一颗布局树。

2. 布局计算

渲染引擎计算出每个元素对应的几何位置，布局计算的结果会写进布局树中

### 分层

浏览器根据布局树，为特定的节点生成专有图层，最终生成图层树(LayerTree)

并不是每个节点都拥有自己的图层，没有创建自己的层叠上下文的元素会被父层叠上下文同化，且 `<html>` 元素默认拥有层叠上下文。

设置以下属性的元素会有独立的图层（有些需要 `z-index` 不为 `auto`）：

- 非 `static` 值的 `position`
- `flex`
- `grid`
- `opacity` 小于 `1`
- `transform`
- `filter`
- `perspective`
- `clip-path`
- `mask` / `mask-image` / `mask-border`
- `will-change`

同时，当元素溢出容器被隐藏时，也会创建独立的层，滚动条也拥有独立的层。

### 绘制

渲染引擎主线程根据图层拆分成绘制指令，组成绘制列表，提交给合成线程处理。

### 栅格化 raster

合成线程将图层划分为图块（tile），例如 256x256、512x512 大小的图块，根据视口（viewPort）大小，优先处理视口附近的可视图块，使用栅格化技术将其变成位图。

光栅化使用线程池将图块转为位图，并且常常会使用 GPU 来加速生成过程，生成的位图被保存在 GPU 内存中，这些生成过程都是在 GPU 进程中完成的。

### 合成与显示

光栅化完成后，合成线程开始绘制图块，发出 `DrawQuad` 命令，浏览器进程接收到命令后，将页面内容绘制到内存中，然后显示在屏幕上。

### 重排与重绘

更新元素的几何属性，例如宽高，元素需要重新计算样式表、布局树、图层树以及之后的所有操作。

更新元素的绘制属性，例如颜色背景，元素需要重新计算样式表，但是不需要重新计算布局与图层，直接执行后面的工作。

## 变量提升

JS引擎在执行代码前需要进行预编译，会将 var 声明的变量、函数存到作用域内的变量对象中，let 声明的变量会放在词法环境(Lexical Environment)中，块级作用域中的 let 变量会声明在词法环境的栈空间中，新的变量会放在栈顶，变量的查找方式为从栈顶向下查找，再查找变量对象，之后是函数作用域之外，也就是原型链；var/let声明的变量会被赋值 `undefined`，声明的函数会被创建在堆内存中，然后将函数的引用保存给一个变量，然后存进变量对象中；并且后声明的变量或函数会覆盖掉已声明的变量；之后引擎会将代码中声明之外的代码编译为字节码，然后一行一行的执行。

## 堆栈

代码执行过程中，主要搜三种类型内存空间：代码空间、栈空间、堆空间

栈空间就是执行上下文的调用栈，原始类型的变量存放在执行上下文中，可以说原始类型的变量存放在栈内存中；引用类型的数据会先在堆内存中分配空间，并将堆空间的地址赋值在变量中。

栈空间需要维护执行上下文，以及高效的内存分配与内存回收，所以不会存储很大的数据，因此原始类型的数据只存在栈中，例如对象这类占用空间大的数据则会存在堆空间中。


## 垃圾回收

### 代际假说

1. 大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可
访问;
2. 不死的对象，会活得更久。

V8 引擎会把**堆**分为**新生代**和**老生代**两个区域，新生代存放生存时间短的对象，老生代存放生存时间久的对象；V8 分别使用两个不同的回收器来回收内存，副回收器负责新生代，主回收器负责老生代。

### 执行流程

1. 标记空间中的活动对象和非活动对象。活动对象就是还在使用的对象，非活动对象就是可以进行回收的对象。
2. 回收非活动对象占用的内存。
3. 内存管理。整理回收后出现的大量不连续空间的内存碎片。

### 新生代

新生代使用 Scavenge 算法处理内存回收，大多数小的对象会被放入新生代中。新生代的空间分为两个区域，一个是对象区域，一个是空闲区域，新加入的对象会放入对象区域，当对象区域快写满时就执行一次垃圾回收。

## V8 执行代码的过程

### 编译器和解释器

编程语言一般分为编译型语言和解释型语言

- 编译型语言在程序执行前经过编译器(TurboFan)编译成二进制文件才进行执行。

代码 -> 词法分析/语法分析 -> AST -> 词义分析 -> 中间代码 -> 代码优化 -> 二进制文件 -> 直接执行

- 解释器语言需要每次运行时通过解释器(Ignition)动态解释和执行代码。

代码 -> 词法分析/语法分析 -> AST -> 词义分析 -> 字节码 -> 解释执行

### AST

`AST` 是代码的结构化表示，可以用来处理并生成新的代码

如何在生成AST：

1. 词法分析/分词(tokenize)
将代码拆分为一个个 token，关键字、变量标识、控制语句、字面量等都会被拆分

2. 语法分析/解析(parse)
将tokens转化为AST

此后还会生成执行上下文

### 字节码

字节码是介于AST和机器码之间的一种代码，通过解释器转换为机器码才可以执行

解释器根据AST生成字节码，并解释执行字节码，且字节码占用内存空间比机器码小很多


### 代码执行

解释器会逐条解释执行字节码，在执行过程中，如果发现有一段代码被重复执行多次，也就是热点代码(HotSpot)，此时后台的编译器就会把热点代码的字节码编译成高效的机器码，当以后再次执行热点代码的时候，只需要执行机器码就可以了，这样就提高了代码执行效率，这种解释器与编译器的配合技术即为：即时编译(JIT)

## 事件循环

消息队列是一个储存任务的队列，也被称为宏任务队列，新任务会从队列尾部加入，例如JS代码执行、输入事件、文件读取、WebSocket、定时器、DOM解析、样式计算、布局计算、CSS动画等任务，渲染主线程会从消息队列头部读取任务然后执行。渲染进程会通过一个**IO线程**接收其他线程发送过来的任务消息，然后这些任务被添加进任务队列中，等待渲染主线程的执行

每个宏任务中都包含了一个微任务队列，每当宏任务正在执行中时，如果 DOM 节点发生了变化触发 `MutationObserver` 或者 `Promise`，则会添加到微任务的队列中，在当前宏任务被执行完毕前，渲染引擎会依次执行微任务队列中的所有微任务，这个时间叫做检查点。以此确保了 DOM 频繁变化时不会立刻被执行更新任务而导致当前宏任务的阻塞，从而不影响后面宏任务的执行效率，此方式提供了在当前宏任务结束后批量执行更新任务的能力，来保证 DOM 节点变化的实时性

setTimeout 定时器添加的回调任务会被添加进延迟队列中，每次完成一个宏任务时，会检查延迟任务队列，根据发起时间和延迟时间，依次执行过期的任务。clearTimeout通过传入的定时器ID，找到对应的延迟任务，然后从列表中删除。定时器嵌套5层时，v8引擎会认为嵌套函数发生了阻塞，会将定时器最小触发时间设置为 4 毫秒，而且一个阻塞的任务会时定时器任务延后执行。未被激活的页面，最低延迟会是1000毫秒

xmlHttpRequest 同样是通过异步回调的方式将执行任务，当请求被send时，渲染进程通过 IPC 调用通知网络进程发起请求和下载资源，当网络进程完成请求时通知渲染进程，渲染进程会将事件函数封装成任务添加进消息队列，然后等待执行

当页面要退出时，主线程会设置退出标志的变量，每次执行完任务时，会检查是否设置了退出标志，如果有就终端所有任务，并退出线程。

## 协程（Coroutine）与生成器（Generator）与await

### 生成器

生成器是 function* 声明的函数，在生成器函数内部执行一段代码，如果遇到yield关键字，那么JavaScript引擎将返回关键字后面的内容 给外部，并暂停该函数的执行，外部函数可以通过next方法恢复函数的执行

### 协程

之所以生成器可以暂停函数执行，是因为使用了协程，协程是一种比线程更加轻量级的存在，相当于跑在线程上的任务，一个线程可以有多个协程，但是同时只能执行一个协程，从A协程切换到B协程，A需要将主线程的控制权交给B协程，此时A协程被称为B协程的父协程

例如当生成器fn被调用时，主线程会创建fn协程，而且fn函数不会立即执行；当调用next时，主线程交给fn协程的执行，遇到 yield 关键字时会暂停协程，将yield后面的内容返还给主线程，并交出主线程控制权，当next再次被调用时，再次恢复到fn协程继续执行fn函数，以此往复；在 fn 遇到 return 时会关闭当前协程，在切换协程时会保存父协程的调用栈信息，恢复子协程的调用栈信息

### await

当父协程遇到 async 函数调用时，会保存外部作用域，并为这个函数创建子协程，将主线程的控制权交给子协程；当子协程遇到 await 关键字时，会将后面的内容包装成 promise，并加入到微任务队列，之后会暂停子协程，保存子协程的函数作用域，将主线程的控制权交给父协程，此时父协程会为这个 Promise 添加一个 then 回调函数来监听 Promise 状态，之后继续执行剩下流程；当检查点到来时，微任务会依次执行，当这个回调函数被激活时，会从父协程切换回子协程，并恢复函数作用域，同时将 resolve 的值传递给子协程，继续执行剩下内容，直到 async 函数执行完毕，然后退出协程，恢复到父协程


## DOM 树的构建过程

首先，网络进程在接收到响应头后，判断 Content—Type 是 HTML 类型时，会创建新的渲染进程，网络进程和渲染进程之间会建立共享的数据管道，网络进程接收到数据后会通过管道传输给渲染进程，渲染进程动态的接收字节流，最终解析成DOM树

渲染引擎内部有一个 HTMLParser 用来解析 HTML 代码，分词器会将字节流不断转换为 token，例如 tagToken 和 textToken，然后按顺序添加进 tokens 栈中，并根据进栈的 token 类型组成 DOM 树，DOM 树也会在一开始初始化为以 document 为根节点的 DOM 树结构，并将 startTag document 添加进栈底

例如 tagToken 一般会有开始标签和结束标签，如果进栈的是 startTag 时，会在 DOM 树中创建开始标签，遇到 textToken 时，会在这个标签中添加文本节点，或者再次遇到 startTag 时，会在此标签中创建子 tag 元素；当遇到 endTag 时，会在 DOM 树中创建结束标签，以此往复，这样就完成的树结构的创建

## HTTP 发展史

### HTTP0.9

HTTP0.9 只为了传输简单文本信息，只有请求行和响应行，用来解释数据内容的基本信息。

### HTTP1.0

HTTP1.0 添加了请求头和响应头，支持多种文件类型、语言版本、编码类型、压缩方式等内容的传输，还加入了状态码、缓存机制、用户代理等功能

### HTTP1.1

HTTP1.1 支持了在建立一次TCP连接即可进行多次HTTP请求，但是后一次的HTTP请求需要等待前一次HTTP的响应，也就是队头阻塞；还加入了cookie机制

### HTTP2.0

HTTP2 支持多路复用，解决的TCP的慢启动和HTTP1.1的队头阻塞问题，一个域名只启用一个TCP长连接，请求可以并行发出。经过二进制分帧层将请求变成唯一ID的帧发送出去，在接收到响应时，根据ID编号将数据帧提交给对应的请求；同时也可以设置请求的优先级，让服务器优先处理优先级高的请求；还可以将资源主动推送给浏览器端，例如HTML页面引用的CSS、JS资源；另外请求头和响应头也可以进行压缩；在分包传输的过程中，如果有丢包发生，那同样会阻塞后面的请求，变成对头阻塞

TCP连接会进行三次握手，以及HTTPS协议会进行TLS握手，通常会花费3-4个RTT时间

### HTTP3

HTTP3 为了解决TCP协议引发的问题，改用UDP协议实现了类似TCP的多路数据流、流量控制、传输可靠性功能，这个协议叫做 QUIC 协议，数据流可以单独传输，解决了TCP对头阻塞，由于基于UDP协议，所以可以实现快速握手


## XSS

### 储存型攻击
恶意代码储存在数据库中，用户访问页面加载数据库内容时触发

### 反射型攻击
在URL的query中注入恶意代码

### 基于DOM的攻击
劫持HTML页面来注入恶意代码

### 防范
过滤、转义恶意代码

设置CSP，禁止加载不明来源的资源，禁止内联脚本，上报攻击事件

## CSRF 跨站请求伪造

利用服务器漏洞以及用户登录状态实施攻击的行为

### 防范

#### SameSite

在cookie中设置SameSite防止cookie被窃取

Strict：完全禁止第三方cookie

Lax：相对宽松的规则，第三方站点的get请求可以携带cookie，post、img、iframe不可以携带cookie

None：会在任何情况下都携带cookie

#### Referer 和 Origin

除了设置SameSite外，还可以在服务器端验证请求来源的站点，根据请求头中的referer属性，判断请求来源地址，或者判断origin属性确定来源

#### CSRF token

服务端返回用于验证的token植入在页面中，第三方站点无法拿到token就无法请求成功

## 浏览器沙箱

由于不能保证任何网络环境都是安全的，避免因为浏览器漏洞而被不安全的网页、资源攻击，浏览器架构分开了浏览器进程和渲染进程两大部分，浏览器进程负责资源的下载、页面的显示、文件读取、cookie管理、cache管理等，渲染进程负责资源的解析，页面的绘制与生成，两者通过IPC调用来通信，渲染进程本身被隔离在沙箱环境中，如果不安全的页面或资源被运行，因为处在沙箱环境中，所以不会获得高级别的权限，不会危害用户的操作系统环境和数据

沙箱隔离了渲染进程对文件、缓存、cookie的直接读取，必须通过IPC调用与浏览器进程通信来操作，同样，渲染进程不可以直接访问网络，必须通过浏览器进程访问网络、下载资源，浏览器进程还会在请求前检查跨域、HTTPS信息等

### 渲染与交互

关于页面渲染和交互，渲染进程需要将页面渲染成位图发送至浏览器进程，浏览器进程通过狂口句柄复制到屏幕上；至于用户触发的操作事件也是浏览器进程把控，在经过调度后，将页面窗口内的事件转发给渲染进程，浏览器界面的事件由浏览器进程自己处理，这样可以防止渲染进程监控用户输入事件而造成安全问题

### 站点隔离

相同根域名和相同协议的地址会被认为是同一站点，会分贝在同一个渲染进程中执行，不同站点会放在不同的渲染进程中，而且在页面内嵌入的iframe也需要站点隔离，防止利用系统级别的漏洞发起攻击

## HTTPS

由于TCP连接过程中，很有可能会被中间人窃取请求信息，所以引入了加密协议HTTPS。在HTTPS的协议栈中，TCP与HTTP之间插入了一个安全层，数据经过安全层后会被加密或解密

加密的方式有很多中：

### 对称加密

最简单的加密方式，也就是数据的加密与解密都使用了同一个秘钥

浏览器端发起HTTP请求经过安全层后会进行握手操作：浏览器发送支持的加密套件以及一个随机数给服务器，服务器选择加密套件后返回加密套件和一个新的随机数，浏览器返回确认，服务器也返回确认，之后，浏览器会根据双方的随机数生成秘钥，然后使用加密套件加密数据，这时候就可以进行数据的传输了。这样还是会被中间人窃取秘钥信息，从而篡改数据

### 非对称加密

非对称加密算法使用两个秘钥，公钥用来加密，私钥用来解密，服务器会生成好公钥和私钥，在经过安全层时，浏览器向服务器发送加密套件列表，服务器将选择的加密套件和公钥传递给浏览器，浏览器向服务端发起确认，服务器向浏览器回应确认，之后浏览器发送数据时，会使用公钥加密数据，然后服务器使用私钥解密数据，所以公钥被中间人获取了也无法解密数据

非对称加密的缺点是加解密的效率太低，如果每次数据发送都是用非对称加密，则会影响数据传输的速度，还有就是公钥泄露的问题，虽然数据不会被解密，但是公钥被中间人拿到后，就无法保证浏览器传输给服务器的数据是真是的了

### 对称加密和非对称加密搭配使用

结合两者的特性，只要在秘钥传输时使用非对称加密，数据传输是使用对称加密就可以解决效率问题

在经过加密层时，浏览器发送对称加密套件列表、非对称加密套件列表和随机数，服务器返回选择的对称加密和非对称加密套件，以及一个随机数和公钥，浏览器使用这两个随机数计算出pre-master，并用公钥加密，发送给服务器，服务器使用私钥解密pre-master，返回确认消息，之后浏览器和服务器就使用这两个随机数和pre-master生成对称秘钥进行数据传输

#### 数字证书

如果浏览器访问的地址被中间人通过DNS劫持，由中间人的服务器向浏览器提供公钥，然后再转发给服务器，那么还是会有安全风险，无法保证公钥的正确性，也就是浏览器无法判断服务器是否是真实的

如果通过一个权威机构，为服务器颁发一个可信的数字，就可以证明服务器的身份了，这个机构就是CA(certificate authority)，这个证书叫数字证书(digital certificate)，数字证书可以证明服务器的身份，同时也包含了公钥信息

服务器不再直接返回公钥，而是返回了数字证书，其中包含了公钥，浏览器会校验证书的可靠性，之后才会继续传输数据，即使中间人拦截了请求，但是无法返回正确的数字证书，所以无法完成攻击

注册数字证书认证需要向CA提供公司、站点，以及公钥等信息，CA通过线上线下渠道核实信息的真实性后才会签发数字证书，CA使用私钥加密计算过后的信息摘要，得到数字签名，在浏览器接收到服务器发来的数字证书时，同样计算出信息摘要，然后使用CA的公钥对数字签名解密，得到的结果与信息摘要一致时，就说明这个数字证书是合法的，可以信任。
