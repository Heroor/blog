{"version":3,"sources":["webpack:///./src/docs/随想.md","webpack:///./src/docs \\.mdjs$","webpack:///./src/docs/解析 npm-package.json.mdjs","webpack:///./src/docs/linux学习笔记.mdjs","webpack:///./src/docs/chrome extension.mdjs","webpack:///./src/docs/对 javascript 执行环境的探索.mdjs","webpack:///./src/docs/浏览器原理.mdjs","webpack:///./src/docs/SVG Animation.mdjs","webpack:///./src/docs/MacOS 环境安装 MongoDB.mdjs","webpack:///./src/docs/ts.md","webpack:///./src/service/mock.js","webpack:///./src/docs/浅析 AMD CMD UMD CommonJS 模块规范.mdjs","webpack:///src/views/Article/ArticleDetail.vue","webpack:///./src/views/Article/ArticleDetail.vue?5031","webpack:///./src/views/Article/ArticleDetail.vue","webpack:///./src/docs ^\\.\\/.*$"],"names":["module","exports","info","title","poster","date","id","desc","content","wordCount","map","./MacOS 环境安装 MongoDB.mdjs","./SVG Animation.mdjs","./chrome extension.mdjs","./linux学习笔记.mdjs","./对 javascript 执行环境的探索.mdjs","./浅析 AMD CMD UMD CommonJS 模块规范.mdjs","./浏览器原理.mdjs","./解析 npm-package.json.mdjs","webpackContext","req","__webpack_require__","webpackContextResolve","Error","keys","Object","resolve","articleList","require","path","mdjs","slice","__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default","sort","a","b","Date","ArticleDetail","name","props","type","String","required","data","detail","methods","toggleSideBar","isShow","this","$store","commit","mutations","SWITCH_SIDE_NAV","mounted","_this","mock","find","v","then","res","assign_default","contentHtml","containerEle","$refs","contentContainer","innerHTML","$emit","beforeDestroy","Article_ArticleDetail","render","_vm","_h","$createElement","_c","_self","staticClass","_v","_s","ref","domProps","staticRenderFns","Component","normalizeComponent","ssrContext","__webpack_exports__","./ts.md","./随想.md"],"mappings":"uCAAAA,EAAAC,SACAC,MACAC,MAAA,KACAC,OAAA,GACAC,KAAA,aACAC,GAAA,aACAC,KAAA,aAEAC,QAAA,8yBAQAC,UAAA,6BChBA,IAAAC,GACAC,4BAAA,OACAC,uBAAA,OACAC,0BAAA,OACAC,mBAAA,OACAC,8BAAA,OACAC,sCAAA,OACAC,eAAA,OACAC,6BAAA,QAEA,SAAAC,EAAAC,GACA,OAAAC,EAAAC,EAAAF,IAEA,SAAAE,EAAAF,GACA,IAAAd,EAAAI,EAAAU,GACA,KAAAd,EAAA,GACA,UAAAiB,MAAA,uBAAAH,EAAA,MACA,OAAAd,EAEAa,EAAAK,KAAA,WACA,OAAAC,OAAAD,KAAAd,IAEAS,EAAAO,QAAAJ,EACAtB,EAAAC,QAAAkB,EACAA,EAAAb,GAAA,oDCxBAN,EAAAC,SACAC,MACAC,MAAA,sBACAC,OAAA,kBACAC,KAAA,aACAC,GAAA,aACAC,KAAA,wDAEAC,QAAA,i4dAoUAC,UAAA,4BC5UAT,EAAAC,SACAC,MACAC,MAAA,YACAC,OAAA,GACAC,KAAA,aACAC,GAAA,aACAC,KAAA,uCAEAC,QAAA,wmvBAsyBAC,UAAA,6BC9yBAT,EAAAC,SACAC,MACAC,MAAA,mBACAC,OAAA,yBACAC,KAAA,aACAC,GAAA,aACAC,KAAA,0BAEAC,QAAA,yqjBAuTAC,UAAA,4BC/TAT,EAAAC,SACAC,MACAC,MAAA,uBACAC,OAAA,qBACAC,KAAA,aACAC,GAAA,aACAC,KAAA,8EAEAC,QAAA,28wBAyWAC,UAAA,0BCjXAT,EAAAC,SACAC,MACAC,MAAA,YACAC,OAAA,GACAC,KAAA,aACAC,GAAA,aACAC,KAAA,oBAEAC,QAAA,66aAkPAC,UAAA,2BC1PAT,EAAAC,SACAC,MACAC,MAAA,gBACAC,OAAA,GACAC,KAAA,aACAC,GAAA,aACAC,KAAA,iDAEAC,QAAA,2mgCA6dAC,UAAA,2BCreAT,EAAAC,SACAC,MACAC,MAAA,qBACAC,OAAA,GACAC,KAAA,aACAC,GAAA,aACAC,KAAA,yBAEAC,QAAA,uxEA8DAC,UAAA,iDCtEAT,EAAAC,SACAC,MACAC,MAAA,KACAC,OAAA,GACAC,KAAA,aACAC,GAAA,aACAC,KAAA,gHAEAC,QAAA,grLA8EAC,UAAA,kGClFakB,EAJGC,UAEgBJ,OAEId,IAAI,SAAAmB,GACtC,IAAMC,EAAOF,eAAoBC,EAAKE,MAAM,IAC5C,OAAAC,OACKF,EAAK5B,MACRM,QAASsB,EAAKtB,QACdC,UAAWqB,EAAKrB,cAEjBwB,KAAK,SAACC,EAAGC,GAAJ,OAAW,IAAIC,KAAKD,EAAE9B,OAAS,IAAI+B,KAAKF,EAAE7B,4BCXlDL,EAAAC,SACAC,MACAC,MAAA,+BACAC,OAAA,GACAC,KAAA,aACAC,GAAA,aACAC,KAAA,0DAEAC,QAAA,qpVAqLAC,UAAA,gKChLA4B,GACAC,KAAA,gBACAC,OACAjC,IACAkC,KAAAC,OACAC,UAAA,IAGAC,KARA,WASA,OACAC,QACAzC,MAAA,GACAI,KAAA,GACAH,OAAA,GACAI,QAAA,GACAH,KAAA,GACAC,GAAA,QAIAuC,SACAC,cADA,SACAC,GACAC,KAAAC,OAAAC,OAAAC,EAAA,EAAAC,gBAAAL,KAGAM,QAzBA,WAyBA,IAAAC,EAAAN,KACA1C,EAAA0C,KAAA1C,GACA0C,KAAAO,OAAA,EAAAC,KAAA,SAAAC,GAAA,OAAAA,EAAAnD,UACAoD,KAAA,SAAAC,GACMC,IAANN,EAAAV,OAAAe,GAEA,IAAAE,EAAAP,EAAAV,OAAApC,QACAsD,EAAAR,EAAAS,MAAAC,iBACAH,GAAAC,IACAA,EAAAG,UAAAJ,GAAA,GAEAP,EAAAY,MAAA,iBAAAJ,GACAR,EAAAR,eAAA,OAIAqB,cAzCA,WA0CAnB,KAAAF,eAAA,KCpDesB,GADEC,OAFjB,WAA0B,IAAAC,EAAAtB,KAAauB,EAAAD,EAAAE,eAA0BC,EAAAH,EAAAI,MAAAD,IAAAF,EAAwB,OAAAE,EAAA,OAAiBE,YAAA,iBAA2BF,EAAA,MAAWE,YAAA,4BAAsCL,EAAAM,GAAAN,EAAAO,GAAAP,EAAA1B,OAAAzC,UAAAmE,EAAAM,GAAA,KAAAH,EAAA,OAA2DK,IAAA,mBAAAH,YAAA,aAAAI,UAA0Dd,UAAAK,EAAAO,GAAA,0BAA2CP,EAAAM,GAAA,KAAAH,EAAA,OAAwBE,YAAA,iBAA2BL,EAAAM,GAAAN,EAAAO,GAAAP,EAAA1B,OAAAvC,YAExX2E,oBCGjB,IAcAC,EAdyB5D,EAAQ,OAcjC6D,CACE7C,EACA+B,GATF,EAZA,SAAAe,GACE9D,EAAQ,QACRA,EAAQ,QACRA,EAAQ,SAaV,kBAEA,MAUe+D,EAAA,QAAAH,EAAiB,8BC5BhC,IAAAvE,GACAC,4BAAA,OACAC,uBAAA,OACAC,0BAAA,OACAC,mBAAA,OACAuE,UAAA,OACAtE,8BAAA,OACAC,sCAAA,OACAC,eAAA,OACAC,6BAAA,OACAoE,UAAA,QAEA,SAAAnE,EAAAC,GACA,OAAAC,EAAAC,EAAAF,IAEA,SAAAE,EAAAF,GACA,IAAAd,EAAAI,EAAAU,GACA,KAAAd,EAAA,GACA,UAAAiB,MAAA,uBAAAH,EAAA,MACA,OAAAd,EAEAa,EAAAK,KAAA,WACA,OAAAC,OAAAD,KAAAd,IAEAS,EAAAO,QAAAJ,EACAtB,EAAAC,QAAAkB,EACAA,EAAAb,GAAA","file":"static/js/0.9c92c4bd409ad91e647d.js","sourcesContent":["module.exports = {\n    info: {\n  title: '随想',\n  poster: '',\n  date: '2020-09-04',\n  id: '2020-09-04',\n  desc: 'Mig 引发的思考'\n},\n    content: `<p>几个月前，我开发了 Mig 的部分功能，由于跻身其他事情(主要是懒)被搁置许久了。</p>\n<p>前几天有人询问我 Mig 的原理，其实原理很简单，我就把代码实现告诉了他，他知道后表示了“这些技术并不难啊，没有什么高深技术”之类的话。</p>\n<p>他说的没错，说到实现原理，确实没用什么高深罕见的技术，仅仅用了简单普通的技术就实现了.</p>\n<p>今天碰巧看到乔布斯早年说的一些话，顿时想到一些事情：</p>\n<p>我们在做一个产品时，是否一开始是从用户的角度出发去，然后才通过用户体验反推出我们需要用到的技术，是否时刻在思考用户需要的是什么，我们怎样才能给用户带来更多的利益，怎样去引导用户体验以及带给用户真正想要的，而不是单纯在系统考虑加入什么吊炸天的技术、内部采取多么复杂的设计，如果产品需要，那这些将是必然的，而不是先于产品去设计的。</p>\n<p>开始做 Mig 之前我做了许多的调研，体验过许多同类的插件，查遍了拦截请求的各种可能，思考了假如使用中间人服务，如何免去用户手动控制服务启动与关闭，为了减去用户的操作，甚至我还想过在 Chrome 中直接跑 nodejs，后来了解到使 Chrome 调用本地应用程序，理论上可以实现，但是这始终需要用户除扩展外再安装一个应用程序，这个体验极其不友好也不方便，还依赖系统环境，所以放弃；使用 ChromeAPI 拦截，却只能在控制台界面修改响应内容，之前考虑到使用性最终选择 option 页，所以也放弃了；在查了很多资料后，反而改写 XMLHttpRequest 是最简单最合适的方式，但是如何使页面与扩展顺畅的通信又是一大难题，庆幸的是我也解决了，还有其他一些问题等等就不再叙述了。</p>\n<p>事实上一个产品的价值，更体现在一个点以及点的落地，从用户体验回归到技术实现，如果最简洁的实现却是最适合的，那不要犹豫了，选择它吧。</p>\n`,\n    wordCount: 762\n  }\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/docs/随想.md\n// module id = +JY3\n// module chunks = 0 1","var map = {\n\t\"./MacOS 环境安装 MongoDB.mdjs\": \"PU9U\",\n\t\"./SVG Animation.mdjs\": \"Jz86\",\n\t\"./chrome extension.mdjs\": \"7K+T\",\n\t\"./linux学习笔记.mdjs\": \"4oDU\",\n\t\"./对 javascript 执行环境的探索.mdjs\": \"7afm\",\n\t\"./浅析 AMD CMD UMD CommonJS 模块规范.mdjs\": \"h4K6\",\n\t\"./浏览器原理.mdjs\": \"I4L2\",\n\t\"./解析 npm-package.json.mdjs\": \"4MyP\"\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\tvar id = map[req];\n\tif(!(id + 1)) // check for number or string\n\t\tthrow new Error(\"Cannot find module '\" + req + \"'.\");\n\treturn id;\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"/HJh\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/docs \\.mdjs$\n// module id = /HJh\n// module chunks = 0 1","module.exports = {\n    info: {\n  title: '解析 npm-package.json',\n  poster: '/static/npm.png',\n  date: '2018-07-16',\n  id: '2018-07-16',\n  desc: 'npm-package.json 是描述一个 npm 项目的文件，它包含了很多字段，表示了项目的各种定义'\n},\n    content: `<h2>前言</h2>\n<p><code>npm</code> 是 <code>nodejs</code> 的包管理工具，它让 <code>javascript</code> 开发者可以方便的分享、复用代码，并以强大的方式组装构建它们，这些可以重复引入的代码被称为 包（package）或模块（module），作为项目的依赖项独立存在。如今 <code>npm</code> 上已有 <code>700,000+</code> 个包，其中有很多优秀的、受开发者欢迎的包，例如 <code>lodash</code>、<code>webpack</code>、<code>react</code>、<code>express</code> 等，世界各地的 <code>javascript</code> 开发者都在使用 <code>npm</code> 或贡献代码，任何人都可以发布一个 <code>npm</code> 包。</p>\n<p>管理本地安装的 <code>npm</code> 包的最佳方法是创建一个 <code>package.json</code> 文件，一个 <code>package.json</code> 文件可以:</p>\n<ol>\n<li>\n<p>列出项目依赖的包。</p>\n</li>\n<li>\n<p>指定项目所使用的依赖项的版本。</p>\n</li>\n<li>\n<p>重新构建更加方便，更容易与他人共享开发。</p>\n</li>\n</ol>\n<p>使用 <code>npm init -y</code> 可以快速创建一个 <code>package.json</code>：</p>\n<pre><code class=\"hljs\" lang=\"json\">$ npm init -y\n\n// ./package.json\n{\n  <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"app\"</span>,\n  <span class=\"hljs-attr\">\"version\"</span>: <span class=\"hljs-string\">\"1.0.0\"</span>,\n  <span class=\"hljs-attr\">\"description\"</span>: <span class=\"hljs-string\">\"\"</span>,\n  <span class=\"hljs-attr\">\"main\"</span>: <span class=\"hljs-string\">\"index.js\"</span>,\n  <span class=\"hljs-attr\">\"scripts\"</span>: {\n    <span class=\"hljs-attr\">\"test\"</span>: <span class=\"hljs-string\">\"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"</span>\n  },\n  <span class=\"hljs-attr\">\"repository\"</span>: {\n    <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"git\"</span>,\n    <span class=\"hljs-attr\">\"url\"</span>: <span class=\"hljs-string\">\"git+https://github.com/ben/app.git\"</span>\n  },\n  <span class=\"hljs-attr\">\"keywords\"</span>: [],\n  <span class=\"hljs-attr\">\"author\"</span>: <span class=\"hljs-string\">\"\"</span>,\n  <span class=\"hljs-attr\">\"license\"</span>: <span class=\"hljs-string\">\"ISC\"</span>,\n  <span class=\"hljs-attr\">\"bugs\"</span>: {\n    <span class=\"hljs-attr\">\"url\"</span>: <span class=\"hljs-string\">\"https://github.com/ben/app/issues\"</span>\n  },\n  <span class=\"hljs-attr\">\"homepage\"</span>: <span class=\"hljs-string\">\"https://github.com/ben/app#readme\"</span>\n}\n</code></pre>\n<p>可以为 <code>init</code> 命令设置多个配置选项：</p>\n<pre><code class=\"hljs\" lang=\"bash\">&gt; npm <span class=\"hljs-built_in\">set</span> init.author.email <span class=\"hljs-string\">\"ben@npmjs.com\"</span>\n&gt; npm <span class=\"hljs-built_in\">set</span> init.author.name <span class=\"hljs-string\">\"ag_dubs\"</span>\n&gt; npm <span class=\"hljs-built_in\">set</span> init.license <span class=\"hljs-string\">\"MIT\"</span>\n</code></pre>\n<blockquote>\n<p>注意：如果 <code>package.json</code> 中没有 <code>description</code> 字段，则 <code>package.json</code> 使用 <code>README.md</code> 或 <code>README</code> 的第一行。<code>description</code> 可帮助开发者在搜索 <code>npm</code> 时找到你的包，因此在 <code>package.json</code> 中编写描述非常有用。</p>\n</blockquote>\n<h2>属性</h2>\n<p><code>package.json</code> 包含了很多属性，当发布一个 <code>npm</code> 包时，<code>name</code> 和 <code>version</code> 字段是必填的。</p>\n<ol>\n<li>\n<p>name：当然就是这个 <code>npm</code> 包的名字。</p>\n<p><code>name</code> 的命名不能以点或下划线开始，不能有大写字母和空格，并且不能与 <code>node</code> 的核心模块相同（例如 <code>path</code>、<code>fs</code>）；考虑到 <code>name</code> 作为一个 <code>npm</code> 包的名字，它可能会出现在 <code>url</code> 引用中、命令行参数中，或是作为一个文件夹的名字，所以有很多限制，非安全的字符是不能出现的，同时也要尽量保持简短。</p>\n<blockquote>\n<p>当你想要发布一个 <code>npm</code> 包时，最好先在<a href=\"https://www.npmjs.com/\">npm</a>搜索你的包名是否已经被占用了。</p>\n</blockquote>\n</li>\n<li>\n<p>version：版本号，使用了 <a href=\"https://github.com/npm/node-semver\">node-semver</a> 管理。</p>\n<p>例如 <code>'1.0.4'</code>，<code>'12.4.5'</code>，版本号有三位数字，分别代表不同的含义：</p>\n<ul>\n<li>\n<p><code>'X.0.0'</code>：表示 <code>主版本</code>，有较大变动，但是向下不兼容的</p>\n</li>\n<li>\n<p><code>'0.Y.0'</code>：表示 <code>次版本</code>，有新增功能，并且向下兼容</p>\n</li>\n<li>\n<p><code>'0.0.Z'</code>：表示 <code>补丁版本</code>，一般是修复了上个版本的bug</p>\n</li>\n</ul>\n<blockquote>\n<p>当发布 <code>npm</code> 包的迭代时，版本号必需高于之前的版本。</p>\n</blockquote>\n</li>\n<li>\n<p>description：对这个包的表述。有利于使用者快速了解这个包的作用，因为它会出现在 <code>npm</code> 搜索结果里，而 <code>README.md</code> 不会。</p>\n</li>\n<li>\n<p>keywords：包的关键字。同样利于包出现在搜索结果里。</p>\n</li>\n<li>\n<p>homepage：项目的主页的链接，例如 <code>GitHub</code> 地址。</p>\n</li>\n<li>\n<p>bugs：跟踪或提出项目问题的途径，可以是 <code>GitHub</code> 的 <code>issues</code> 地址及你的邮箱:</p>\n<pre><code class=\"hljs\" lang=\"json\"><span class=\"hljs-string\">\"bugs\"</span>: <span class=\"hljs-string\">\"https://github.com/ben/npm-program/issues\"</span>\n</code></pre>\n<pre><code class=\"hljs\" lang=\"json\"><span class=\"hljs-string\">\"bugs\"</span>: {\n    <span class=\"hljs-attr\">\"url\"</span> : <span class=\"hljs-string\">\"https://github.com/ben/npm-program/issues\"</span>,\n    <span class=\"hljs-attr\">\"email\"</span> : <span class=\"hljs-string\">\"ben@gmail.com\"</span>\n}\n</code></pre>\n</li>\n<li>\n<p>license：许可类型。</p>\n<p>开源世界的软件并不都是可以自由使用的，不同的许可协议赋予了使用者不同的权利，<code>npm</code> 的许可类型多达300多种，通过 <a href=\"https://opensource.org/about\">OSI</a> 认证的有80种，比较常见的开源许可有 <code>MIT</code>、<code>ISC</code>、<code>GPL</code>、<code>Apache</code>等。</p>\n<blockquote>\n<p>参考自：<a href=\"https://github.phodal.com/\">《GitHub漫游指南》</a></p>\n</blockquote>\n</li>\n<li>\n<p>author、contributors：作者或贡献者。</p>\n<p>以一个 <code>people</code> 对象为单位，包含<code>name</code>、<code>url</code>、<code>email</code>字段；<code>author</code> 是一个 <code>people</code> 对象，<code>contributors</code> 是多个。</p>\n<pre><code class=\"hljs\" lang=\"json\"><span class=\"hljs-string\">\"author\"</span>: {\n    <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"ben\"</span>,\n    <span class=\"hljs-attr\">\"url\"</span>: <span class=\"hljs-string\">\"http://www.ben.com\"</span>,\n    <span class=\"hljs-attr\">\"email\"</span>: <span class=\"hljs-string\">\"ben@gmail.com\"</span>\n}\n</code></pre>\n<pre><code class=\"hljs\" lang=\"json\"><span class=\"hljs-string\">\"contributors\"</span>: [{\n    <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"ben\"</span>,\n    <span class=\"hljs-attr\">\"url\"</span>: <span class=\"hljs-string\">\"http://www.ben.com\"</span>,\n    <span class=\"hljs-attr\">\"email\"</span>: <span class=\"hljs-string\">\"ben@gmail.com\"</span>\n}]\n</code></pre>\n<pre><code class=\"hljs\" lang=\"json\">// 同样可以简写为字符串的形式，npm会自动解析\n<span class=\"hljs-string\">\"author\"</span>: <span class=\"hljs-string\">\"ben &lt;ben@gmail.com&gt; (http://www.ben.com)\"</span>\n</code></pre>\n</li>\n<li>\n<p>files：描述了 <code>npm</code> 包当做依赖安装时要包含的目录，默认会包含全部文件。</p>\n<p>// vue package.json 中的 files</p>\n<pre><code class=\"hljs\" lang=\"json\"><span class=\"hljs-string\">\"files\"</span>: [\n    <span class=\"hljs-string\">\"src\"</span>,\n    <span class=\"hljs-string\">\"dist/*.js\"</span>,\n    <span class=\"hljs-string\">\"types/*.d.ts\"</span>\n]\n</code></pre>\n<p>也可以声明一个 <code>.npmignore</code> 文件来确定包含的文件。</p>\n</li>\n<li>\n<p>main：指定程序的入口文件。</p>\n<p>在 <code>require('myapp')</code> 这个模块时，<code>main</code> 字段的文件将被返回。</p>\n<p>使用 <code>npm init</code> 或 <code>yarn init</code> 初始化时会默认为项目根目录下的 <code>index.js</code>。</p>\n</li>\n<li>\n<p>bin：用来指定可执行文件的路径。</p>\n<p>如果你的项目有可执行文件，就需要在 <code>bin</code> 字段中指定文件路径作为映射，当项目作为依赖安装时，<code>npm</code> 会在全局或 <code>./node_modules/.bin/</code> 安装这些可执行文件。</p>\n<pre><code class=\"hljs\" lang=\"json\"><span class=\"hljs-string\">\"bin\"</span>: {\n    <span class=\"hljs-attr\">\"myapp\"</span>: <span class=\"hljs-string\">\"./cli.js\"</span>\n}\n</code></pre>\n<blockquote>\n<p>可执行脚本需要以 <code>#!/usr/bin/env node</code> 开头。</p>\n</blockquote>\n</li>\n<li>\n<p>repository：标识项目代码所在的位置，可以帮助开发者找到项目或为项目贡献代码。</p>\n<pre><code class=\"hljs\" lang=\"json\"><span class=\"hljs-string\">\"repository\"</span>: {\n    <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"git\"</span>,\n    <span class=\"hljs-attr\">\"url\"</span>: <span class=\"hljs-string\">\"https://github.com/npm/cli.git\"</span>\n}\n</code></pre>\n<p><code>npm</code> 可识别的快捷语法：</p>\n<pre><code class=\"hljs\" lang=\"js\"><span class=\"hljs-string\">\"repository\"</span>: <span class=\"hljs-string\">\"npm/npm\"</span>\n<span class=\"hljs-string\">\"repository\"</span>: <span class=\"hljs-string\">\"github:user/repo\"</span>\n<span class=\"hljs-string\">\"repository\"</span>: <span class=\"hljs-string\">\"gist:11081aaa281\"</span>\n<span class=\"hljs-string\">\"repository\"</span>: <span class=\"hljs-string\">\"bitbucket:user/repo\"</span>\n<span class=\"hljs-string\">\"repository\"</span>: <span class=\"hljs-string\">\"gitlab:user/repo\"</span>\n</code></pre>\n</li>\n<li>\n<p>scripts：一个包含特定脚本命令的对象。</p>\n<p><code>key</code> 是命令的事件名，<code>value</code> 是执行时所运行的命令。</p>\n<pre><code class=\"hljs\" lang=\"json\"><span class=\"hljs-string\">\"scripts\"</span>: {\n    <span class=\"hljs-attr\">\"dev\"</span>: <span class=\"hljs-string\">\"node app.js\"</span>\n}\n</code></pre>\n<p>如果根目录中有 <code>server.js</code> 文件，那 scripts 的默认值如下：</p>\n<pre><code class=\"hljs\" lang=\"json\"><span class=\"hljs-string\">\"scripts\"</span>: {\n    <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-string\">\"node server.js\"</span>\n}\n</code></pre>\n</li>\n<li>\n<p>dependencies：项目依赖的文件组成的对象，键值对将包名映射到了版本范围，一般描述为生产环境的依赖关系。</p>\n<p><code>-S</code> 或 <code>--save</code> 添加的依赖会被加到这里来：</p>\n<pre><code class=\"hljs\" lang=\"js\">$ npm i vue --save\n\n<span class=\"hljs-string\">\"dependencies\"</span>: {\n    <span class=\"hljs-string\">\"vue\"</span>: <span class=\"hljs-string\">\"^2.5.2\"</span>\n}\n</code></pre>\n<pre><code>version  版本必须完全匹配\n&gt;version  必须大于此版本\n&gt;=version  大于等于此版本\n&lt;version  小于此版本\n&lt;=version  小于等于系版本\n~version  约等于此版本\n^version  兼容版本\n1.2.X  可以是 1.2.0, 1.2.1, ..., 而不是1.3.0\nhttp://...  以 URL 作为依赖\n*  匹配任何版本\n&quot;&quot;  空字符串和 * 是一样的\nversion1 - version2  相当于 &gt;=version1 &lt;=version2\nrange1 || range2  当range1可用时用range1，否则用range2\ngit...  使用 Git URLs 作为依赖\nuser/repo  同上\ntag  使用一个公开的 tag 版本\npath/path/path  使用本地路径\n</code></pre>\n<pre><code class=\"hljs\" lang=\"json\"><span class=\"hljs-string\">\"dependencies\"</span>: {\n    <span class=\"hljs-attr\">\"foo\"</span>: <span class=\"hljs-string\">\"1.0.0 - 2.9999.9999\"</span>,\n    <span class=\"hljs-attr\">\"bar\"</span>: <span class=\"hljs-string\">\"&gt;=1.0.2 &lt;2.1.2\"</span>,\n    <span class=\"hljs-attr\">\"baz\"</span>: <span class=\"hljs-string\">\"&gt;1.0.2 &lt;=2.3.4\"</span>,\n    <span class=\"hljs-attr\">\"boo\"</span>: <span class=\"hljs-string\">\"2.0.1\"</span>,\n    <span class=\"hljs-attr\">\"qux\"</span>: <span class=\"hljs-string\">\"&lt;1.0.0 || &gt;=2.3.1 &lt;2.4.5 || &gt;=2.5.2 &lt;3.0.0\"</span>,\n    <span class=\"hljs-attr\">\"asd\"</span>: <span class=\"hljs-string\">\"http://asdf.com/asdf.tar.gz\"</span>,\n    <span class=\"hljs-attr\">\"til\"</span>: <span class=\"hljs-string\">\"~1.2\"</span>,\n    <span class=\"hljs-attr\">\"elf\"</span>: <span class=\"hljs-string\">\"~1.2.3\"</span>,\n    <span class=\"hljs-attr\">\"two\"</span>: <span class=\"hljs-string\">\"2.x\"</span>,\n    <span class=\"hljs-attr\">\"thr\"</span>: <span class=\"hljs-string\">\"3.3.x\"</span>,\n    <span class=\"hljs-attr\">\"lat\"</span>: <span class=\"hljs-string\">\"latest\"</span>,\n    <span class=\"hljs-attr\">\"dyl\"</span>: <span class=\"hljs-string\">\"file:../dyl\"</span>\n}\n\n</code></pre>\n</li>\n<li>\n<p>devDependencies：如果有人在项目中想使用你的模块，那么一定不希望也不需要下载你模块中的开发或测试环境依赖，这种情况下，最好把这些附加依赖映射到 <code>devDependencies</code> 字段中。</p>\n<p><code>-D</code> 或 <code>--save-dev</code> 添加的依赖会被加到这里来：</p>\n<pre><code class=\"hljs\" lang=\"json\">$ npm i stylus --save-dev\n\n<span class=\"hljs-string\">\"devDependencies\"</span>: {\n    <span class=\"hljs-attr\">\"stylus\"</span>: <span class=\"hljs-string\">\"^0.54.5\"</span>\n}\n</code></pre>\n</li>\n<li>\n<p>peerDependencies、bundledDependencies、optionalDependencies</p>\n</li>\n<li>\n<p>engines：指定项目的 <code>nodejs</code> 版本（例如 webpack 4.0.0+ 只支持 nodejs 6.11.5 以上）；如果省略了 <code>engines</code> 字段或指定为 <code>&quot;*&quot;</code>，则表示可以支持任何版本。</p>\n<blockquote>\n<p>注意：除非用户设置了 <code>engine-strict</code> 标识， 否则此字段仅供参考，并且将项目作为依赖项时才起作用。<code>engineStrict</code> 字段已经在npm 3.0.0 是移除了，如果想使用可以用 <a href=\"https://www.npmjs.com/package/engine-strict\">engine-strict</a> 这个模块</p>\n</blockquote>\n<p>当然除了指定 <code>nodejs</code> 版本，还可以指定 <code>npm</code> 版本：</p>\n<pre><code class=\"hljs\" lang=\"json\"><span class=\"hljs-string\">\"engines\"</span>: {\n    <span class=\"hljs-attr\">\"node\"</span>: <span class=\"hljs-string\">\"&gt;=6.11.5\"</span>,\n    <span class=\"hljs-attr\">\"npm\"</span>: <span class=\"hljs-string\">\"~5.0.0\"</span>\n}\n</code></pre>\n</li>\n<li>\n<p>os：为模块指定操作系统。</p>\n<pre><code class=\"hljs\" lang=\"json\"><span class=\"hljs-string\">\"os\"</span>: [<span class=\"hljs-string\">\"darwin\"</span>, <span class=\"hljs-string\">\"linux\"</span>]\n\n// 如果你想设置黑名单，只需要在操作系统前加 '!'\n<span class=\"hljs-string\">\"os\"</span>: [<span class=\"hljs-string\">\"!win32\"</span>]\n</code></pre>\n<blockquote>\n<p>主机操作系统由 <code>process.arch</code> 确定</p>\n</blockquote>\n</li>\n<li>\n<p>cpu：如果你的代码仅可以在某些cpu体系上运行，那么这个字段可以帮到你。</p>\n<pre><code class=\"hljs\" lang=\"json\"><span class=\"hljs-string\">\"cpu\"</span> : [ <span class=\"hljs-string\">\"x64\"</span>, <span class=\"hljs-string\">\"ia32\"</span> ]\n\n// 同样支持黑名单：\n<span class=\"hljs-string\">\"cpu\"</span> : [ <span class=\"hljs-string\">\"!arm\"</span>, <span class=\"hljs-string\">\"!mips\"</span> ]\n</code></pre>\n<blockquote>\n<p>主机架构由 <code>process.arch</code> 确定</p>\n</blockquote>\n</li>\n<li>\n<p>private：如果你设置了 <code>private</code> 为 <code>true</code>，那么 <code>npm</code> 将拒绝发布它。这是一种防止私有库被意外发布的方法。</p>\n</li>\n</ol>\n<p>当运行 <code>npm install</code> 时，<code>npm</code> 会根据 <code>package.json</code> 的 <code>dependencies</code> 与 <code>devDependencies</code> 字段映射的所有依赖版本，将依赖包安装到 <code>./node_modules/</code> 中。</p>\n<h2>定制 <code>package.json</code></h2>\n<p>如果你希望敲下 <code>npm init</code> 就能生成你想要的 <code>package.json</code>，那么你可以定制你的 <code>package.json</code>：</p>\n<p>创建 <code>~/.npm-init.js</code> 文件:</p>\n<pre><code class=\"hljs\" lang=\"js\"><span class=\"hljs-built_in\">module</span>.exports = {\n  <span class=\"hljs-attr\">customField</span>: <span class=\"hljs-string\">'Custom Field'</span>,\n  <span class=\"hljs-attr\">otherCustomField</span>: <span class=\"hljs-string\">'This field is really cool'</span>\n}\n</code></pre>\n<pre><code class=\"hljs\" lang=\"js\">$ npm init\n\n<span class=\"hljs-comment\">// ./package.json</span>\n{\n  <span class=\"hljs-attr\">customField</span>: <span class=\"hljs-string\">'Custom Field'</span>,\n  <span class=\"hljs-attr\">otherCustomField</span>: <span class=\"hljs-string\">'This field is really cool'</span>\n}\n</code></pre>\n<p>使用 <code>prompt</code> 加入自定义问题：</p>\n<pre><code class=\"hljs\" lang=\"js\"> <span class=\"hljs-built_in\">module</span>.exports = prompt(<span class=\"hljs-string\">\"what's your favorite flavor of ice cream, buddy?\"</span>, <span class=\"hljs-string\">\"I LIKE THEM ALL\"</span>);\n</code></pre>\n<h2>发布一个 npm 包</h2>\n<blockquote>\n<p>在此之前，你需要注册一个 <code>npm</code> 账号。</p>\n</blockquote>\n<ul>\n<li>\n<p>配置好 <code>package.json</code> 文件，为你的包起一个好名字</p>\n</li>\n<li>\n<p>检查项目的开源许可类型，减少一些纠纷</p>\n</li>\n<li>\n<p>最好有一些单元测试，让开发者放心食用</p>\n</li>\n<li>\n<p>编写一个清晰的 <code>README.md</code>，项目的使用文档，花里胡哨的配图</p>\n</li>\n</ul>\n<pre><code class=\"hljs\" lang=\"bash\"><span class=\"hljs-comment\"># 登录 npm 账号</span>\n$ npm login\n\n<span class=\"hljs-comment\"># 输入用户名 密码</span>\nUsername: ben\nPassword:\nEmail: (this IS public) ben@npmjs.com\n\n<span class=\"hljs-comment\"># 登录成功</span>\nLogged <span class=\"hljs-keyword\">in</span> as ben on https://registry.npmjs.org/.\n\n<span class=\"hljs-comment\"># 发布</span>\n$ npm publish\n</code></pre>\n<p><img src=\"https://img.shields.io/badge/package-json-ff69b4.svg\" alt=\"http://shields.io/\"></p>\n`,\n    wordCount: 7509\n  }\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/docs/解析 npm-package.json.mdjs\n// module id = 4MyP\n// module chunks = 0 1","module.exports = {\n    info: {\n  title: 'Linux学习笔记',\n  poster: '',\n  date: '2020-03-07',\n  id: '2020-03-07',\n  desc: '学习linux的常用命令，文件系统，权限系统，软件安装，远程登录等知识'\n},\n    content: `<h1>linux-note</h1>\n<h2>命令</h2>\n<h3>关于参数</h3>\n<p>参数常常跟在命令后面，用于改变命令的行为</p>\n<ol>\n<li>短参数\n<code>-p</code>  短参数 一个连字符与一个字母\n<code>-p -a</code> 多个短参数\n<code>-pasf</code> 多个短参数可以合并在一起\n<code>-p 10</code>  短参数传递值</li>\n<li>长参数\n<code>—para</code> 长参数 两个连字符与多个字母\n<em>多个长参数不可合并</em>\n<code>—para=10</code> 长参数传递值</li>\n</ol>\n<ul>\n<li>\n<p><code>&lt;xxx&gt;</code> 必填内容</p>\n</li>\n<li>\n<p><code>[xxx]</code> 选填内容</p>\n</li>\n<li>\n<p><code>&lt;xxx|xxx&gt;</code> 至少选择一项</p>\n</li>\n<li>\n<p><code>[xxx]...</code> 可多次重复</p>\n</li>\n<li>\n<p><code>&amp;&amp;</code> 前面命令成功，才执行后面命令</p>\n</li>\n<li>\n<p><code>||</code> 前面命令失败，才执行后面命令</p>\n</li>\n<li>\n<p><code>;</code> 执行完前面命令就执行后面命令</p>\n</li>\n</ul>\n<h3>常用命令</h3>\n<p><code>whoami</code> 显示当前用户</p>\n<p><code>hostname</code> 显示主机名</p>\n<p><code>date</code> 显示日期</p>\n<p><code>history</code> 历史运行过的命令</p>\n<p><code>clear</code> 清屏</p>\n<p><code>exit</code> 退出终端或当前账户</p>\n<p><code>pwd</code> 显示当前工作目录 <code>print working directory</code></p>\n<p><code>which</code> 显示一个命令的对应可执行文件的路径</p>\n<ul>\n<li><code>which pwd</code></li>\n</ul>\n<h3>文件操作</h3>\n<h4>基本命令</h4>\n<p><code>ls</code> 列举目录下的文件和目录 <em><code>list</code></em></p>\n<ul>\n<li><code>ls</code> 列举当前目录</li>\n<li><code>ls dir</code> 列举 <code>dir</code> 目录</li>\n<li><code>-a</code> 显示全部文件、目录，包括隐藏文件、目录 (all)。以 <code>.</code> 开头的是隐藏文件或目录：<code>.git</code></li>\n<li><code>-l</code> 显示详细信息的列表</li>\n<li><code>-t</code> 按最近修改时间排序</li>\n<li><code>-h</code> 以便于阅读的方式展示</li>\n<li><code>-i</code> 显示文件的 <em><code>inode</code></em></li>\n</ul>\n<p><code>cd</code> 切换目录 <em><code>change directory</code></em></p>\n<ul>\n<li><code>cd /</code> 跳转至根目录</li>\n<li><code>cd ../</code> 跳转至上级目录</li>\n</ul>\n<p><code>du</code> 统计j目录的大小，他会向下遍历每一层目录 <em><code>disk usage</code></em></p>\n<ul>\n<li>\n<p><code>du</code> 显示当前目录的大小</p>\n</li>\n<li>\n<p><code>du test.txt</code>  显示 <code>test.txt</code> 文件的大小</p>\n</li>\n<li>\n<p><code>du -a</code> 统计目录以及文件的大小</p>\n</li>\n<li>\n<p><code>du -s</code> 至显示总计大小</p>\n</li>\n</ul>\n<p><code>cat</code> 显示文件内容，显示文件所有内容</p>\n<ul>\n<li><code>cat -n test.txt</code> 显示行号</li>\n<li><code>cat 1.txt 2.txt</code>  显示多个文件内容</li>\n</ul>\n<p><code>less</code> 读取部分文件内容</p>\n<p>浏览模式下的快捷键：</p>\n<ul>\n<li><code>d</code> 前进半页</li>\n<li><code>b</code> 后退一页</li>\n<li><code>y</code> 后退一行</li>\n<li><code>u</code> 后退半页</li>\n<li><code>q</code> 停止读取</li>\n<li><code>=</code> 显示当前在文件中什么位置</li>\n<li><code>/</code> 搜索内容</li>\n<li><code>n</code> 显示下一个搜索匹配结果</li>\n<li><code>N</code> 显示上一个搜索匹配结果</li>\n</ul>\n<p><code>head</code> 显示文件开头</p>\n<ul>\n<li><code>-n</code> 显示行号</li>\n</ul>\n<p><code>tail</code> 显示文件结尾</p>\n<ul>\n<li><code>-n</code> 显示行号</li>\n<li><code>-f</code> 实时显示文件追加的内容</li>\n<li><code>-s</code> 指定检查文件更新的频率 默认为1秒</li>\n</ul>\n<p><code>touch</code> 修改文件的创建时间或修改时间；如果文件不存在，就会创建这个文件，所以可以用这个命令来创建文件</p>\n<ul>\n<li>\n<p><code>touch newfile</code> 创建 <code>newfile</code>  文件</p>\n</li>\n<li>\n<p><code>touch file1 file2</code> 同时创建多个文件</p>\n</li>\n<li>\n<p><code>touch &quot;new file&quot;</code> 创建文件名带空格的文件，需要使用双引号</p>\n</li>\n</ul>\n<p><code>mkdir</code> 创建目录</p>\n<ul>\n<li>\n<p><code>mkdir newfloder</code> 创建 <code>newfloder</code>  目录</p>\n</li>\n<li>\n<p><code>mkdir floder1 floder2</code> 同时创建多个目录</p>\n</li>\n<li>\n<p><code>mkdir &quot;new floder&quot;</code> 创建目录名带空格的目录，需要使用双引号</p>\n</li>\n<li>\n<p><code>-p</code> 递归创建目录结构 <code>mkdir a/b/c</code></p>\n</li>\n</ul>\n<p><code>cp</code> 拷贝文件或目录</p>\n<ul>\n<li><code>cp file1 file2</code> 复制 <code>file1</code> 为 <code>file2</code></li>\n<li><code>cp file floder</code> 拷贝 <code>file</code> 至 <code>floder</code> 目录下</li>\n<li><code>-r</code> 递归拷贝，也就是拷贝目录</li>\n<li><code>cp *.img images</code> 将当前目录下所有以 <code>.img</code> 结尾的文件拷贝到 <code>images</code> 目录</li>\n<li><code>cp icon-* images</code> 将当前目录下所有以 <code>icon-</code> 开头的文件拷贝到 <code>images</code> 目录</li>\n</ul>\n<p><code>mv</code> 移动文件或目录</p>\n<ul>\n<li><code>mv file floder/</code> 将文件 <code>file</code> 移动至 <code>floder/</code> 目录下</li>\n<li><code>mv file1 file2</code>  将 <code>file1</code> 重命名为 <code>file2</code></li>\n</ul>\n<p><code>rm</code> 删除文件或目录</p>\n<ul>\n<li><code>rm file</code> 删除当前目录下的 <code>file</code> 文件</li>\n<li><code>rm fil1 fil2</code> 同时删除多个文件</li>\n<li><code>-i</code> 询问是否删除</li>\n<li><code>-f</code> 强制删除，不会询问</li>\n<li><code>-r</code> 递归删除</li>\n</ul>\n<p><code>rmdir</code> 删除空目录</p>\n<p><code>ln</code> 创建链接 <em><code>link</code></em></p>\n<blockquote>\n<p>linux链接分为 硬链接 和 软连接 两种</p>\n<p>硬链接：（一般只能创建文件的硬链接）不同的文件名指向相同的文件内容 <code>inode</code> ，当修改一个文件时，也是在修改另一个文件；删除其中一个文件，不会对其他文件造成影响</p>\n<p>软连接：（可以指向文件或目录）创建一个文件，指向某文件的文件名，相当于快捷方式；删除软链接，源文件不收影响，但是删除源文件，软链接会失效</p>\n</blockquote>\n<ul>\n<li><code>ln file1 file2</code> 创建 <code>file1</code> 的硬链接 <code>file2</code></li>\n<li><code>-s</code> 创建软链接 symbolic</li>\n<li><code>ln -s file1 file2</code> 创建 <code>file1</code>  的软链接 <code>file2</code></li>\n</ul>\n<p><code>find</code> 查找命令</p>\n<ul>\n<li>\n<p><code>find [path] &lt;file-name&gt; [action]</code> 可指定路径下查找文件，还可以指定查找后的动作</p>\n</li>\n<li>\n<p><code>find -name &lt;file-name&gt;</code> 在当前目录下查找所有符合 <code>file-name</code> 的文件或目录</p>\n</li>\n<li>\n<p><code>find /home -name file</code> 在 <code>/home</code> 目录下查找 <code>file</code> 文件</p>\n</li>\n<li>\n<p><code>find pre*</code> 当前目录下查找所有以 <code>pre</code> 开头的文件或目录</p>\n</li>\n<li>\n<p><code>find *.txt</code> 当前目录下查找所有以 <code>.txt</code> 结尾的文件或目录</p>\n</li>\n<li>\n<p><code>-size</code> 指定大小查找</p>\n<ul>\n<li><code>-size -20M</code> 小于 <code>20M</code> 的文件</li>\n<li><code>-size 1G</code> 等于 <code>1G</code> 的文件</li>\n</ul>\n</li>\n<li>\n<p><code>-atime</code> 按访问时间查找 <em><code>access time</code></em></p>\n<ul>\n<li><code>-atime 10</code> 最近10天</li>\n<li><code>-atime -10</code> 10天之内</li>\n</ul>\n</li>\n<li>\n<p><code>-type</code> 文件类型</p>\n<ul>\n<li><code>-type d</code> 查找的目标是目录</li>\n<li><code>-type f</code> 查找的目标是文件</li>\n</ul>\n</li>\n<li>\n<p><code>-printf</code> 格式化打印结果</p>\n<ul>\n<li><code>-printf &quot;%p - %u/n&quot;</code> 按格式打印查找的结果</li>\n<li><code>%p</code> 文件名</li>\n<li><code>%u</code> 用户名</li>\n</ul>\n</li>\n<li>\n<p><code>-delete</code> 删除查找到的文件</p>\n</li>\n<li>\n<p><code>-exec</code> 对结果文件执行命令，命令以 <code>\\;</code> 结尾</p>\n<ul>\n<li><code>-exec cp {} ./result \\;</code> 将匹配到的每个文件（用 <code>{}</code> 表示）复制到 <code>./result</code> 目录</li>\n</ul>\n</li>\n<li>\n<p><code>-ok</code> 与 <code>-exec</code> 用法一致，但是会在执行命令前让用户确认</p>\n</li>\n</ul>\n<p><code>grep</code> 全局搜索正则表达式并打印</p>\n<ul>\n<li><code>grep &lt;word&gt; &lt;file&gt;</code> 在文件中搜索</li>\n<li><code>-i</code> 忽略大小写</li>\n<li><code>-n</code> 显示行号</li>\n<li><code>-v</code> 只显示文本不在的行</li>\n<li><code>-r</code> 在目录中递归查找</li>\n<li><code>-E</code> 使用正则表达式搜索</li>\n</ul>\n<p><code>wc</code> 文件统计 <em><code>word count</code></em></p>\n<ul>\n<li><code>wc file</code> 打印行数、单词数，字节数</li>\n<li><code>-l</code> 统计行数</li>\n<li><code>-w</code> 统计单词数</li>\n<li><code>-c</code> 统计字节数</li>\n<li><code>-m</code> 统计字符数</li>\n</ul>\n<h4>压缩</h4>\n<p><code>tar</code> 将多个文件归并成归档</p>\n<ul>\n<li><code>-c</code> 创建 <em><code>create</code></em></li>\n<li><code>-v</code> 显示过程</li>\n<li><code>-f</code> 指定文件 <em><code>file</code></em></li>\n<li><code>-t</code>  <em><code>list</code></em></li>\n<li><code>-x</code> 解开归档</li>\n<li><code>-z</code> 压缩文件</li>\n<li><code>tar -cvf file.tar file</code> 将 <code>file</code> 文件归档</li>\n<li><code>tar -zcvf file.tar.gz file</code> 将文件归档并压缩</li>\n<li><code>tar -tf file.tar</code> 显示归档内容而不解开归档</li>\n<li><code>tar -rvf file.tar file</code> 追加文件 <code>file</code> 到归档 <code>file.tar</code></li>\n<li><code>tar -xvf file.tar</code> 解开归档</li>\n<li><code>tar -zxvf file.tar.gz</code> 解压并解开归档</li>\n</ul>\n<p><code>gzip</code> 压缩文件</p>\n<ul>\n<li><code>gzip file.tar</code> 压缩一个归档</li>\n</ul>\n<p><code>gunzip</code> 解压文件</p>\n<ul>\n<li><code>gunzip file.tar.gz</code> 解压文件</li>\n</ul>\n<p><code>zip</code> 压缩成 <code>zip</code> 文件</p>\n<ul>\n<li><code>zip file.zip file</code> 压缩 <code>file</code> 文件为 <code>file.zip</code></li>\n<li><code>zip -r dir.zip ./dir/</code> 递归压缩目录</li>\n</ul>\n<p><code>unzip</code> 解压文件</p>\n<ul>\n<li><code>unzip file.zip</code> 解压文件</li>\n<li><code>unzip -l file.zip</code> 不解压只查看内容</li>\n</ul>\n<p><code>wget</code> 下载器</p>\n<ul>\n<li><code>wget xxxxxx</code> 下载一个链接的文件</li>\n</ul>\n<h4>流、管道、重定向</h4>\n<p>linux中的数据可以通过命令输出到屏幕上，也可以保存在文件中，甚至作为另一个命令的输入，这样的方式叫做管道，管道中的数据就是流 <code>stream</code></p>\n<h5>重定向 <code>&gt;</code> <code>&gt;&gt;</code></h5>\n<p><strong>重定向到文件时，没有文件会默认新建，有则会覆盖</strong></p>\n<p>标准输出使用 <code>&gt;</code> 或 <code>&gt;&gt;</code> (标准输出符是1)</p>\n<p><code>ls &gt; dir.txt</code> 将目录信息从定向到文件 <code>dir.txt</code> 中保存</p>\n<p><code>groups &gt;&gt; log</code> 将群组信息追加到 <code>log</code> 文件末尾</p>\n<p>标准错误输出使用 <code>2&gt;</code> （标准错误输出符是2)</p>\n<p><code>cp not_exist_file file 2&gt; err_log</code> 将错误信息输出至 <code>err_log</code> 文件中</p>\n<p><code>cp file file &gt; log 2&gt; err_log</code> 成功输出至 <code>log</code> ，若失败则错误信息输出至 <code>err_log</code> 文件中</p>\n<p><code>cp file file &gt; log 2&gt;&gt; err_log</code> 成功输出至 <code>log</code> ，若失败则错误信息追加至 <code>err_log</code> 文件中</p>\n<p><code>cp file file &gt; log 2&gt;&amp;1 err_log</code> 成功输出至 <code>log</code> ，若失败也将错误信息输出至 <code>err_log</code> 文件中； <code>2&gt;&amp;1</code> 表示标准错误输出与标准输出一致</p>\n<p><code>cp file file &gt;&gt; log 2&gt;&amp;1 err_log</code> 追加只改变标准输出就可以 <code>&gt;&gt;</code></p>\n<h4>文本编辑器 vim</h4>\n<p><code>vim</code> 是一个 <code>linux</code> 常用的文本编辑器之一，具有强大的快捷键操作功能。</p>\n<p><code>vimtutor</code> 命令可以进去 <code>vim</code> 的教程进行学习</p>\n<p><code>vim</code> 快捷键：</p>\n<p><code>h</code> 向左移动光标</p>\n<p><code>l</code> 向右移动光标</p>\n<p><code>j</code> 向下移动光标</p>\n<p><code>k</code> 向上移动光标</p>\n<p><code>x</code> 删除光标所在的字符</p>\n<p><code>i</code> 在光标所在字符位置插入</p>\n<p><code>a</code> 在光标所在字符后插入</p>\n<p><code>A</code> 在行尾插入</p>\n<p><code>o</code> 在光标下方新起一行插入</p>\n<p><code>O</code> 在光标上方新起一行插入</p>\n<p><code>r</code> 替换光标所在字符</p>\n<p><code>R</code> 连续替换模式</p>\n<p><code>dw</code> 删除单词，从光标位置直到下一个单词起始处</p>\n<p><code>de</code> 删除从光标直到单词末尾，包括最后一个字符</p>\n<p><code>d$</code> 从光标删除到行末</p>\n<p><code>d2w</code> 删除后 <code>2</code> 个单词</p>\n<p><code>cw</code> 删除单词，从光标位置直到下一个单词起始处，并进入编辑模式</p>\n<p><code>ce</code> 删除从光标直到单词末尾，包括最后一个字符，并进入编辑模式</p>\n<p><code>c$</code> 从光标删除到行末，并进入编辑模式</p>\n<p><code>w</code> 移动到下一个单词的开始</p>\n<p><code>2w</code> 移动到  <code>2</code> 个单词后的开始</p>\n<p><code>e</code> 移动到下一个单词的末尾</p>\n<p><code>3e</code> 移动到  <code>3</code> 个单词后的末尾</p>\n<p><code>0</code> 移动到行首</p>\n<p><code>$</code> 移动到行尾</p>\n<p><code>dd</code> 删除一行</p>\n<p><code>2dd</code> 删除 <code>2</code> 行</p>\n<p><code>u</code> 撤销最后的操作命令</p>\n<p><code>U</code> 撤销整行的修改</p>\n<p><code>ctrl+r</code>  重做被撤消的命令</p>\n<p><code>ctrl+g</code> 显示光标所在行位置以及文件状态信息</p>\n<p><code>G</code> 跳转文件最后一行</p>\n<p><code>gg</code> 跳转文件第一行</p>\n<p><code>30G</code> 跳转到第 <code>30</code> 行</p>\n<p><code>ctrl+o</code> 跳回较旧位置</p>\n<p><code>ctrl+i</code> 跳回较新位置</p>\n<p><code>/word</code> 搜索，按 <code>n</code> 搜索下一个，<code>N</code> 搜索上一个</p>\n<p><code>?word</code> 向上搜索</p>\n<p><code>%</code> 查找匹配的括号</p>\n<p><code>:s/old/new</code> 在一行内的第一个 <code>old</code> 替换成 <code>new</code></p>\n<p><code>:s/old/new/g</code> 在一行内所有 <code>old</code> 替换成 <code>new</code></p>\n<p><code>:5,10s/old/new</code> 指定 <code>5</code> 到 <code>10</code> 行</p>\n<p><code>:%s/old/new/g</code> 全文替换所有 <code>old</code> 为 <code>new</code></p>\n<p><code>:%s/old/new/gc</code> 在替换时提示是否替换</p>\n<p><code>:!ls</code> 执行外部命令 <code>ls</code>，按 <code>enter</code> 返回 <code>vim</code></p>\n<p><code>:w file.txt</code> 以 <code>file.txt</code> 文件名保存</p>\n<p><code>v</code> 进入选择模式，按 <code>:</code> 确认选择。可以将所选文本保存成文件 <code>:'&lt;,'&gt;w file.txt</code></p>\n<p><code>:r fileName</code> 从光标处插入文件内容</p>\n<p><code>:r !ls</code> 还可以插入外部命令的输出</p>\n<p><code>y</code> 复制 <code>v</code> 模式选择的文本</p>\n<p><code>yw</code> 复制一个单词</p>\n<p><code>ye</code> 复制光标处到单词结尾的字符</p>\n<p><code>yy</code> 复制一行</p>\n<p><code>p</code> 在光标处粘贴</p>\n<p><code>:set ic</code> 忽略搜索大小写</p>\n<p><code>:set noic</code> 启用搜索大小写</p>\n<p><code>:set hls</code> 高亮搜索结果</p>\n<p><code>:set is</code> 找短语时显示部分匹配</p>\n<p><code>f1</code> 打开帮助，<code>ctrl+w ctrl+w</code> 切换窗口</p>\n<p><code>:help</code> 打开帮助</p>\n<p><code>:help a</code> 查看某指令的帮助</p>\n<p>新建 <code>vim ~/.vimrc</code> 文件，插入默认配置：<code>:r $VIMRUNTIME/vimrc_example.vim</code></p>\n<p>vim 的插件管理：<a href=\"https://github.com/junegunn/vim-plug\">vim-plug</a></p>\n<h3>用户与群组</h3>\n<p><code>sudo</code> 以 <code>root</code> 用户运行命令 <em><code>substitute user do</code></em></p>\n<ul>\n<li><code>sudo su</code> 切换为 <code>root</code> 用户</li>\n<li><code>-i</code> 切换到家目录</li>\n</ul>\n<p><code>su</code> 切换用户</p>\n<ul>\n<li>\n<p><code>su</code> 切换为 <code>root</code> 用户</p>\n</li>\n<li>\n<p><code>su user1</code> 切换为 <code>user1</code> 用户</p>\n</li>\n<li>\n<p><code>su -</code> 切换为 <code>root</code> 用户并切换到 <code>root</code> 的家目录</p>\n</li>\n</ul>\n<p><code>useradd</code> 添加用户</p>\n<ul>\n<li><code>useradd tom</code> 创建用户</li>\n</ul>\n<p><code>passwd</code> 操作用户密码</p>\n<ul>\n<li><code>passwd user1</code> 修改user1用户的密码</li>\n</ul>\n<p><code>userdel</code> 删除用户</p>\n<ul>\n<li><code>userdel user1</code> 删除user1用户</li>\n<li><code>-r</code> <code>—remove</code> 删除用户的 <code>home</code> 目录</li>\n</ul>\n<p><code>groups</code> 获取用户群组</p>\n<ul>\n<li><code>groups user1</code> 获取用户user1的群组</li>\n</ul>\n<p><code>groupadd</code> 添加群组</p>\n<ul>\n<li><code>groupadd group1</code> 添加一个叫 <code>group1</code> 的群组</li>\n</ul>\n<p><code>groupdel</code> 删除群组</p>\n<ul>\n<li><code>groupdel group1</code> 删除 <code>group1</code> 群组</li>\n</ul>\n<p><code>usermod</code> 修改用户账户</p>\n<ul>\n<li><code>usermod -g group1 user1</code>  将用户user1添加进group1群组</li>\n<li><code>usermod -G group1,group2 user1</code>  将用户user1添加进group1、group2群组</li>\n<li><code>-l</code> 对用户重命名 (用户的家目录名称不会修改)</li>\n<li><code>-g</code> 修改用户所在群组</li>\n<li><code>-G</code> 修改多个群组 群组名之间用逗号分隔</li>\n<li><code>-a</code> 追加到用户组，会将用户保留在原有的组里；需要时用 <code>-G</code>，例如<code>-aG</code></li>\n</ul>\n<p><code>chown</code> 改变文件的所有者 <em><code>change owner</code></em></p>\n<ul>\n<li><code>chown user1 file1</code> 将文件 <code>file1</code> 的所有者变为 <code>user1</code></li>\n<li><code>chown user1:group1 file1</code> 将文件 <code>file1</code> 的所有者改为 <code>user1</code>，文件的群组改为 <code>group1</code></li>\n<li><code>-R</code> 递归设置子目录和子文件</li>\n</ul>\n<p><code>chgrp</code> 改变文件的群组 <code>change group</code></p>\n<ul>\n<li><code>chown group1 file1</code> 将文件 <code>file1</code> 的群组变为 <code>group1</code></li>\n<li><code>-R</code> 递归设置子目录和子文件</li>\n</ul>\n<h2>权限</h2>\n<h3>权限符</h3>\n<p>根目录下输入 <code>ls -l</code> ，会显示所有文件以及其信息，其中类似这样的 <code>drwxr-xr-x.</code> 文件信息，代表文件访问权限符</p>\n<table>\n<thead>\n<tr>\n<th>权限符号</th>\n<th>含义</th>\n<th>代表权限</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>d</td>\n<td><em>directory</em></td>\n<td>表示文件是目录</td>\n</tr>\n<tr>\n<td>l</td>\n<td><em>link</em></td>\n<td>表示文件是链接</td>\n</tr>\n<tr>\n<td>r</td>\n<td><em>read</em></td>\n<td>可读权限</td>\n</tr>\n<tr>\n<td>w</td>\n<td><em>write</em></td>\n<td>可写和可删除权限</td>\n</tr>\n<tr>\n<td>x</td>\n<td><em>execute</em></td>\n<td>可执行权限</td>\n</tr>\n<tr>\n<td>.</td>\n<td></td>\n<td>安全标签</td>\n</tr>\n<tr>\n<td>-</td>\n<td></td>\n<td>普通文件或无相应权限</td>\n</tr>\n</tbody>\n</table>\n<p>一个完整的文件权限的表示方式：</p>\n<table>\n  <tr>\n  \t<td></td>\n  \t<td>文件属性</td>\n  \t<td colspan=\"3\">所有者权限</td>\n  \t<td colspan=\"3\">群组用户</td>\n  \t<td colspan=\"3\">其他用户</td>\n  \t<td colspan=\"3\">安全标签</td>\n  </tr>\n  <tr>\n  \t<td>权限符</td>\n  \t<td>d, l, -</td>\n  \t<td>r</td>\n  \t<td>w</td>\n  \t<td>x</td>\n  \t<td>r</td>\n  \t<td>w</td>\n  \t<td>x</td>\n  \t<td>r</td>\n  \t<td>w</td>\n  \t<td>x</td>\n  \t<td>.</td>\n  </tr>\n  <tr>\n  \t<td>权限值</td>\n  \t<td></td>\n  \t<td>4</td>\n  \t<td>2</td>\n  \t<td>1</td>\n  \t<td>4</td>\n  \t<td>2</td>\n  \t<td>1</td>\n  \t<td>4</td>\n  \t<td>2</td>\n  \t<td>1</td>\n  \t<td></td>\n  </tr>\n</table>\n<p>例如表示一个文件的权限就是这样：<code>drwxrwx---.</code> ，指明这是一个目录文件，所有者对此文件可读可写可执行，群组用户也可读可写可执行，其他用户没有任何权限。</p>\n<p>权限符对应的值进行相加就是文件的权限</p>\n<blockquote>\n<p>除普通用户外，<code>root</code> 用户拥有系统最高权限，也就是拥有文件的所有权限。</p>\n</blockquote>\n<h3>修改文件的权限</h3>\n<p><code>chmod</code> 命令可以修改文件的权限 <em><code>change mode</code></em></p>\n<p>将权限对应的值相加就是文件的权限：</p>\n<table>\n<thead>\n<tr>\n<th>权限</th>\n<th>值</th>\n<th>计算方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>---</td>\n<td>0</td>\n<td>0+0+0</td>\n</tr>\n<tr>\n<td>—x</td>\n<td>1</td>\n<td>0+0+1</td>\n</tr>\n<tr>\n<td>-w-</td>\n<td>2</td>\n<td>0+2+0</td>\n</tr>\n<tr>\n<td>-wx</td>\n<td>3</td>\n<td>0+2+1</td>\n</tr>\n<tr>\n<td>r--</td>\n<td>4</td>\n<td>4+0+0</td>\n</tr>\n<tr>\n<td>r-x</td>\n<td>5</td>\n<td>4+0+1</td>\n</tr>\n<tr>\n<td>rw-</td>\n<td>6</td>\n<td>4+2+0</td>\n</tr>\n<tr>\n<td>rwx</td>\n<td>7</td>\n<td>4+2+1</td>\n</tr>\n</tbody>\n</table>\n<h4>1. 通过权限值修改</h4>\n<p>例如对文件分配权限 <code>777</code>，表示 <code>用户|群组|其他用户</code> 权限分别为 <code>7</code>，所以执行命令 <code>chmod 777 file</code> ，文件权限将变为：<code>rwxrwxrwx</code></p>\n<h4>2. 通过权限符修改</h4>\n<p>通过权限符可以细粒度的控制不同用户的权限</p>\n<p>通过组合用户、修改行为、权限符，来修改一个文件的权限：</p>\n<p>用户：</p>\n<table>\n<thead>\n<tr>\n<th>所属用户 user</th>\n<th>群组 group</th>\n<th>其他用户 other</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>u</td>\n<td>g</td>\n<td>o</td>\n</tr>\n</tbody>\n</table>\n<p>修改行为：</p>\n<table>\n<thead>\n<tr>\n<th>赋予权限</th>\n<th>添加权限</th>\n<th>删除权限</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>=</td>\n<td>+</td>\n<td>-</td>\n</tr>\n</tbody>\n</table>\n<p>权限码：</p>\n<table>\n<thead>\n<tr>\n<th>可读 read</th>\n<th>可写 write</th>\n<th>可执行 execute</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>r</td>\n<td>w</td>\n<td>x</td>\n</tr>\n</tbody>\n</table>\n<p>组合之后可以修改文件权限了：</p>\n<ul>\n<li><code>chmode u+rw file1</code> 增加所属用户的读写权限</li>\n<li><code>chmode g-w file1</code> 去除群组的写权限</li>\n<li><code>chmod o=- file1</code> 设置其他用户无任何权限</li>\n<li><code>chmod u=rw,g=rw file1</code> 同时设置多种权限</li>\n<li><code>-R</code> 递归修改所有子目录和文件</li>\n</ul>\n<h2>系统管理</h2>\n<h3>进程管理</h3>\n<p><code>w</code> 显示系统运行时间，负载，以及正在登录的用户</p>\n<p><code>uptime</code> 显示系统运行时长</p>\n<p><code>toload</code> 显示负载变化图</p>\n<p><code>who</code> 显示登录中的 用户</p>\n<p><code>ps</code> 查看进程 <em><code>process status</code></em></p>\n<ul>\n<li><code>-ef</code> 列出所有用户的所有进程</li>\n<li><code>-u</code> 指定列出某用户</li>\n<li><code>-aux</code> 根据cpu和内存使用率过滤\n<ul>\n<li><code>--sort</code> 排序\n<ul>\n<li><code>-aux --sort -pcpu</code> 根据cpu使用率排序</li>\n<li><code>-aux --sort -pmem</code> 根据内存使用率排序</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><code>top</code> 进程的动态列表</p>\n<p><code>top</code> 面板的快捷键：</p>\n<ul>\n<li><code>q</code> 退出</li>\n<li><code>h</code> 帮助</li>\n<li><code>f</code> 编辑表头、排序</li>\n<li><code>u</code> 筛选用户</li>\n<li><code>k</code> 结束进程</li>\n<li><code>s</code> 改变刷新时间</li>\n</ul>\n<p><code>htop</code> 是一款比 <code>top</code> 命令功能更多的终端工具</p>\n<p>安装 <code>htop</code>：</p>\n<ol>\n<li><code>yum install -y epel-release</code></li>\n<li><code>yum install htop -y</code></li>\n</ol>\n<p><code>kill</code> 终止某个进程</p>\n<ul>\n<li><code>kill PID ...</code> 结束进程ID</li>\n<li><code>kill -9 PID</code> 立即结束进程；<code>-9</code> 是一个命令参数</li>\n</ul>\n<p><code>halt</code> 关闭系统</p>\n<p><code>reboot</code> 重启系统</p>\n<p><code>shutdown</code> 执行重启、关机等操作</p>\n<p><code>poweroff</code> 关机，普通用户也可以使用</p>\n<p><code>&amp;</code> 命令结束加 <code>&amp;</code>，可以让进程在后台运行，终端关闭进程就会关闭</p>\n<ul>\n<li><code>find tom &amp;</code> 在后台搜索，可以继续输入命令</li>\n</ul>\n<p><code>nohup</code> 进程与终端分离，关闭终端也不会终止进程 <em><code>no hangup</code></em></p>\n<p><code>bg</code> 将前台进程或后台暂停的进程转至后台运行，或将最近一次转到后台运行的程序转至前台运行</p>\n<p><code>fg</code> 将后台进程转至前台运行</p>\n<p><code>jobs</code> 查看后台信息</p>\n<p>进程状态：</p>\n<ol>\n<li><code>r</code> 运行中</li>\n<li><code>s</code> 休眠中，终端</li>\n<li><code>d</code> 不可终端</li>\n<li><code>z</code> 僵死</li>\n<li><code>t</code> 停止</li>\n</ol>\n<h3>远程登录</h3>\n<p><code>ssh</code> 可以远程登录主机</p>\n<ul>\n<li><code>ssh root@192.169.0.100</code> 登录主机名为 <code>192.168.0.100</code> 的主机，用户名为 <code>root</code>，也就是登录 <code>root</code> 用户，之后会要求输入密码验证</li>\n</ul>\n<p>配置客户机的 <code>ssh</code> 配置，可以方便的登录主机：</p>\n<ol>\n<li>\n<p>打开 <code>~/.ssh/</code> 目录下 <code>config</code> 文件；如果没有可以新建 <code>config</code>；如果没有 <code>.ssh</code> 目录，可以执行 <code>ssh localhost</code> 生成</p>\n</li>\n<li>\n<p>配置主机信息：</p>\n<pre><code>Host serverName\n  HostName 192.168.0.100\n  Post 22\n  User root\n</code></pre>\n</li>\n<li>\n<p>配置保存后，执行 <code>ssh serverName</code> 就可以自动连接主机 <code>roor</code> 账户了</p>\n</li>\n</ol>\n<h3>免密登录</h3>\n<p>通过设置秘钥可以实现免密登录：</p>\n<ol>\n<li>生成本地秘钥：<code>ssh-keygen</code>；相当于：<code>ssh-keygen -t rsa</code>，公钥秘钥默认生成在 <code>~/.ssh/</code> 目录下</li>\n<li>将公钥传输到服务器：<code>ssh-copy-id root@192.168.0.100</code>，然后输入主机密码即可。这个命令相当于执行了 <code>ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.0.100</code>，作用是将本机公钥追加到服务器的 <code>~/.ssh/authorized_keys</code> 文件中，在登录时进行验证。</li>\n<li>设置完毕直接登录主机 <code>ssh root@192.168.0.100</code> 就可以免密码登录主机了</li>\n</ol>\n<blockquote>\n<p>设置了免密登录后使用密码登录：<code>ssh -o PreferredAuthentications=password -o PubkeyAuthentication=no root@192.168.0.100</code></p>\n</blockquote>\n<h2>快捷键</h2>\n<p><code>ctrl+d</code> 给终端传递 <em><code>EOF(end of file)</code></em>，退出终端或账号</p>\n<p><code>ctrl+l</code> 清屏</p>\n<p><code>ctrl+a</code> 光标跳转命令开头</p>\n<p><code>ctrl+e</code> 光标跳转命令结尾</p>\n<p><code>ctrl+u</code> 删除光标左侧所有字符</p>\n<p><code>ctrl+k</code> 删除光标右侧所有字符</p>\n<p><code>ctrl+w</code> 删除光标左侧的一个单词</p>\n<p><code>ctrl+y</code> 粘贴 <code>ctrl+u</code> <code>ctrl+k</code> <code>ctrl+w</code> 删除的内容</p>\n<p><code>ctrl+c</code> 终止当前程序</p>\n<p><code>ctrl+z</code> 将进程转到后台挂起，暂停运行</p>\n<h2>系统文件目录摘要</h2>\n<p><code>/</code> 表示根目录</p>\n<p><code>.</code> 表示当前目录</p>\n<p><code>..</code> 表示上一级目录</p>\n<p><code>~</code> 当前用户的 <code>home</code> 目录</p>\n<p><code>/bin</code> 存放二进制文件 <em><code>binary</code></em></p>\n<p><code>/sbin</code> 存放系统二进制文件，包含重要的可执行程序    <em><code>system bin</code></em></p>\n<p><code>/boot</code> 系统启动相关文件的目录</p>\n<p><code>/dev</code> 保存了外设与驱动器文件的目录 <em><code>device</code></em></p>\n<p><code>/etc</code> 存放了一些配置文件与其他零零碎碎的文件</p>\n<p><code>/home</code> 用户的私人目录</p>\n<p><code>/lib</code> 程序调用的库文件  <em><code>library</code></em></p>\n<p><code>/media</code> 访问外设媒体的目录</p>\n<p><code>/mnt</code> 临时挂载一些装置 <em><code>mount</code></em></p>\n<p><code>/opt</code> 表示可选的应用软件包，用于安装第三方软件及插件 <em><code>optional application software package</code></em></p>\n<p><code>/root</code> 超级用户的 <code>home</code> 目录</p>\n<p><code>/srv</code>  网络服务相关的目录 <em><code>service</code></em></p>\n<p><code>/tmp</code> 临时文件存放的目录</p>\n<p><code>/usr</code> 操作系统软件资源，这里有用户大量要调用的程序 <em><code>Unix software resource</code></em></p>\n<p><code>/var</code>  包含程序的数据日志记录文件等 <em><code>variable</code></em></p>\n<ul>\n<li><code>*.log</code> 日志记录文件</li>\n</ul>\n<h2>linux的软件</h2>\n<h3>软件与源</h3>\n<p>因为linux是一个开源的系统，他都软件也都是开源的，世界上有许多个服务器作为软件仓库存放了linux的软件可供使用，我们可以切换任意的<a href=\"https://www.centos.org/download/mirrors/\">仓库源</a>去下载。</p>\n<p><code>/ect/yum.repos.d/CentOS-Base.repo</code>  这个文件配置了仓库的地址，为了达到更快的下载速度，我们可以找到国内比较好的源来替换这个文件：</p>\n<p>阿里巴巴：https://developer.aliyun.com/mirror/centos?spm=a2c6h.13651102.0.0.3e221b11BPhjUY</p>\n<p>华为：https://mirrors.huaweicloud.com/</p>\n<p>网易：<a href=\"http://mirrors.163.com/.help/centos.html\">http://mirrors.163.com/.help/centos.html</a></p>\n<p>清华大学：https://mirrors.tuna.tsinghua.edu.cn/help/centos/</p>\n<h3>使用yum管理软件</h3>\n<p><code>yum</code> 是linux的包管理工具，可以方便的下载、卸载和更新系统软件包</p>\n<p><code>yum update</code> 和 <code>yum updrade</code> 可以更新本地安装的软件，<code>upgrade</code> 会删除原有的软件包再更新</p>\n<p><code>yum update &lt;pkg-name&gt;</code> 更新指定软件包</p>\n<p><code>yum search &lt;pkg-name&gt;</code> 搜索软件包</p>\n<p><code>yum install &lt;pkg-name&gt;</code> 安装软件包</p>\n<p><code>yum remove &lt;pkg-name&gt;</code> 删除软件包</p>\n<p>也可以下载 <code>.rpm</code> 格式的软件包，用 <code>rpm</code> 命令本地安装：</p>\n<p><code>rpm -i &lt;pkg-name.rpm&gt;</code> 安装本地软件包</p>\n<p>还可以用 <code>yum</code> 命令安装：</p>\n<p><code>yum localinstall &lt;pkg-name.rpm&gt;</code></p>\n<p><code>rpm -e &lt;pkg-name&gt;</code> 卸载包</p>\n<h2>使用手册</h2>\n<ol>\n<li>\n<p><code>man</code> 命令可以阅读手册获取帮助信息 <code>manual</code></p>\n<p>安装手册 <code>yum install man-pages</code></p>\n<p>更新手册 <code>mandb</code></p>\n<p>查询命令手册 <code>man &lt;command&gt;</code></p>\n</li>\n<li>\n<p>大多数命令的 <code>--help</code> 参数可以获取简要的帮助信息</p>\n<p>查看命令的帮助信息 <code>ls --help</code></p>\n</li>\n<li>\n<p><code>wathis &lt;command&gt;</code> 获取一个命令的简要信息</p>\n</li>\n<li>\n<p>在不知道命令是什么的时候，可以搜索关键字来查找命令：<code>apropos &lt;keyword&gt;</code></p>\n</li>\n</ol>\n`,\n    wordCount: 13284\n  }\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/docs/linux学习笔记.mdjs\n// module id = 4oDU\n// module chunks = 0 1","module.exports = {\n    info: {\n    title: 'chrome extension',\n    poster: 'static/chrome_icon.png',\n    date: '2019-04-03',\n    id: '2019-04-03',\n    desc: '教你 chrome extension 入门'\n},\n    content: `<h2>介绍</h2>\n<p>Chrome Extension 是 Chrome 的扩展程序，也就是大家常说的「插件」。</p>\n<p><code>扩展程序</code> 本质上其实是网页，开发者运用 web 技术，并基于 <a href=\"https://developers.chrome.com/extensions/api_index\">Chrome Extension API</a> 来增强 Chrome 的能力，实现诸如控制网络请求、自定义右键菜单、管理书签、在页面中插入 CSS 与 JavaScript、主题美化、定制主页等功能。</p>\n<p><a href=\"https://chrome.google.com/webstore/category/extensions\">Chrome webstore</a> 上聚集了大量优秀的插件、主题、应用，你可以使用并且自己开发。</p>\n<p>Chrome Extension 一般有多种类型，大致有插件类、主题类、APP类：</p>\n<img src=\"/static/google-translate_icon.png\" width=\"50\"/>\n<img src=\"/static/theme_icon.png\" width=\"55\"/>\n<img src=\"/static/postman_icon.png\" width=\"50\"/>\n<h2>组成</h2>\n<p>Chrome Extension 的几个重要组成部分:</p>\n<ol>\n<li>\n<p><code>manifest.json</code>  扩展程序的组成清单</p>\n<p><code>manifest.json</code> 这个文件定义了扩展程序的方方面面，就像你的身份证、户口本一样，这个我们等下介绍它</p>\n</li>\n<li>\n<p><code>background script</code>  后台运行脚本</p>\n<p><code>background script</code> 可以在后台一直运行，用来监听各种事件、响应用户的操作</p>\n</li>\n<li>\n<p><code>content script</code>  注入页面脚本</p>\n<p><code>content script</code> 可以将脚本注入进页面中，用来对页面进行修改</p>\n</li>\n<li>\n<p><code>popup page</code>  侧边栏按钮弹窗</p>\n<p><code>popup page</code> 用来展示工具栏中图标按钮点击后出现的弹窗</p>\n</li>\n</ol>\n<p>我们常见的主要功能就是这些啦</p>\n<h3>manifest.json</h3>\n<p><code>manifest.json</code> 是描述插件的清单文件，包含了扩展程序的大部分信息：</p>\n<pre><code class=\"hljs\" lang=\"json\">{\n  <span class=\"hljs-attr\">\"manifest_version\"</span>: <span class=\"hljs-number\">2</span>,  // 扩展标准\n  <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"插件的名称\"</span>,\n  <span class=\"hljs-attr\">\"version\"</span>: <span class=\"hljs-string\">\"0.0.1\"</span>,\n  <span class=\"hljs-attr\">\"description\"</span>: <span class=\"hljs-string\">\"插件的描述\"</span>,\n  <span class=\"hljs-attr\">\"icons\"</span>: {\n    <span class=\"hljs-attr\">\"16\"</span>: <span class=\"hljs-string\">\"imgs/icons-16.png\"</span>,  // 扩展程序页面上的图标\n    <span class=\"hljs-attr\">\"32\"</span>: <span class=\"hljs-string\">\"imgs/icons-32.png\"</span>,  // windows计算机通常需要此大小，防止失真\n    <span class=\"hljs-attr\">\"48\"</span>: <span class=\"hljs-string\">\"imgs/icons-48.png\"</span>,  // 显示在扩站程序管理页面上\n    <span class=\"hljs-attr\">\"128\"</span>: <span class=\"hljs-string\">\"imgs/icons-128.png\"</span>  // 在安装和chrome webstore中显示\n  },\n  <span class=\"hljs-attr\">\"background\"</span>: {\n    <span class=\"hljs-attr\">\"page\"</span>: <span class=\"hljs-string\">\"background.html\"</span>,\n    <span class=\"hljs-attr\">\"scripts\"</span>: [<span class=\"hljs-string\">\"background.js\"</span>],\n    <span class=\"hljs-attr\">\"persistent\"</span>: <span class=\"hljs-literal\">false</span>\n  },\n  <span class=\"hljs-attr\">\"browser_action\"</span>: {\n    <span class=\"hljs-attr\">\"default_icon\"</span>: <span class=\"hljs-string\">\"imgs/icon.png\"</span>,\n    <span class=\"hljs-attr\">\"default_title\"</span>: <span class=\"hljs-string\">\"悬浮在工具栏插件图标时的tooltip内容\"</span>,\n    <span class=\"hljs-attr\">\"default_popup\"</span>: <span class=\"hljs-string\">\"popup.html\"</span>  // 不允许内联 javascript\n  },\n  <span class=\"hljs-attr\">\"content_scripts\"</span>: [{\n    <span class=\"hljs-attr\">\"js\"</span>: [<span class=\"hljs-string\">\"inject.js\"</span>],\n    <span class=\"hljs-attr\">\"matches\"</span>: [<span class=\"hljs-string\">\"http://*/*\"</span>, <span class=\"hljs-string\">\"https://*/*\"</span>],\n    <span class=\"hljs-attr\">\"run_at\"</span>: <span class=\"hljs-string\">\"document_start\"</span>\n  }],\n  <span class=\"hljs-attr\">\"permissions\"</span>: [\n    <span class=\"hljs-string\">\"contextMenus\"</span>,\n    <span class=\"hljs-string\">\"tabs\"</span>\n  ],\n  <span class=\"hljs-attr\">\"web_accessible_resources\"</span>: [<span class=\"hljs-string\">\"dist/*\"</span>, <span class=\"hljs-string\">\"dist/**/*\"</span>]\n}\n</code></pre>\n<ul>\n<li>\n<p><code>manifest_version</code> 是扩展程序的清单文件格式的版本，从 <code>chrome18</code> 开始，都应指定为 <code>2</code></p>\n</li>\n<li>\n<p><code>name</code> 就是这个扩展程序的名字</p>\n</li>\n<li>\n<p><code>version</code> 是当前发布的版本，每一次发布都应该更新版本</p>\n</li>\n<li>\n<p><code>description</code> 是对扩展程序的描述，这个描述会在 chrome 应用商店的扩展程序主页显示</p>\n</li>\n<li>\n<p><code>icons</code> 定义了在各个地方展示的图标</p>\n</li>\n<li>\n<p><code>background</code> 可以理解为后台运行的脚本，与浏览器打开的页面不存才关联</p>\n</li>\n<li>\n<p><code>browser_action</code> 定义了浏览器工具栏上的表现行为</p>\n</li>\n<li>\n<p><code>content_script</code> 是一个独立插入页面的脚本，可以获取 <code>window</code>、<code>DOM</code> 元素，并且不会与页面中的命名空间发生冲突</p>\n</li>\n<li>\n<p><code>permissions</code> chrome extension 提供了很多 <code>api</code>，在 <code>background</code> 中使用 <code>api</code> 需要事先定义</p>\n</li>\n<li>\n<p><code>web_accessible_resources</code> 可以授予访问其他资源的权限，比如你的 <code>css</code>、<code>js</code> 库</p>\n</li>\n</ul>\n<h2>开始我们的第一款插件</h2>\n<p>我们创建一个文件夹 <code>my-plugin</code>，作为我们的项目。</p>\n<p>先在根目录创建一个 manifest.json 文件:</p>\n<pre><code class=\"hljs\" lang=\"json\">{\n  <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"my-plugin\"</span>,\n  <span class=\"hljs-attr\">\"version\"</span>: <span class=\"hljs-string\">\"0.0.1\"</span>,\n  <span class=\"hljs-attr\">\"manifest_version\"</span>: <span class=\"hljs-number\">2</span>\n}\n</code></pre>\n<blockquote>\n<p>Chrome 规定了一个 Chrome Extension 只允许包含一个 manifest.json 文件</p>\n</blockquote>\n<p>配置一个这样的清单文件就可以创建出一个扩展啦，就是这么简单粗暴。</p>\n<p>但是它现在什么功能都没有，什么都做不了，我们现在来加一些东西上去。</p>\n<p>首先，我们可以为插件添加一个 icon:</p>\n<pre><code class=\"hljs\" lang=\"json\">{\n  <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"my-plugin\"</span>,\n  <span class=\"hljs-attr\">\"version\"</span>: <span class=\"hljs-string\">\"0.0.1\"</span>,\n  <span class=\"hljs-attr\">\"manifest_version\"</span>: <span class=\"hljs-number\">2</span>,\n  <span class=\"hljs-attr\">\"icons\"</span>: {\n    <span class=\"hljs-attr\">\"16\"</span>: <span class=\"hljs-string\">\"imgs/icon16.png\"</span>,\n    <span class=\"hljs-attr\">\"32\"</span>: <span class=\"hljs-string\">\"imgs/icon32.png\"</span>,\n    <span class=\"hljs-attr\">\"48\"</span>: <span class=\"hljs-string\">\"imgs/icon48.png\"</span>,\n    <span class=\"hljs-attr\">\"128\"</span>: <span class=\"hljs-string\">\"imgs/icon128.png\"</span>\n  }\n}\n</code></pre>\n<p>你可以添加任何喜欢的图标，只需要配置 <code>icons</code> 选项即可。</p>\n<p>这里定义四种规格的图标，分别会作用在工具栏、插件管理页、插件商店等地方。</p>\n<p>一般扩展程序在浏览器上的表现分为两种：</p>\n<ol>\n<li><code>browser_action</code> 适用于任何页面的扩展 （例如 Google 翻译）</li>\n<li><code>page_action</code> 作用于某一页面的扩展（例如 Vue.js devtools）</li>\n</ol>\n<p>接下来我们创建一个常见的工具栏弹窗，在 <code>browser_action</code> 中定义:</p>\n<pre><code class=\"hljs\" lang=\"json\">{\n  <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"my-plugin\"</span>,\n  <span class=\"hljs-attr\">\"version\"</span>: <span class=\"hljs-string\">\"0.0.1\"</span>,\n  <span class=\"hljs-attr\">\"manifest_version\"</span>: <span class=\"hljs-number\">2</span>,\n  <span class=\"hljs-attr\">\"icons\"</span>: {\n    <span class=\"hljs-attr\">\"16\"</span>: <span class=\"hljs-string\">\"imgs/icon16.png\"</span>,\n    <span class=\"hljs-attr\">\"32\"</span>: <span class=\"hljs-string\">\"imgs/icon32.png\"</span>,\n    <span class=\"hljs-attr\">\"48\"</span>: <span class=\"hljs-string\">\"imgs/icon48.png\"</span>,\n    <span class=\"hljs-attr\">\"128\"</span>: <span class=\"hljs-string\">\"imgs/icon128.png\"</span>\n  },\n  <span class=\"hljs-attr\">\"browser_action\"</span>: {\n    <span class=\"hljs-attr\">\"default_icon\"</span>: <span class=\"hljs-string\">\"imgs/icon.png\"</span>,\n    <span class=\"hljs-attr\">\"default_title\"</span>: <span class=\"hljs-string\">\"hello chrome\"</span>,\n    <span class=\"hljs-attr\">\"default_popup\"</span>: <span class=\"hljs-string\">\"popup.html\"</span>\n  }\n}\n</code></pre>\n<p>我们现在设定插件作用于任何页面：使用 <code>browser_action</code> 选项，popup 需要指定一个 <code>html</code> 文件：</p>\n<pre><code class=\"hljs\" lang=\"html\"><span class=\"hljs-comment\">&lt;!-- popup.html --&gt;</span>\n<span class=\"hljs-meta\">&lt;!DOCTYPE html&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">\"en\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"UTF-8\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>my-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\">\n      <span class=\"hljs-selector-tag\">body</span> { <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">65px</span>; }\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn\"</span>\n      <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"button\"</span>\n      <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"click me!\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"popup.js\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n<p>在这里要注意：<code>popup html</code> 文件是不可以内联书写 <code>javscript</code> 的，也就是说只能使用 <code>script</code> 标签来引用外部的 <code>javascript</code> 脚本，所以我们还需定义一个 <code>popup.js</code>。</p>\n<pre><code class=\"hljs\" lang=\"js\"><span class=\"hljs-comment\">// popup.js</span>\n<span class=\"hljs-keyword\">const</span> btnEle = <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">'.btn'</span>)\nbtnEle.onclick = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  alert(<span class=\"hljs-string\">'hello chrome!'</span>)\n}\n</code></pre>\n<p>点击按钮弹出 <code>hello chrome!</code>，好了，我们迫不及待想要看看效果了！</p>\n<h3>调试</h3>\n<p>想要看到效果，我们需要把插件先装到 chrome 上：</p>\n<p>菜单中找到扩展程序入口：</p>\n<p><img src=\"/static/install-chrome-plugin-1.png\" alt=\"install-chrome-plugin-1\"></p>\n<p>右上角开启开发者模式：</p>\n<p><img src=\"/static/install-chrome-plugin-2.png\" alt=\"install-chrome-plugin-2\"></p>\n<p>点击 <code>加载已解压的扩展程序</code> 选择 <code>my-plugin</code> 项目：</p>\n<p><img src=\"/static/install-chrome-plugin-3.png\" alt=\"install-chrome-plugin-3\"></p>\n<p><img src=\"/static/install-chrome-plugin-4.png\" alt=\"install-chrome-plugin-4\"></p>\n<p>这样就添加到了插件管理页：</p>\n<p><img src=\"/static/install-chrome-plugin-5.png\" alt=\"install-chrome-plugin-5\"></p>\n<p>这时浏览器工具栏就会出现刚刚添加的插件，图标时自定义的：</p>\n<p><img src=\"/static/install-chrome-plugin-6.png\" alt=\"install-chrome-plugin-6\"></p>\n<p>点击插件图标，会显示 <code>popup.html</code> 页面：</p>\n<p><img src=\"/static/install-chrome-plugin-7.png\" alt=\"install-chrome-plugin-7\"></p>\n<p>click me!</p>\n<p><img src=\"/static/install-chrome-plugin-8.png\" alt=\"install-chrome-plugin-8\"></p>\n<h3>与页面交互</h3>\n<p>我们现在只能在页面外做动作，怎样与页面交互呢？</p>\n<p>前面说到 <code>content_script</code> 可以拿到浏览器当前打开页面的资源，这样我们就可以获取到 <code>window</code> 以及 <code>DOM</code>，并可以修改和插入 <code>html</code>、<code>css</code>、<code>js</code>。</p>\n<p>在 <code>manifest.json</code> 中配置 <code>content_script</code>：</p>\n<pre><code class=\"hljs\" lang=\"json\">{\n  <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"my-plugin\"</span>,\n  <span class=\"hljs-attr\">\"version\"</span>: <span class=\"hljs-string\">\"0.0.1\"</span>,\n  <span class=\"hljs-attr\">\"manifest_version\"</span>: <span class=\"hljs-number\">2</span>,\n  <span class=\"hljs-attr\">\"icons\"</span>: {\n    <span class=\"hljs-attr\">\"16\"</span>: <span class=\"hljs-string\">\"imgs/icon16.png\"</span>,\n    <span class=\"hljs-attr\">\"32\"</span>: <span class=\"hljs-string\">\"imgs/icon32.png\"</span>,\n    <span class=\"hljs-attr\">\"48\"</span>: <span class=\"hljs-string\">\"imgs/icon48.png\"</span>,\n    <span class=\"hljs-attr\">\"128\"</span>: <span class=\"hljs-string\">\"imgs/icon128.png\"</span>\n  },\n  <span class=\"hljs-attr\">\"browser_action\"</span>: {\n    <span class=\"hljs-attr\">\"default_icon\"</span>: <span class=\"hljs-string\">\"imgs/icon.png\"</span>,\n    <span class=\"hljs-attr\">\"default_title\"</span>: <span class=\"hljs-string\">\"hello chrome\"</span>,\n    <span class=\"hljs-attr\">\"default_popup\"</span>: <span class=\"hljs-string\">\"popup.html\"</span>\n  },\n  <span class=\"hljs-attr\">\"content_scripts\"</span>: [{\n    <span class=\"hljs-attr\">\"js\"</span>: [<span class=\"hljs-string\">\"inject.js\"</span>],\n    <span class=\"hljs-attr\">\"matches\"</span>: [\n      <span class=\"hljs-string\">\"http://*/*\"</span>,\n      <span class=\"hljs-string\">\"https://*/*\"</span>\n    ]\n  }]\n}\n</code></pre>\n<ul>\n<li><code>js</code> 字段定义了需要加载的js脚本文件，这里是一个数组，所以脚本文件会按找数组顺序注入，如果我们的程序需要依赖于第三方库，就可以先注入他们。</li>\n<li><code>matches</code> 可以让你选择这些脚本在页面匹配到什么样的 <code>URI</code> 时被注入，以此来实现更复杂的功能。</li>\n</ul>\n<p>我们定义一个叫 <code>inject.js</code> 的文件，还是老套路，打印 <code>hello chrome</code> 或者你可以删掉某个 <code>DOM</code> 试试看：</p>\n<pre><code class=\"hljs\" lang=\"js\"><span class=\"hljs-comment\">// inject.js</span>\nalert(<span class=\"hljs-string\">'hello chrome'</span>)\n</code></pre>\n<p>此时随便打开一个 <code>http(s)://**/*</code> 页面时， chrome 就会帮我们注入 <code>inject.js</code> 到页面中并执行：</p>\n<p><img src=\"/static/install-chrome-plugin-9.png\" alt=\"install-chrome-plugin-9\"></p>\n<p>随便打开一个页面，弹窗就出来了（不要这样做哦）。</p>\n<h3>一个全局的后台脚本 background</h3>\n<p>有些时候，我们在不同页面都需要出发一些事件、统一处理操作等，就需要一个全局的脚本在运行，这就是 <code>background script</code> 的作用。</p>\n<p>我们再来新建一个 <code>background.js</code> 并注册在 <code>manifest.json</code> 里：</p>\n<pre><code class=\"hljs\" lang=\"js\"><span class=\"hljs-comment\">// background.js</span>\n<span class=\"hljs-keyword\">let</span> timeout = <span class=\"hljs-number\">10000</span>\n<span class=\"hljs-built_in\">window</span>.setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  alert(<span class=\"hljs-string\">'hello chrome!'</span>)\n}, timeout)\n</code></pre>\n<pre><code class=\"hljs\" lang=\"json\">{\n  <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"my-plugin\"</span>,\n  <span class=\"hljs-attr\">\"version\"</span>: <span class=\"hljs-string\">\"0.0.1\"</span>,\n  <span class=\"hljs-attr\">\"manifest_version\"</span>: <span class=\"hljs-number\">2</span>,\n  <span class=\"hljs-attr\">\"icons\"</span>: {\n    <span class=\"hljs-attr\">\"16\"</span>: <span class=\"hljs-string\">\"imgs/icon16.png\"</span>,\n    <span class=\"hljs-attr\">\"32\"</span>: <span class=\"hljs-string\">\"imgs/icon32.png\"</span>,\n    <span class=\"hljs-attr\">\"48\"</span>: <span class=\"hljs-string\">\"imgs/icon48.png\"</span>,\n    <span class=\"hljs-attr\">\"128\"</span>: <span class=\"hljs-string\">\"imgs/icon128.png\"</span>\n  },\n  <span class=\"hljs-attr\">\"browser_action\"</span>: {\n    <span class=\"hljs-attr\">\"default_icon\"</span>: <span class=\"hljs-string\">\"imgs/icon.png\"</span>,\n    <span class=\"hljs-attr\">\"default_title\"</span>: <span class=\"hljs-string\">\"hello chrome\"</span>,\n    <span class=\"hljs-attr\">\"default_popup\"</span>: <span class=\"hljs-string\">\"popup.html\"</span>\n  },\n  <span class=\"hljs-attr\">\"content_scripts\"</span>: [{\n    <span class=\"hljs-attr\">\"js\"</span>: [<span class=\"hljs-string\">\"inject.js\"</span>],\n    <span class=\"hljs-attr\">\"matches\"</span>: [\n      <span class=\"hljs-string\">\"http://*/*\"</span>,\n      <span class=\"hljs-string\">\"https://*/*\"</span>\n    ]\n  }],\n  <span class=\"hljs-attr\">\"background\"</span>: {\n    <span class=\"hljs-attr\">\"scripts\"</span>: [<span class=\"hljs-string\">\"background.js\"</span>],\n    <span class=\"hljs-attr\">\"persistent\"</span>: <span class=\"hljs-literal\">false</span>\n  }\n}\n</code></pre>\n<ul>\n<li><code>scripts</code> 用来注入我们的 <code>background.js</code>。</li>\n<li><code>persistent</code> 字段为 <code>true</code> 时会持续在后台运行；<code>false</code>，会在事件触发时被才唤醒。</li>\n</ul>\n<p>这里写了一个定时器，每过 <code>10</code> 秒就会打印 <code>hello chrome!</code>。</p>\n<p>到这个时候，你可能会疑问：这些脚本之间如何通信？</p>\n<h3>通信</h3>\n<p>接下来我们看看怎么通信，我们在 <code>inject.js</code> 中发送消息，怎么样在 <code>background.js</code> 中收到？</p>\n<p><code>chrome API</code> 中有一个 <code>sendMessage</code> 方法，可以发送消息，我们在 <code>inject.js</code> 这样写：</p>\n<pre><code class=\"hljs\" lang=\"js\"><span class=\"hljs-comment\">// inject.js</span>\nchrome.runtime.sendMessage(\n  message,\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">response</span>) </span>{\n    <span class=\"hljs-comment\">// do something...</span>\n  }\n)\n</code></pre>\n<p>这样就能向 <code>background.js</code> 发送消息了，<code>sendMessage</code> 方法的第一个参数 <code>message</code> 为发送的消息内容（基础数据类型），第二个参数是一个回调函数，回调函数的第一个参数为 <code>background scripts</code> 接收消息后返回的消息（如果有的话）。</p>\n<p>接下来只需在 <code>background.js</code> 中接收消息了：</p>\n<pre><code class=\"hljs\" lang=\"js\"><span class=\"hljs-comment\">// background.js</span>\nchrome.runtime.onMessage.addListener(\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">request, sender, sendResponse</span>) </span>{\n    sendResponse(<span class=\"hljs-string\">\"It's \"</span> + request)\n  }\n)\n</code></pre>\n<p><code>addListener</code> 方法可以监听到发来的消息，第一个参数 <code>request</code> 表示发来消息的内容，第三个参数 <code>sendResponse</code> 是一个函数，用于对消息进行回应，如 <code>sendResponse('我已收到你的消息：'+JSON.stringify(request))</code>。</p>\n<h3>发布</h3>\n<p>当我们完成了插件所有的功能后，就可以发布插件啦~</p>\n<p>进入<a href=\"https://chrome.google.com/webstore/category/extensions\">chrome 扩展程序商店</a>,右上角菜单中点击<code>开发者信息中心</code>，点击 <code>添加新内容</code>：</p>\n<p><img src=\"/static/publish-chrome-plugin-1.png\" alt=\"publish-chrome-plugin-1\"></p>\n<p>上传插件的压缩文件：</p>\n<p><img src=\"/static/publish-chrome-plugin-3.png\" alt=\"publish-chrome-plugin-3\"></p>\n<p><img src=\"/static/publish-chrome-plugin-2.png\" alt=\"publish-chrome-plugin-2\"></p>\n<p>填写插件信息、上传预览图后，就可以发布更改了</p>\n<p><img src=\"/static/publish-chrome-plugin-4.png\" alt=\"publish-chrome-plugin-4\"></p>\n<h2>参考资料:</h2>\n<ol>\n<li>https://welearnmore.gitbook.io/chrome-extension-book/</li>\n<li>https://juejin.im/post/5c135a275188257284143418#heading-10</li>\n<li>http://www.dahouduan.com/2017/08/12/make-chrome-extension/</li>\n</ol>\n`,\n    wordCount: 8219\n  }\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/docs/chrome extension.mdjs\n// module id = 7K+T\n// module chunks = 0 1","module.exports = {\n    info: {\n  title: '对 javascript 执行环境的探索',\n  poster: '/static/poster.png',\n  date: '2018-06-08',\n  id: '2018-06-08',\n  desc: '执行上下文 执行环境 作用域 作用域链 函数调用栈 执行队列 执行上下文队列 变量对象 活动对象 解析器interpreter 声明declared'\n},\n    content: `<blockquote>\n<p>执行上下文 执行环境 作用域 作用域链 函数调用栈 执行队列 执行上下文队列 变量对象 活动对象 解析器interpreter 声明declared\n执行上下文是动态的，作用域是静态的，两者是不一样的</p>\n</blockquote>\n<blockquote>\n<p>函数的执行环境会在调用时才创建，不同的调用方式(比如call、apply)执行环境也会不同，也就是说一个函数的执行环境不是固定的，是可能会变的，执行环境的改变会导致this指向的改变；而函数作用域是在定义函数时就确定了，全局就是全局的，局部就是局部的，不会再改变了，如果这个函数被赋值给一个变量或对象的方法后(函数在其他地方被引用)，函数调用者就不一定是之前的了，所以函数中的this会发生变化，但是函数内变量查找的规则还是会<strong>回到</strong>这个函数体被定义的地方根据作用域链向上查找</p>\n</blockquote>\n<h2>执行上下文(执行环境) Execution Context</h2>\n<p><strong>执行上下文</strong>可以理解为当前代码所运行在的环境与范围（并不是<strong>作用域</strong>），分为以下三种：</p>\n<h3>全局上下文</h3>\n<p>全局上下文是代码运行时第一时间会进入的默认执行环境</p>\n<ul>\n<li><strong>浏览器</strong>中的全局上下文指 <code>window</code> 对象</li>\n<li><strong>nodejs</strong>中的全局上下文指 <code>global</code> 对象</li>\n</ul>\n<h3>函数上下文</h3>\n<p>函数 <code>function</code> 或方法 <code>method</code> 在调用时所在的执行环境。</p>\n<pre><code class=\"hljs\" lang=\"javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sayHello</span> (<span class=\"hljs-params\">name</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'hello '</span> + name\n}\nsayHello()\n\n<span class=\"hljs-keyword\">const</span> person = {\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'tom'</span>,\n  say () {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'I am '</span> + <span class=\"hljs-keyword\">this</span>.name)\n  }\n}\nperson.say()\n</code></pre>\n<h3>eval上下文</h3>\n<p><code>eval()</code> 函数创建的执行环境。</p>\n<pre><code class=\"hljs\" lang=\"javascript\"><span class=\"hljs-built_in\">eval</span>(<span class=\"hljs-string\">'console.log(\"in eval\")'</span>)\n</code></pre>\n<h2>函数调用栈(执行上下文栈) Execution Stack</h2>\n<p>首先浏览器中的javascript引擎是单线程，所有的事件和行为都在一个栈结构中储存与调用。</p>\n<ol>\n<li>\n<p>js代码开始执行时，首先会进入到 <strong>全局上下文</strong>，全局上下文总是存在于函数调用栈的最底部。</p>\n</li>\n<li>\n<p>当在全局调用一个 <strong>函数</strong> 时，执行流程会进入到当前函数内，js引擎会创建一个新的函数执行上下文，压入函数调用栈顶部，位于全局上下文之上，并且调用栈(在内存资源充足的情况下)可以压入无限个函数执行上下文。</p>\n</li>\n<li>\n<p>此时如果在一个 <strong>函数内调用了另一个函数</strong> ，执行流程便进入被调用的函数，并创建新的执行上下文，将它压入函数调用栈的顶部，调用栈的顶部此时已是新创建的执行上下文，在函数执行完毕时，执行上下文在没有被引用的情况下(被引用会有闭包的问题)，js引擎会将它从调用栈中弹出，并将控制权返回给之前的执行上下文。</p>\n</li>\n</ol>\n<h2>执行上下文的创建</h2>\n<p>执行上下文的创建可以分为创建和执行两个阶段：</p>\n<h3>创建阶段</h3>\n<p>在执行代码之前会先创建执行上下文：</p>\n<ol>\n<li>初始化作用域链</li>\n<li>创建变量对象\n<ul>\n<li>收集函数的参数</li>\n<li>声明函数，并指向函数的引用</li>\n<li>声明局部变量，并初始化为 <code>undefined</code></li>\n</ul>\n</li>\n<li>确定 <code>this</code> 的指向</li>\n</ol>\n<h3>执行阶段</h3>\n<p>执行代码，进行变量赋值、流程控制、函数调用等操作</p>\n<p>执行上下文创建示意：</p>\n<pre><code class=\"hljs\" lang=\"javascript\">execytionContext = {\n  <span class=\"hljs-string\">'scopeChain'</span>: [\n    <span class=\"hljs-comment\">// 当前执行环境的变量对象variableObject</span>\n    <span class=\"hljs-comment\">// 栈中所有父级执行环境的变量对象</span>\n  ],\n  <span class=\"hljs-string\">'variableObject'</span>: {\n    <span class=\"hljs-comment\">// 函数参数</span>\n    <span class=\"hljs-comment\">// 函数声明</span>\n    <span class=\"hljs-comment\">// 变量声明</span>\n  },\n  <span class=\"hljs-string\">'this'</span>: {}\n};\n</code></pre>\n<h2>创建变量对象</h2>\n<p>为了我们可以使用到当前上下文中声明的所有变量，在生成执行上下文时，js引擎会进行预解析，创建 <strong>变量对象 <code>variable object</code></strong> 来保存所有信息。</p>\n<p>变量对象的创建包括以下几个步骤：</p>\n<h3>1. 初始化变量对象与函数参数</h3>\n<p>创建 <strong>函数参数对象 <code>arguments object</code></strong>，检查参数的上下文，初始化参数的变量名和值，并将它们拷贝一份</p>\n<p>这里导致了参数中的变量会在 <code>var</code> <code>let</code> <code>const</code> <code>function</code> 等主动声明的变量之前被创建，值为参数传入了值，如果未传入参数，默认为 <code>undefined</code>：</p>\n<pre><code class=\"hljs\" lang=\"JavaScript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span> (<span class=\"hljs-params\">arg</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(arg);\n};\nfoo();  <span class=\"hljs-comment\">// undefined</span>\nfoo(<span class=\"hljs-number\">1</span>);  <span class=\"hljs-comment\">// 1</span>\n</code></pre>\n<pre><code class=\"hljs\" lang=\"JavaScript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span> (<span class=\"hljs-params\">arg</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(arg); <span class=\"hljs-comment\">// 这里打印有值，也证明了函数或变量在执行代码前会先提升声明</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">arg</span> (<span class=\"hljs-params\"></span>) </span>{}; <span class=\"hljs-comment\">// 覆盖掉了参数arg</span>\n};\nfoo();  <span class=\"hljs-comment\">// ƒ arg() {}</span>\nfoo(<span class=\"hljs-number\">1</span>);  <span class=\"hljs-comment\">// ƒ arg() {}</span>\n</code></pre>\n<pre><code class=\"hljs\" lang=\"JavaScript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span> (<span class=\"hljs-params\">arg</span>) </span>{ <span class=\"hljs-comment\">// 这里会先声明一次</span>\n  <span class=\"hljs-keyword\">let</span> arg; <span class=\"hljs-comment\">// 声明第二次就会报错</span>\n};\nfoo(); <span class=\"hljs-comment\">// Identifier 'arg' has already been declared</span>\n</code></pre>\n<pre><code class=\"hljs\" lang=\"JavaScript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span> (<span class=\"hljs-params\">arg, arg=<span class=\"hljs-number\">1</span></span>) </span>{ <span class=\"hljs-comment\">// 声明两次并赋予默认值时会报错</span>\n  <span class=\"hljs-built_in\">console</span>.log(arg);\n};\n<span class=\"hljs-comment\">// Uncaught SyntaxError: Duplicate parameter name not allowed in this context</span>\n</code></pre>\n<h3>2. 内部函数的声明</h3>\n<p>扫描上下文中的 <strong>函数声明</strong>，每找到一个函数声明，就在变量对象中创建一个同名属性，它保存了函数内存地址的引用，如果函数已存在，引用将会被覆盖：</p>\n<pre><code class=\"hljs\" lang=\"JavaScript\"><span class=\"hljs-built_in\">console</span>.log(f);   <span class=\"hljs-comment\">// 函数的声明被提前了，</span>\nf();              <span class=\"hljs-comment\">// 在这里是可以访问到的。</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"I'm here!\"</span>)\n};\n</code></pre>\n<pre><code class=\"hljs\" lang=\"javascript\">foo(); <span class=\"hljs-comment\">// 2</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>);\n};\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span> (<span class=\"hljs-params\"></span>) </span>{  <span class=\"hljs-comment\">// 覆盖了上面已声明的同名函数</span>\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">2</span>);\n};\n</code></pre>\n<h3>3. 局部变量的声明</h3>\n<p>函数声明结束后，才是变量的声明。</p>\n<p>扫描上下文中的 <strong>变量声明</strong>，每找到一个变量声明，就会在变量对象中创建一个属性，并将它初始化为 <code>undefined</code>，(这也就是为什么当我们声明一个变量后未赋值时，立即访问它会是 <code>undefined</code> 的原因)如果发现重新声明的变量，则会忽略它。</p>\n<pre><code class=\"hljs\" lang=\"javascript\"><span class=\"hljs-built_in\">console</span>.log(a); <span class=\"hljs-comment\">// undefined   声明在先，但还未赋值</span>\n<span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">1</span>;      <span class=\"hljs-comment\">// a被赋值为1</span>\n<span class=\"hljs-built_in\">console</span>.log(a); <span class=\"hljs-comment\">// 1</span>\n</code></pre>\n<pre><code class=\"hljs\" lang=\"JavaScript\">a(); <span class=\"hljs-comment\">// 2</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">a</span> (<span class=\"hljs-params\"></span>) </span>{log(<span class=\"hljs-number\">1</span>)};  <span class=\"hljs-comment\">// 函数声明</span>\na(); <span class=\"hljs-comment\">// 2</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">a</span> (<span class=\"hljs-params\"></span>) </span>{log(<span class=\"hljs-number\">2</span>)};  <span class=\"hljs-comment\">// 函数声明</span>\na(); <span class=\"hljs-comment\">// 2</span>\n<span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{log(<span class=\"hljs-number\">3</span>)};  <span class=\"hljs-comment\">// 这里的函数表达式是赋值操作，并不是函数声明，声明的只有变量a</span>\na(); <span class=\"hljs-comment\">// 3</span>\n</code></pre>\n<p>值得注意的都是，<a href=\"http://es6.ruanyifeng.com/#docs/let\"><code>let</code> <code>const</code></a> 关键字有声明变量的过程，但是在声明之前的区域都属于 <strong>“暂时性死区”</strong>，变量将不可访问，尝试访问会报错，这样更有利于规范的书写代码，避免产生不必要的错误：</p>\n<pre><code class=\"hljs\" lang=\"JavaScript\"><span class=\"hljs-built_in\">console</span>.log(a); <span class=\"hljs-comment\">// 属于“暂时性死区”</span>\n<span class=\"hljs-keyword\">let</span> a;\n<span class=\"hljs-comment\">// Uncaught ReferenceError: a is not defined</span>\n</code></pre>\n<pre><code class=\"hljs\" lang=\"javascript\"><span class=\"hljs-keyword\">typeof</span> a;\n<span class=\"hljs-keyword\">let</span> a;\n<span class=\"hljs-comment\">// Uncaught ReferenceError: a is not defined</span>\n</code></pre>\n<p>下面这个例子解释了当一个函数被调用时，变量对象在上下文中的变化：</p>\n<pre><code class=\"hljs\" lang=\"JavaScript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">a, b</span>) </span>{\n  <span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{};\n  <span class=\"hljs-keyword\">var</span> y = <span class=\"hljs-number\">2</span>;\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f</span>(<span class=\"hljs-params\"></span>) </span>{};\n};\nfoo(<span class=\"hljs-number\">1</span>);\n\n<span class=\"hljs-comment\">// 变量对象的初始化：</span>\nfooExecutionContext = {\n  <span class=\"hljs-attr\">scopeChain</span>: { ... },\n  <span class=\"hljs-attr\">variableObject</span>: {\n    <span class=\"hljs-attr\">arguments</span>: {\n      <span class=\"hljs-number\">0</span>: <span class=\"hljs-number\">1</span>,\n      <span class=\"hljs-attr\">length</span>: <span class=\"hljs-number\">1</span>,\n      <span class=\"hljs-comment\">// callee: ƒ foo(a, b),</span>\n      <span class=\"hljs-comment\">// Symbol(Symbol.iterator): ƒ values(),</span>\n      <span class=\"hljs-comment\">// __proto__: Object</span>\n    },\n    <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>,\n    <span class=\"hljs-attr\">b</span>: <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-comment\">// 未传入的参数不会被拷贝进arguments中</span>\n    f: pointer to ƒ f()\n    x: <span class=\"hljs-literal\">undefined</span>,\n    <span class=\"hljs-attr\">y</span>: <span class=\"hljs-literal\">undefined</span>\n  },\n  <span class=\"hljs-attr\">this</span>: <span class=\"hljs-built_in\">window</span>\n}\n\n\n<span class=\"hljs-comment\">// 代码执行后变量对象的变化：</span>\nfooExecutionContext = {\n  <span class=\"hljs-attr\">scopeChain</span>: { ... },\n  <span class=\"hljs-attr\">variableObject</span>: {\n    <span class=\"hljs-attr\">arguments</span>: {\n      <span class=\"hljs-number\">0</span>: <span class=\"hljs-number\">1</span>,\n      <span class=\"hljs-attr\">length</span>: <span class=\"hljs-number\">1</span>,\n      <span class=\"hljs-comment\">// callee: ƒ foo(a, b),</span>\n      <span class=\"hljs-comment\">// Symbol(Symbol.iterator): ƒ values(),</span>\n      <span class=\"hljs-comment\">// __proto__: Object</span>\n    },\n    <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>,\n    <span class=\"hljs-attr\">b</span>: <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-comment\">// 未传入的参数不会被拷贝进arguments中</span>\n    f: pointer to ƒ f()\n    x: ƒ (),\n    <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">2</span>\n  },\n  <span class=\"hljs-attr\">this</span>: <span class=\"hljs-built_in\">window</span>\n}\n</code></pre>\n<h2>this的指向</h2>\n<p>js现为止只有全局作用域与函数作用域两种，不同作用域中的 <code>this</code> 指向是不同的</p>\n<ul>\n<li>\n<p>首先 <strong>全局作用域</strong> 中的 <code>this</code> 永远指向的是全局对象，浏览器中为 <code>window</code>对象，nodejs中为 <code>global</code>对象</p>\n</li>\n<li>\n<p>而 <strong>函数作用域</strong> 中 <code>this</code> 的指向是在创建执行上下文时被确立的，默认指向的是调用此函数的对象，所以决定 <code>this</code> 指向的关键就是——<strong>函数是如何调用的</strong></p>\n</li>\n</ul>\n<p>函数的调用有多种情况：</p>\n<h3>全局函数调用</h3>\n<p>在<strong>全局作用域</strong>中调用函数时，并没有对象在调用这个函数，<code>this</code> 本会是 <code>undefined</code>，但是会默认隐式指向<strong>全局对象</strong>：</p>\n<pre><code class=\"hljs\" lang=\"javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>);\n};\nfoo(); <span class=\"hljs-comment\">// Window {...}</span>\n</code></pre>\n<p>而使用了 <strong>严格模式 <code>&quot;use strict&quot;</code></strong> ，<code>this</code> 将会是被指定的值；如果未指定，它会是 <strong><code>undefine</code></strong>：</p>\n<pre><code class=\"hljs\" lang=\"javascript\"><span class=\"hljs-meta\">'use strict'</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span> (<span class=\"hljs-params\"></span>) </span>{;\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>);\n};\nfoo(); <span class=\"hljs-comment\">// undefined</span>\n</code></pre>\n<blockquote>\n<p>在<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode#Securing_JavaScript\">严格模式</a>下通过 <code>this</code> 传递给一个函数的值不会被强制转换为一个对象。对一个普通的函数来说，<code>this</code> 总会是一个对象：不管调用时 <code>this</code> 它本来就是一个对象；还是用布尔值，字符串或者数字调用函数时函数里面被封装成对象的 <code>this</code>；还是使用 <code>undefined</code> 或者 <code>null</code> 调用函数时this代表的全局对象（使用call, apply或者bind方法来指定一个确定的this）。这种自动转化为对象的过程不仅是一种性能上的损耗，同时在浏览器中暴露出全局对象也会成为安全隐患，因为全局对象提供了访问那些所谓安全的JavaScript环境必须限制的功能的途径。所以对于一个开启严格模式的函数，指定的 <code>this</code> 不再被封装为对象，而且如果没有指定 <code>this</code> 的话它值是 <code>undefined</code> ：</p>\n</blockquote>\n<pre><code class=\"hljs\" lang=\"javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fun</span>(<span class=\"hljs-params\"></span>) </span>{ <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>; };\n<span class=\"hljs-built_in\">console</span>.log(fun()); <span class=\"hljs-comment\">// Window{...}</span>\n<span class=\"hljs-built_in\">console</span>.log(fun.call(<span class=\"hljs-number\">2</span>)); <span class=\"hljs-comment\">// Number {2}</span>\n<span class=\"hljs-built_in\">console</span>.log(fun.apply(<span class=\"hljs-literal\">null</span>)); <span class=\"hljs-comment\">// Window {...}</span>\n<span class=\"hljs-built_in\">console</span>.log(fun.call(<span class=\"hljs-literal\">undefined</span>)); <span class=\"hljs-comment\">// Window {...}</span>\n<span class=\"hljs-built_in\">console</span>.log(fun.bind(<span class=\"hljs-literal\">true</span>)()); <span class=\"hljs-comment\">// Boolean {true}</span>\n</code></pre>\n<pre><code class=\"hljs\" lang=\"javascript\"><span class=\"hljs-meta\">\"use strict\"</span>;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fun</span>(<span class=\"hljs-params\"></span>) </span>{ <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>; };\n<span class=\"hljs-built_in\">console</span>.assert(fun() === <span class=\"hljs-literal\">undefined</span>);\n<span class=\"hljs-built_in\">console</span>.assert(fun.call(<span class=\"hljs-number\">2</span>) === <span class=\"hljs-number\">2</span>);\n<span class=\"hljs-built_in\">console</span>.assert(fun.apply(<span class=\"hljs-literal\">null</span>) === <span class=\"hljs-literal\">null</span>);\n<span class=\"hljs-built_in\">console</span>.assert(fun.call(<span class=\"hljs-literal\">undefined</span>) === <span class=\"hljs-literal\">undefined</span>);\n<span class=\"hljs-built_in\">console</span>.assert(fun.bind(<span class=\"hljs-literal\">true</span>)() === <span class=\"hljs-literal\">true</span>);\n</code></pre>\n<h3>对象方法调用</h3>\n<p>函数在对象中通常叫做方法，调用一个对象的方法时，方法中的 <code>this</code> 指向的就是这个调用它的对象：</p>\n<pre><code class=\"hljs\" lang=\"JavaScript\"><span class=\"hljs-keyword\">let</span> cat = {\n  <span class=\"hljs-attr\">nickName</span>: <span class=\"hljs-string\">'meow'</span>,\n  <span class=\"hljs-attr\">say</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.nickName);\n  }\n};\ncat.say(); <span class=\"hljs-comment\">// 'meow'   this指向了cat对象，并可以访问对象的属性</span>\n</code></pre>\n<p>同样，在对象之外定义的函数被设置为对象的方法时，<code>this</code> 的指向会跟着转变：</p>\n<pre><code class=\"hljs\" lang=\"JavaScript\"><span class=\"hljs-keyword\">var</span> nickName = <span class=\"hljs-string\">'zoo'</span>; <span class=\"hljs-comment\">// var会声明为全局对象中的属性</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">say</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.nickName);\n};\n<span class=\"hljs-keyword\">let</span> dog = {\n  <span class=\"hljs-attr\">nickName</span>: <span class=\"hljs-string\">'wang'</span>,\n  say\n};\n<span class=\"hljs-keyword\">let</span> cat = {\n  <span class=\"hljs-attr\">nickName</span>: <span class=\"hljs-string\">'meow'</span>,\n  say\n};\nsay();     <span class=\"hljs-comment\">// 'zoo'    this指向window</span>\ncat.say(); <span class=\"hljs-comment\">// 'meow'   this指向cat</span>\ndog.say(); <span class=\"hljs-comment\">// 'wang'   this指向dog</span>\n</code></pre>\n<h3>构造函数调用</h3>\n<p><code>new</code> 操作符将函数通过构造函数的形式调用，它会创建一个新对象来作为构造函数的实例，将构造函数中的 <code>this</code> 指向这个实例并隐式返这个实例：</p>\n<pre><code class=\"hljs\" lang=\"javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Animal</span> (<span class=\"hljs-params\">name</span>) </span>{\n  <span class=\"hljs-keyword\">this</span>.name = name;  <span class=\"hljs-comment\">// this指向实例</span>\n  <span class=\"hljs-keyword\">this</span>.color = <span class=\"hljs-string\">\"white\"</span>;\n  <span class=\"hljs-comment\">// 隐式返回了实例</span>\n};\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">new</span> Animal(<span class=\"hljs-string\">'cat'</span>));  <span class=\"hljs-comment\">// 构造函数调用   {name: \"cat\", color: \"white\"}</span>\nAnimal(); <span class=\"hljs-comment\">// 函数调用</span>\n</code></pre>\n<h3>使用 <code>call</code> <code>apply</code> <code>bind</code> 调用</h3>\n<p><code>call</code> <code>apply</code> <code>bind</code> 属于函数自身的方法，用以改变 <code>this</code> 的指向。</p>\n<ul>\n<li>\n<p><code>call</code> 传入参数为：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call#%E8%AF%AD%E6%B3%95\">( thisArg, arg1, arg2, ... )</a>，第一个参数为指定函数 <code>this</code> 的值，以后的参数都为调用函数时传入的参数</p>\n</li>\n<li>\n<p><code>apply</code> 传入的参数为：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply#Syntax\">( thisArg, [argsArray] )</a>，第一个参数为指定函数的 <code>this</code>，第二个参数是一个传入函数所有参数的类数组</p>\n</li>\n<li>\n<p><code>bind</code> 传入的参数为：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#%E8%AF%AD%E6%B3%95\">( thisArg[, arg1[, arg2[, ...]]] )</a>，第一个参数为原函数 <code>this</code> 的绑定，后面的参数依次是传入原函数的参数，在调用绑定后的函数时传递过去；调用 <code>bind</code> 函数时并不会调用原函数，而是返回一个绑定了 <code>this</code> 和指定参数的原函数拷贝</p>\n</li>\n</ul>\n<blockquote>\n<p><code>thisArg</code> 为在函数运行时指定的 <code>this</code> 值。需要注意的是，指定的 <code>this</code> 值并不一定是该函数执行时真正的 <code>this</code> 值，如果这个函数处于<strong>非严格模式</strong>下，则指定为 <code>null</code> 和 <code>undefined</code> 的 <code>this</code> 值会自动指向全局对象(浏览器中就是window对象)，同时值为原始值(数字，字符串，布尔值)的 <code>this</code> 会指向该原始值的自动包装对象。</p>\n</blockquote>\n<pre><code class=\"hljs\" lang=\"JavaScript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">a, b</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(a);\n  <span class=\"hljs-built_in\">console</span>.log(b);\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>);\n};\nfoo.call(<span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 1  2  Window {...}</span>\nfoo.apply(<span class=\"hljs-literal\">null</span>, [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]);      <span class=\"hljs-comment\">// 1  2  Window {...}</span>\nfoo.call(<span class=\"hljs-number\">2</span>);         <span class=\"hljs-comment\">// Number {2}</span>\nfoo.apply(<span class=\"hljs-literal\">true</span>);         <span class=\"hljs-comment\">// Boolean {true}</span>\n</code></pre>\n<p>apply传入带有 <code>length</code> 属性的对象时，会被识别为类数组，可以利用这一点创建指定长度的数组，每一项都是 <code>undefnied</code>：</p>\n<pre><code class=\"hljs\" lang=\"JavaScript\"><span class=\"hljs-built_in\">Array</span>.apply(<span class=\"hljs-literal\">null</span>, {<span class=\"hljs-attr\">length</span>: <span class=\"hljs-number\">5</span>});\n</code></pre>\n<pre><code class=\"hljs\" lang=\"JavaScript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">CreatePerson</span>(<span class=\"hljs-params\">name, age</span>) </span>{\n  <span class=\"hljs-keyword\">this</span>.name = name;\n  <span class=\"hljs-keyword\">this</span>.age = age;\n};\n<span class=\"hljs-keyword\">var</span> createTom = CreatePerson.bind({}, <span class=\"hljs-string\">'tom'</span>);\n<span class=\"hljs-keyword\">var</span> tom = <span class=\"hljs-keyword\">new</span> createTom(<span class=\"hljs-number\">12</span>);\n<span class=\"hljs-built_in\">console</span>.log(tom);  <span class=\"hljs-comment\">// {name: \"tom\", age: 12}</span>\n</code></pre>\n<h3>ES6中箭头函数的this</h3>\n<p>ES6中的<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions#Syntax\">箭头函数</a>语法，可以大大简化以往的函数表达式写法，不同的是，箭头函数作用域中没有绑定 <code>this</code>，它的 <code>this</code> 是继承自上一级的，而且箭头函数内是没有 <code>arguments</code> 的</p>\n<pre><code class=\"hljs\" lang=\"JavaScript\"><span class=\"hljs-keyword\">var</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>];\n<span class=\"hljs-keyword\">var</span> newArr = [];\n\nnewArr = arr.map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> value * <span class=\"hljs-number\">2</span>;\n}); <span class=\"hljs-comment\">// [2, 4, 6, 8, 10]</span>\n\nnewArr = arr.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> value * <span class=\"hljs-number\">2</span>;\n}); <span class=\"hljs-comment\">// [2, 4, 6, 8, 10]</span>\n\nnewArr = arr.map(<span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =&gt;</span> value * <span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// [2, 4, 6, 8, 10]</span>\n</code></pre>\n<pre><code class=\"hljs\" lang=\"javascript\"><span class=\"hljs-keyword\">var</span> val = <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-keyword\">var</span> obj = {\n  <span class=\"hljs-attr\">val</span>: <span class=\"hljs-number\">2</span>,\n  showVal() {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getVal</span>(<span class=\"hljs-params\"></span>) </span>{\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.val;\n    };\n    <span class=\"hljs-built_in\">console</span>.log(getVal()); <span class=\"hljs-comment\">// 这里的getVal()其实是全局对象在调用</span>\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.val);\n  }\n};\n\nobj.showVal(); <span class=\"hljs-comment\">// 这儿的showVal()是obj在调用</span>\n<span class=\"hljs-comment\">// 1</span>\n<span class=\"hljs-comment\">// 2</span>\n</code></pre>\n<pre><code class=\"hljs\" lang=\"javascript\"><span class=\"hljs-keyword\">var</span> val = <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-keyword\">var</span> obj = {\n  <span class=\"hljs-attr\">val</span>: <span class=\"hljs-number\">2</span>,\n  showVal() {\n    <span class=\"hljs-keyword\">var</span> getVal = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.val;\n    };\n    <span class=\"hljs-built_in\">console</span>.log(getVal()); <span class=\"hljs-comment\">// 这里的getVal()其实是全局对象在调用，但是this缺继承了上一级的this</span>\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.val);\n  }\n};\n\nobj.showVal(); <span class=\"hljs-comment\">// 这儿的showVal()是obj在调用</span>\n<span class=\"hljs-comment\">// 2</span>\n<span class=\"hljs-comment\">// 2</span>\n</code></pre>\n`,\n    wordCount: 9556\n  }\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/docs/对 javascript 执行环境的探索.mdjs\n// module id = 7afm\n// module chunks = 0 1","module.exports = {\n    info: {\n  title: '透析浏览器工作原理',\n  poster: '',\n  date: '2021-08-05',\n  id: '2021-08-05',\n  desc: '带你经历从URL到页面渲染的旅程'\n},\n    content: `<h2>浏览器架构</h2>\n<h3>单进程浏览器时代</h3>\n<p>2007年之前，浏览器的所有功能模块都运行在同一个进程里，这些模块包含了网络、插件、JavaScript运行环境、渲染引擎和⻚ 面等</p>\n<p>一个页面或者插件崩溃，会导致浏览器崩溃；一个页面运行时占满线程，会导致浏览器整体卡顿</p>\n<h3>多进程浏览器时代</h3>\n<p>浏览器每个tab都是一个单独的渲染进程，一个页面崩溃不会影响其他页面的渲染</p>\n<p>稳定安全、关闭页面即可回收内存、利用沙箱环境限制操作硬盘数据</p>\n<h3>现代Chrome架构</h3>\n<ol>\n<li>浏览器主进程\n负责界面显示、交互、子进程管理、储存</li>\n<li>GPU进程\n负责渲染浏览器界面、页面CSS/3D特效</li>\n<li>网络进程\n负责网络资源的加载</li>\n<li>多个渲染进程\n负责渲染页面，每个页面都会拥有独立的沙箱环境的渲染进程</li>\n<li>多个插件进程\n每个插件也拥有独立的插件进程，防止插件的崩溃影响页面和浏览器</li>\n</ol>\n<h2>数据是如何交换的</h2>\n<p>在网络协议 <code>IP</code> 的标准下，数据包自由地在服务器与客户端之间传递，<code>IP地址</code> 就是设备在网络中的位置信息。</p>\n<p>首先，提供服务的应用程序需要在系统中开放一个端口号，数据在发送前，发送者使用 <code>UDP</code> 协议事先将数据包加工，添加 <code>UDP</code> 头，保存接受者的端口号信息，随后 <code>IP</code> 网络层会在数据包上附加发送者和接受者的 <code>IP地址</code>，以方便发送与回传，这些信息被放在 <code>IP头</code> 中，包含IP版本、源IP地址、目标IP地址、生存时间等信息。</p>\n<h3>UDP</h3>\n<p><code>UDP</code> (User Datagram Protocol) 用户数据包协议传送速度极快，但是不能保证数据的可靠性，因为 <code>UDP</code> 不会为发送失败的数据包进行重发操作，也不关注数据包发送之后是否到了达目的地。</p>\n<h3>TCP</h3>\n<p><code>TCP</code> (Transmission Control Protocol) 传输控制协议是用来解决 <code>UDP</code> 传输问题的协议，会将丢失的数据包进行重传，同时会在接收数据时，将被拆分的数据包排序并组装还原，而且接受者在接收到数据包后，会向发送者发送确认信息，以此保证数据传输的完整性。</p>\n<h3>HTTP</h3>\n<p><code>HTTP</code> 建立与 <code>TCP</code> 链接之上，常用于浏览器向服务器请求数据，浏览器首先使用 <code>TCP</code> 协议与服务器建立链接，然后才开始使用 <code>HTTP</code> 协议发送消息，包含了请求行、请求头、请求体等内容。</p>\n<p>浏览器首先发送 <code>HTTP</code> 请求行，就像这样：<code>GET /images/logo.png HTTP1.1</code>，包含了请求方法、请求URI、HTTP协议版本；之后便会发送请求头信息，包含一些浏览器信息、操作系统信息、请求配置信息等；<code>POST</code> 请求还会发送请求体，也就是浏览器要传输给服务器的数据。</p>\n<p>服务器接收到数据包，然后执行拼装、解析、处理等操作，最后返回一个响应的资源或数据给浏览器，包含了响应行、响应头、响应体等信息。</p>\n<p>响应行结构如下：<code>HTTP/1.1 200 OK</code>，包含了 <code>HTTP</code> 版本、状态码等信息；然后发送响应头，包含服务器相关信息、缓存信息、响应数据类型等；最后会发送响应体，包含服务器发送的数据包。</p>\n<h3>HTTP 缓存</h3>\n<p>浏览器在接收到资源后也会对资源进行缓存，下次请求前，浏览器检查本地存在缓存资源并符合可用条件时，会取消请求的发送，优先返回被缓存的资源。</p>\n<p>浏览器发出请求时会经过 <code>CDN</code> 服务，<code>CDN</code> 返回的 <code>IP</code> 地址会被浏览器缓存在本地，所以下次请求可以省去 <code>CDN</code> 的过程，从而加快请求速度。</p>\n<p>当服务器端返回资源时，会断开 <code>TCP</code> 连接，这样浏览器每次请求都会重新建立 <code>TCP</code> 连接。当服务器设置响应头 <code>Connection: Keep-Alive</code> 时可以建立持久连接，也就是不会断开 <code>TCP</code> 连接，用来被下次的请求复用；</p>\n<p>设置 <code>Cache-control: max-age: 100</code> 响应头，可以告知浏览器主动缓存此资源，并允许在过期之前使用；</p>\n<p><code>ETag</code> 响应头可以设置资源标识信息，当浏览器发起请求时，如果本地资源过期了，浏览器会携带 <code>If-None-Match: &quot;&lt;ETag&gt;&quot;</code> 请求头发起请求，询问服务器此资源是否有更新，当服务器检测到资源没有更新时，会返回 <code>304</code> 状态码通知浏览器继续使用本地缓存，如果资源有更新则响应 <code>200</code> 和最新的数据。</p>\n<p>如果资源不需要缓存，服务器端可以设置 <code>Catch-control: no-store</code> 让浏览器不做缓存；设置 <code>Catch-control: no-cache</code> 可以让浏览器每次请求都询问服务器是否可以使用本地缓存的资源。</p>\n<p>另外，资源在返回给浏览器的途中，如果经历了中间代理服务器，设置响应头 <code>Catch-control: public</code>，可以缓存在代理服务器中，以便下次请求时直接被代理服务器返回；<code>Catch-control: private</code> 则表示不被中间代理缓存。设置 <code>Catch-control: s-max-age=100</code> 响应头可以对代理服务器做过期新鲜度设置，在资源未过期时，浏览器请求资源会被代理服务器直接被返回，从而减少源服务器的压力。</p>\n<p>整体请求链路如下：</p>\n<ol>\n<li>构建请求信息</li>\n<li>查找本地缓存（命中缓存则请求被取消）</li>\n<li>查询 <code>DNS</code></li>\n<li>准备 <code>IP</code> 和端口</li>\n<li>等待 <code>TCP</code> 队列（只能同时并发6个TCP请求）</li>\n<li>建立 <code>TCP</code> 连接（经历三次握手的阶段）</li>\n<li>发送 <code>HTTP</code> 请求数据（请求行、请求头(附加cookie)、请求体）</li>\n<li>中间代理服务器（命中缓存则被返回）</li>\n<li>服务器返回响应数据（响应行、响应头、响应体）</li>\n<li>解析响应头（<code>310,320</code> 重定向则重新请求；根据 <code>Content-Type</code> 进行渲染文档或下载等操作）</li>\n<li>网络进程提交文档给渲染进程（同站点会复用渲染进程）</li>\n<li>开始解析渲染页面</li>\n</ol>\n<h2>渲染原理</h2>\n<p>浏览器解析文档会经历以下过程：</p>\n<p>构建 <code>DOM</code> 树、算计式样、布局阶段、分层、绘制、分块、光栅化、合成</p>\n<h3>构建 DOM 树</h3>\n<p><code>HTML</code> 代码被编译为树结构的内容才能被渲染引擎理解，也方便被 <code>JS</code> 操作，这个树结构就是 <code>DOM</code> 树。</p>\n<h3>生成计算样式</h3>\n<p>有了 <code>DOM</code> 树，浏览器还需要知道节点的样式才能渲染，这就需要对 <code>CSS</code> 代码进行解析，生成 <code>CSSOM</code> 树。<code>CSSOM</code> 的构建不会阻塞 <code>DOM</code> 树的解析，但是会阻塞布局树的合成，以及阻塞 <code>js</code> 代码的执行（<code>js</code> 有操作 <code>CSSOM</code> 的能力）。</p>\n<ol>\n<li>CSS 树</li>\n</ol>\n<p><code>CSS</code> 代码来源于：</p>\n<ol>\n<li>外联样式 <code>&lt;link href=&quot;dist.css&quot; rel=&quot;stylesheet&quot;&gt;</code></li>\n<li>内联样式 <code>&lt;style&gt;h1 { color: red }&lt;/style&gt;</code></li>\n<li>行内样式 <code>&lt;h1 style=&quot;color: red&quot;&gt;hello&lt;/h1&gt;</code></li>\n</ol>\n<p>转换成 <code>CSSOM</code> 结构后，需要对 <code>CSS</code> 属性的值做标椎化处理，例如将 <code>red</code> 转换为浏览器理解的颜色值：<code>rgb(255, 0, 0)</code></p>\n<ol start=\"2\">\n<li>计算样式</li>\n</ol>\n<p>节点的样式首先会先继承父节点的样式，例如 <code>font-size</code>、<code>color</code> 等，其次是设置自身默认样式，再然后设置自身命中选择器的样式等，最终会层层合并已有的同名样式得到 <code>ComputedStyle</code>（计算样式）。</p>\n<h3>布局阶段</h3>\n<p>得到 <code>DOM</code> 树和计算样式后，浏览器开始布局操作，计算出 <code>DOM</code> 树可见元素的几何位置。</p>\n<ol>\n<li>布局树</li>\n</ol>\n<p>同样，布局也需要创建布局树，也就是把之前解析出来的 <code>DOM</code> 树和 <code>CSSOM</code> 树结合起来，遍历出其中所有的可见元素，例如：<code>head</code> 标签、<code>display: none</code> 的标签等，最终会生成一颗布局树。</p>\n<ol start=\"2\">\n<li>布局计算</li>\n</ol>\n<p>渲染引擎计算出每个元素对应的几何位置，布局计算的结果会写进布局树中</p>\n<h3>分层</h3>\n<p>浏览器根据布局树，为特定的节点生成专有图层，最终生成图层树(LayerTree)</p>\n<p>并不是每个节点都拥有自己的图层，没有创建自己的层叠上下文的元素会被父层叠上下文同化，且 <code>&lt;html&gt;</code> 元素默认拥有层叠上下文。</p>\n<p>设置以下属性的元素会有独立的图层（有些需要 <code>z-index</code> 不为 <code>auto</code>）：</p>\n<ul>\n<li>非 <code>static</code> 值的 <code>position</code></li>\n<li><code>flex</code></li>\n<li><code>grid</code></li>\n<li><code>opacity</code> 小于 <code>1</code></li>\n<li><code>transform</code></li>\n<li><code>filter</code></li>\n<li><code>perspective</code></li>\n<li><code>clip-path</code></li>\n<li><code>mask</code> / <code>mask-image</code> / <code>mask-border</code></li>\n<li><code>will-change</code></li>\n</ul>\n<p>同时，当元素溢出容器被隐藏时，也会创建独立的层，滚动条也拥有独立的层。</p>\n<h3>绘制</h3>\n<p>渲染引擎主线程根据图层拆分成绘制指令，组成绘制列表，提交给合成线程处理。</p>\n<h3>栅格化 raster</h3>\n<p>合成线程将图层划分为图块（tile），例如 256x256、512x512 大小的图块，根据视口（viewPort）大小，优先处理视口附近的可视图块，使用栅格化技术将其变成位图。</p>\n<p>光栅化使用线程池将图块转为位图，并且常常会使用 GPU 来加速生成过程，生成的位图被保存在 GPU 内存中，这些生成过程都是在 GPU 进程中完成的。</p>\n<h3>合成与显示</h3>\n<p>光栅化完成后，合成线程开始绘制图块，发出 <code>DrawQuad</code> 命令，浏览器进程接收到命令后，将页面内容绘制到内存中，然后显示在屏幕上。</p>\n<h3>重排与重绘</h3>\n<p>更新元素的几何属性，例如宽高，元素需要重新计算样式表、布局树、图层树以及之后的所有操作。</p>\n<p>更新元素的绘制属性，例如颜色背景，元素需要重新计算样式表，但是不需要重新计算布局与图层，直接执行后面的工作。</p>\n<h2>变量提升</h2>\n<p>JS引擎在执行代码前需要进行预编译，会将 var 声明的变量、函数存到作用域内的变量对象中，let 声明的变量会放在词法环境(Lexical Environment)中，块级作用域中的 let 变量会声明在词法环境的栈空间中，新的变量会放在栈顶，变量的查找方式为从栈顶向下查找，再查找变量对象，之后是函数作用域之外，也就是原型链；var/let声明的变量会被赋值 <code>undefined</code>，声明的函数会被创建在堆内存中，然后将函数的引用保存给一个变量，然后存进变量对象中；并且后声明的变量或函数会覆盖掉已声明的变量；之后引擎会将代码中声明之外的代码编译为字节码，然后一行一行的执行。</p>\n<h2>堆栈</h2>\n<p>代码执行过程中，主要搜三种类型内存空间：代码空间、栈空间、堆空间</p>\n<p>栈空间就是执行上下文的调用栈，原始类型的变量存放在执行上下文中，可以说原始类型的变量存放在栈内存中；引用类型的数据会先在堆内存中分配空间，并将堆空间的地址赋值在变量中。</p>\n<p>栈空间需要维护执行上下文，以及高效的内存分配与内存回收，所以不会存储很大的数据，因此原始类型的数据只存在栈中，例如对象这类占用空间大的数据则会存在堆空间中。</p>\n<h2>垃圾回收</h2>\n<h3>代际假说</h3>\n<ol>\n<li>大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可\n访问;</li>\n<li>不死的对象，会活得更久。</li>\n</ol>\n<p>V8 引擎会把<strong>堆</strong>分为<strong>新生代</strong>和<strong>老生代</strong>两个区域，新生代存放生存时间短的对象，老生代存放生存时间久的对象；V8 分别使用两个不同的回收器来回收内存，副回收器负责新生代，主回收器负责老生代。</p>\n<h3>执行流程</h3>\n<ol>\n<li>标记空间中的活动对象和非活动对象。活动对象就是还在使用的对象，非活动对象就是可以进行回收的对象。</li>\n<li>回收非活动对象占用的内存。</li>\n<li>内存管理。整理回收后出现的大量不连续空间的内存碎片。</li>\n</ol>\n<h3>新生代</h3>\n<p>新生代使用 Scavenge 算法处理内存回收，大多数小的对象会被放入新生代中。新生代的空间分为两个区域，一个是对象区域，一个是空闲区域，新加入的对象会放入对象区域，当对象区域快写满时就执行一次垃圾回收。</p>\n<h2>V8 执行代码的过程</h2>\n<h3>编译器和解释器</h3>\n<p>编程语言一般分为编译型语言和解释型语言</p>\n<ul>\n<li>编译型语言在程序执行前经过编译器(TurboFan)编译成二进制文件才进行执行。</li>\n</ul>\n<p>代码 -&gt; 词法分析/语法分析 -&gt; AST -&gt; 词义分析 -&gt; 中间代码 -&gt; 代码优化 -&gt; 二进制文件 -&gt; 直接执行</p>\n<ul>\n<li>解释器语言需要每次运行时通过解释器(Ignition)动态解释和执行代码。</li>\n</ul>\n<p>代码 -&gt; 词法分析/语法分析 -&gt; AST -&gt; 词义分析 -&gt; 字节码 -&gt; 解释执行</p>\n<h3>AST</h3>\n<p><code>AST</code> 是代码的结构化表示，可以用来处理并生成新的代码</p>\n<p>如何在生成AST：</p>\n<ol>\n<li>\n<p>词法分析/分词(tokenize)\n将代码拆分为一个个 token，关键字、变量标识、控制语句、字面量等都会被拆分</p>\n</li>\n<li>\n<p>语法分析/解析(parse)\n将tokens转化为AST</p>\n</li>\n</ol>\n<p>此后还会生成执行上下文</p>\n<h3>字节码</h3>\n<p>字节码是介于AST和机器码之间的一种代码，通过解释器转换为机器码才可以执行</p>\n<p>解释器根据AST生成字节码，并解释执行字节码，且字节码占用内存空间比机器码小很多</p>\n<h3>代码执行</h3>\n<p>解释器会逐条解释执行字节码，在执行过程中，如果发现有一段代码被重复执行多次，也就是热点代码(HotSpot)，此时后台的编译器就会把热点代码的字节码编译成高效的机器码，当以后再次执行热点代码的时候，只需要执行机器码就可以了，这样就提高了代码执行效率，这种解释器与编译器的配合技术即为：即时编译(JIT)</p>\n<h2>事件循环</h2>\n<p>消息队列是一个储存任务的队列，也被称为宏任务队列，新任务会从队列尾部加入，例如JS代码执行、输入事件、文件读取、WebSocket、定时器、DOM解析、样式计算、布局计算、CSS动画等任务，渲染主线程会从消息队列头部读取任务然后执行。渲染进程会通过一个<strong>IO线程</strong>接收其他线程发送过来的任务消息，然后这些任务被添加进任务队列中，等待渲染主线程的执行</p>\n<p>每个宏任务中都包含了一个微任务队列，每当宏任务正在执行中时，如果 DOM 节点发生了变化触发 <code>MutationObserver</code> 或者 <code>Promise</code>，则会添加到微任务的队列中，在当前宏任务被执行完毕前，渲染引擎会依次执行微任务队列中的所有微任务，这个时间叫做检查点。以此确保了 DOM 频繁变化时不会立刻被执行更新任务而导致当前宏任务的阻塞，从而不影响后面宏任务的执行效率，此方式提供了在当前宏任务结束后批量执行更新任务的能力，来保证 DOM 节点变化的实时性</p>\n<p>setTimeout 定时器添加的回调任务会被添加进延迟队列中，每次完成一个宏任务时，会检查延迟任务队列，根据发起时间和延迟时间，依次执行过期的任务。clearTimeout通过传入的定时器ID，找到对应的延迟任务，然后从列表中删除。定时器嵌套5层时，v8引擎会认为嵌套函数发生了阻塞，会将定时器最小触发时间设置为 4 毫秒，而且一个阻塞的任务会时定时器任务延后执行。未被激活的页面，最低延迟会是1000毫秒</p>\n<p>xmlHttpRequest 同样是通过异步回调的方式将执行任务，当请求被send时，渲染进程通过 IPC 调用通知网络进程发起请求和下载资源，当网络进程完成请求时通知渲染进程，渲染进程会将事件函数封装成任务添加进消息队列，然后等待执行</p>\n<p>当页面要退出时，主线程会设置退出标志的变量，每次执行完任务时，会检查是否设置了退出标志，如果有就终端所有任务，并退出线程。</p>\n<h2>协程（Coroutine）与生成器（Generator）与await</h2>\n<h3>生成器</h3>\n<p>生成器是 function* 声明的函数，在生成器函数内部执行一段代码，如果遇到yield关键字，那么JavaScript引擎将返回关键字后面的内容 给外部，并暂停该函数的执行，外部函数可以通过next方法恢复函数的执行</p>\n<h3>协程</h3>\n<p>之所以生成器可以暂停函数执行，是因为使用了协程，协程是一种比线程更加轻量级的存在，相当于跑在线程上的任务，一个线程可以有多个协程，但是同时只能执行一个协程，从A协程切换到B协程，A需要将主线程的控制权交给B协程，此时A协程被称为B协程的父协程</p>\n<p>例如当生成器fn被调用时，主线程会创建fn协程，而且fn函数不会立即执行；当调用next时，主线程交给fn协程的执行，遇到 yield 关键字时会暂停协程，将yield后面的内容返还给主线程，并交出主线程控制权，当next再次被调用时，再次恢复到fn协程继续执行fn函数，以此往复；在 fn 遇到 return 时会关闭当前协程，在切换协程时会保存父协程的调用栈信息，恢复子协程的调用栈信息</p>\n<h3>await</h3>\n<p>当父协程遇到 async 函数调用时，会保存外部作用域，并为这个函数创建子协程，将主线程的控制权交给子协程；当子协程遇到 await 关键字时，会将后面的内容包装成 promise，并加入到微任务队列，之后会暂停子协程，保存子协程的函数作用域，将主线程的控制权交给父协程，此时父协程会为这个 Promise 添加一个 then 回调函数来监听 Promise 状态，之后继续执行剩下流程；当检查点到来时，微任务会依次执行，当这个回调函数被激活时，会从父协程切换回子协程，并恢复函数作用域，同时将 resolve 的值传递给子协程，继续执行剩下内容，直到 async 函数执行完毕，然后退出协程，恢复到父协程</p>\n<h2>DOM 树的构建过程</h2>\n<p>首先，网络进程在接收到响应头后，判断 Content—Type 是 HTML 类型时，会创建新的渲染进程，网络进程和渲染进程之间会建立共享的数据管道，网络进程接收到数据后会通过管道传输给渲染进程，渲染进程动态的接收字节流，最终解析成DOM树</p>\n<p>渲染引擎内部有一个 HTMLParser 用来解析 HTML 代码，分词器会将字节流不断转换为 token，例如 tagToken 和 textToken，然后按顺序添加进 tokens 栈中，并根据进栈的 token 类型组成 DOM 树，DOM 树也会在一开始初始化为以 document 为根节点的 DOM 树结构，并将 startTag document 添加进栈底</p>\n<p>例如 tagToken 一般会有开始标签和结束标签，如果进栈的是 startTag 时，会在 DOM 树中创建开始标签，遇到 textToken 时，会在这个标签中添加文本节点，或者再次遇到 startTag 时，会在此标签中创建子 tag 元素；当遇到 endTag 时，会在 DOM 树中创建结束标签，以此往复，这样就完成的树结构的创建</p>\n<h2>HTTP 发展史</h2>\n<h3>HTTP0.9</h3>\n<p>HTTP0.9 只为了传输简单文本信息，只有请求行和响应行，用来解释数据内容的基本信息。</p>\n<h3>HTTP1.0</h3>\n<p>HTTP1.0 添加了请求头和响应头，支持多种文件类型、语言版本、编码类型、压缩方式等内容的传输，还加入了状态码、缓存机制、用户代理等功能</p>\n<h3>HTTP1.1</h3>\n<p>HTTP1.1 支持了在建立一次TCP连接即可进行多次HTTP请求，但是后一次的HTTP请求需要等待前一次HTTP的响应，也就是队头阻塞；还加入了cookie机制</p>\n<h3>HTTP2.0</h3>\n<p>HTTP2 支持多路复用，解决的TCP的慢启动和HTTP1.1的队头阻塞问题，一个域名只启用一个TCP长连接，请求可以并行发出。经过二进制分帧层将请求变成唯一ID的帧发送出去，在接收到响应时，根据ID编号将数据帧提交给对应的请求；同时也可以设置请求的优先级，让服务器优先处理优先级高的请求；还可以将资源主动推送给浏览器端，例如HTML页面引用的CSS、JS资源；另外请求头和响应头也可以进行压缩；在分包传输的过程中，如果有丢包发生，那同样会阻塞后面的请求，变成对头阻塞</p>\n<p>TCP连接会进行三次握手，以及HTTPS协议会进行TLS握手，通常会花费3-4个RTT时间</p>\n<h3>HTTP3</h3>\n<p>HTTP3 为了解决TCP协议引发的问题，改用UDP协议实现了类似TCP的多路数据流、流量控制、传输可靠性功能，这个协议叫做 QUIC 协议，数据流可以单独传输，解决了TCP对头阻塞，由于基于UDP协议，所以可以实现快速握手</p>\n<h2>XSS</h2>\n<h3>储存型攻击</h3>\n<p>恶意代码储存在数据库中，用户访问页面加载数据库内容时触发</p>\n<h3>反射型攻击</h3>\n<p>在URL的query中注入恶意代码</p>\n<h3>基于DOM的攻击</h3>\n<p>劫持HTML页面来注入恶意代码</p>\n<h3>防范</h3>\n<p>过滤、转义恶意代码</p>\n<p>设置CSP，禁止加载不明来源的资源，禁止内联脚本，上报攻击事件</p>\n<h2>CSRF 跨站请求伪造</h2>\n<p>利用服务器漏洞以及用户登录状态实施攻击的行为</p>\n<h3>防范</h3>\n<h4>SameSite</h4>\n<p>在cookie中设置SameSite防止cookie被窃取</p>\n<p>Strict：完全禁止第三方cookie</p>\n<p>Lax：相对宽松的规则，第三方站点的get请求可以携带cookie，post、img、iframe不可以携带cookie</p>\n<p>None：会在任何情况下都携带cookie</p>\n<h4>Referer 和 Origin</h4>\n<p>除了设置SameSite外，还可以在服务器端验证请求来源的站点，根据请求头中的referer属性，判断请求来源地址，或者判断origin属性确定来源</p>\n<h4>CSRF token</h4>\n<p>服务端返回用于验证的token植入在页面中，第三方站点无法拿到token就无法请求成功</p>\n<h2>浏览器沙箱</h2>\n<p>由于不能保证任何网络环境都是安全的，避免因为浏览器漏洞而被不安全的网页、资源攻击，浏览器架构分开了浏览器进程和渲染进程两大部分，浏览器进程负责资源的下载、页面的显示、文件读取、cookie管理、cache管理等，渲染进程负责资源的解析，页面的绘制与生成，两者通过IPC调用来通信，渲染进程本身被隔离在沙箱环境中，如果不安全的页面或资源被运行，因为处在沙箱环境中，所以不会获得高级别的权限，不会危害用户的操作系统环境和数据</p>\n<p>沙箱隔离了渲染进程对文件、缓存、cookie的直接读取，必须通过IPC调用与浏览器进程通信来操作，同样，渲染进程不可以直接访问网络，必须通过浏览器进程访问网络、下载资源，浏览器进程还会在请求前检查跨域、HTTPS信息等</p>\n<h3>渲染与交互</h3>\n<p>关于页面渲染和交互，渲染进程需要将页面渲染成位图发送至浏览器进程，浏览器进程通过狂口句柄复制到屏幕上；至于用户触发的操作事件也是浏览器进程把控，在经过调度后，将页面窗口内的事件转发给渲染进程，浏览器界面的事件由浏览器进程自己处理，这样可以防止渲染进程监控用户输入事件而造成安全问题</p>\n<h3>站点隔离</h3>\n<p>相同根域名和相同协议的地址会被认为是同一站点，会分贝在同一个渲染进程中执行，不同站点会放在不同的渲染进程中，而且在页面内嵌入的iframe也需要站点隔离，防止利用系统级别的漏洞发起攻击</p>\n<h2>HTTPS</h2>\n<p>由于TCP连接过程中，很有可能会被中间人窃取请求信息，所以引入了加密协议HTTPS。在HTTPS的协议栈中，TCP与HTTP之间插入了一个安全层，数据经过安全层后会被加密或解密</p>\n<p>加密的方式有很多中：</p>\n<h3>对称加密</h3>\n<p>最简单的加密方式，也就是数据的加密与解密都使用了同一个秘钥</p>\n<p>浏览器端发起HTTP请求经过安全层后会进行握手操作：浏览器发送支持的加密套件以及一个随机数给服务器，服务器选择加密套件后返回加密套件和一个新的随机数，浏览器返回确认，服务器也返回确认，之后，浏览器会根据双方的随机数生成秘钥，然后使用加密套件加密数据，这时候就可以进行数据的传输了。这样还是会被中间人窃取秘钥信息，从而篡改数据</p>\n<h3>非对称加密</h3>\n<p>非对称加密算法使用两个秘钥，公钥用来加密，私钥用来解密，服务器会生成好公钥和私钥，在经过安全层时，浏览器向服务器发送加密套件列表，服务器将选择的加密套件和公钥传递给浏览器，浏览器向服务端发起确认，服务器向浏览器回应确认，之后浏览器发送数据时，会使用公钥加密数据，然后服务器使用私钥解密数据，所以公钥被中间人获取了也无法解密数据</p>\n<p>非对称加密的缺点是加解密的效率太低，如果每次数据发送都是用非对称加密，则会影响数据传输的速度，还有就是公钥泄露的问题，虽然数据不会被解密，但是公钥被中间人拿到后，就无法保证浏览器传输给服务器的数据是真是的了</p>\n<h3>对称加密和非对称加密搭配使用</h3>\n<p>结合两者的特性，只要在秘钥传输时使用非对称加密，数据传输是使用对称加密就可以解决效率问题</p>\n<p>在经过加密层时，浏览器发送对称加密套件列表、非对称加密套件列表和随机数，服务器返回选择的对称加密和非对称加密套件，以及一个随机数和公钥，浏览器使用这两个随机数计算出pre-master，并用公钥加密，发送给服务器，服务器使用私钥解密pre-master，返回确认消息，之后浏览器和服务器就使用这两个随机数和pre-master生成对称秘钥进行数据传输</p>\n<h4>数字证书</h4>\n<p>如果浏览器访问的地址被中间人通过DNS劫持，由中间人的服务器向浏览器提供公钥，然后再转发给服务器，那么还是会有安全风险，无法保证公钥的正确性，也就是浏览器无法判断服务器是否是真实的</p>\n<p>如果通过一个权威机构，为服务器颁发一个可信的数字，就可以证明服务器的身份了，这个机构就是CA(certificate authority)，这个证书叫数字证书(digital certificate)，数字证书可以证明服务器的身份，同时也包含了公钥信息</p>\n<p>服务器不再直接返回公钥，而是返回了数字证书，其中包含了公钥，浏览器会校验证书的可靠性，之后才会继续传输数据，即使中间人拦截了请求，但是无法返回正确的数字证书，所以无法完成攻击</p>\n<p>注册数字证书认证需要向CA提供公司、站点，以及公钥等信息，CA通过线上线下渠道核实信息的真实性后才会签发数字证书，CA使用私钥加密计算过后的信息摘要，得到数字签名，在浏览器接收到服务器发来的数字证书时，同样计算出信息摘要，然后使用CA的公钥对数字签名解密，得到的结果与信息摘要一致时，就说明这个数字证书是合法的，可以信任。</p>\n`,\n    wordCount: 10998\n  }\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/docs/浏览器原理.mdjs\n// module id = I4L2\n// module chunks = 0 1","module.exports = {\n    info: {\n  title: 'SVG Animation',\n  poster: '',\n  date: '2018-12-12',\n  id: '2018-12-12',\n  desc: '这篇文章将介绍 SVG 与 SVG 基本图形的绘制，以及使用 SVG 来制作有趣的动画效果'\n},\n    content: `<p>在介绍 SVG 之前，我们首先了解一下图形</p>\n<h2>图形</h2>\n<p>计算机中图形的表示方式分为两种：栅格图形 和 矢量图形</p>\n<h3>栅格图形</h3>\n<p>栅格图形又称为位图或点阵图，使用像素阵列表示图像，比如 png，jpg，gif 等图片格式都是栅格图形，每个像素都有特定的位置与颜色值，可以表示的颜色由每个像素的携带的色值决定，像素与颜色信息越多，图片储存空间就越大</p>\n<p><img src=\"/static/svg-animation/img/demo1.jpg\" alt=\"demo1\"></p>\n<p>一般浏览器使用的都是栅格图形，但是它也有缺点，就是当小的图形被放大显示时，图形边缘会产生锯齿，使得显示效果失真，例如这样：</p>\n<p><img src=\"/static/svg-animation/img/demo2.png\" alt=\"demo2\"></p>\n<h3>矢量图形</h3>\n<p>矢量图形是计算机用点、直线或者多边形等基于数学方程的几何图形表示的图像。</p>\n<p>因为矢量图形是根据坐标绘制的，所以与分辨率无关，放大与缩小都不会丢失细节，曲线的边缘更加平滑，不影响清晰度，且保存体积比栅格图形小</p>\n<p><img src=\"/static/svg-animation/img/tool.svg\" alt=\"download\"><img src=\"/static/svg-animation/img/star.svg\" alt=\"star\"><img src=\"/static/svg-animation/img/tree.svg\" alt=\"tree\"></p>\n<h2>SVG</h2>\n<h3>SVG 即可缩放矢量图形（Scalable Vector Graphics）</h3>\n<p>SVG 使用 XML 来描述，属于 XML 分支语言的一种，可以用于绘制矢量图形。SVG 通过定义线或形状来创建一个图形，也可以修改位图，或者将两种方式结合起来创建图形。</p>\n<p>HTML 提供了标题、段落、表格等内容的元素，与此类似，在 SVG 中也提供了一些元素，比如用于定义圆、矩形、曲线和多边形等。一个简单的SVG文档由 <code>&lt;svg&gt;</code> 根元素（相当于 <code>&lt;html&gt;</code> 根元素）和基本的形状元素构成。另外还有一个 <code>&lt;g&gt;</code> 元素，用来把若干个基本形状编写成一个组。当然 SVG 可以与 javascript、css 结合起来使用，当以 <code>.svg</code> 为后缀保存在文件里时，可以被 img、iframe、background 引用。</p>\n<p>SVG 属于 XML 语言，是区分大小写的，这一点与 HTML 不同；与 HTML 相同的是：默认先出现的元素会出现在底层，后出现的元素会绘制在顶层，子元素会继承父元素的一些属性，比如：opacity、transform。</p>\n<p><em><strong>注意：SVG 元素是无法通过 <code>z-index</code> 修改层级的</strong></em></p>\n<h3>SVG 的绘制过程</h3>\n<ol>\n<li>解析 SVG 文档</li>\n<li>列出绘制元素列表</li>\n<li>计算出每个绘制元素的 path 对应的直线长度</li>\n<li>根据动画时长和总长度，在每一帧依次画出指定长度的 path</li>\n<li>path 绘制完成后，绘制 SVG fill</li>\n</ol>\n<h3>SVG 的基本形状</h3>\n<p>svg 的命名空间：</p>\n<p>参考：https://www.jianshu.com/p/c590983dbc87</p>\n<p><code>&lt;svg xmlns=&quot;http://www.w3c.org/2000/svg&quot;&gt;&lt;/svg&gt;</code> 标记 xml 语言是 SVG，它只是一个字符串标识</p>\n<h4>SVG 元素的几个常用属性：</h4>\n<ol>\n<li>x/y 图形起始点的坐标</li>\n<li>width/height 图形的宽高</li>\n<li>fill: 图形的填充颜色（有的图形没有 <code>fill</code> 属性，例如 <code>&lt;line&gt;</code>）\n<code>fill</code> 属性的默认值为黑色 #000，将 <code>fill</code> 设置为 <code>none</code> 为透明</li>\n<li>stroke: 边框或线段的颜色\n<code>stroke</code> 的默认没有颜色</li>\n<li>stroke-width: 边框或线段的宽度\n<code>stroke-width</code> 默认为 <code>1</code></li>\n</ol>\n<h4>SVG 属性值可能是多种形式，值可以是一个数字集合，以 <code>空格</code> 或 <code>,</code> 分割：</h4>\n<p>例如 points 属性的写法：</p>\n<pre><code>points=&quot;10,20,30,40&quot; // 可以逗号分隔\npoints=&quot;10 20 30 40&quot; // 可以空格分隔\npoints=&quot;10,20 30,40&quot; // 建议用逗号分隔 x/y 的值，用空格分隔每个点\n</code></pre>\n<h4>rect 矩形</h4>\n<p>矩形就是长方形或者正方形，通过 <code>&lt;rect&gt;</code> 元素来绘制，包括圆角矩形</p>\n<p>属性：\nx: 矩形左上角的 x 坐标\ny: 矩形左上角的 y 坐标\nwidth: 矩形的宽度\nheight: 矩形的高度\nrx: 圆角效果时圆角沿 x 轴的半径\nry: 圆角效果时圆角沿 y 轴的半径\nfill: 填充的颜色\nstroke: 边框颜色\nstroke-width: 边框的宽度</p>\n<pre><code class=\"hljs\" lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span>\n  <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">\"10\"</span>\n  <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">\"10\"</span>\n  <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span>\n  <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"100\"</span>\n  <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"red\"</span>\n  <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">\"yellow\"</span>\n  <span class=\"hljs-attr\">stroke-width</span>=<span class=\"hljs-string\">\"4\"</span>\n&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">rect</span>&gt;</span>\n</code></pre>\n<p><img src=\"/static/svg-animation/img/rect.svg\" alt=\"rect\"></p>\n<h4>circle 圆形</h4>\n<p>圆形通过 <code>&lt;circle&gt;</code> 元素来绘制</p>\n<p>circle 具有 rect 的部分属性：\nfill: 填充的颜色\nstroke: 边框的颜色\nstroke-width: 边框的宽度</p>\n<p>自己特有的属性：\nr: 半径\ncx: 圆心在 x 轴上的坐标\ncy: 圆心在 y 轴上的坐标</p>\n<pre><code class=\"hljs\" lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span>\n  <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">\"50\"</span>\n  <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">\"50\"</span>\n  <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">\"40\"</span>\n  <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"#555\"</span>\n  <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">\"gray\"</span>\n  <span class=\"hljs-attr\">stroke-width</span>=<span class=\"hljs-string\">\"4\"</span>\n&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">circle</span>&gt;</span>\n</code></pre>\n<p><img src=\"/static/svg-animation/img/circle.svg\" alt=\"circle\"></p>\n<h4>ellipse 椭圆</h4>\n<p>椭圆与圆最大的区别是：圆拥有一个半径，椭圆有两个半径\n椭圆具有两个轴上的半径，x 轴的 <code>rx</code>，y 轴的 <code>ry</code></p>\n<p><img src=\"/static/svg-animation/img/ellipse.gif\" alt=\"椭圆\"></p>\n<p>属性：\ncx: 圆心在 x 轴的坐标\ncy: 圆心在 y 轴的坐标\nrx: 椭圆在 x 轴的半径\nry: 椭圆在 y 轴的半径\nfill: 填充的颜色\nstroke: 边框的颜色\nstroke-width: 边框的宽度</p>\n<pre><code class=\"hljs\" lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ellipse</span>\n  <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">\"100\"</span>\n  <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">\"60\"</span>\n  <span class=\"hljs-attr\">rx</span>=<span class=\"hljs-string\">\"80\"</span>\n  <span class=\"hljs-attr\">ry</span>=<span class=\"hljs-string\">\"50\"</span>\n  <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"pink\"</span>\n  <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">\"red\"</span>\n  <span class=\"hljs-attr\">stroke-width</span>=<span class=\"hljs-string\">\"5\"</span>\n&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ellipse</span>&gt;</span>\n</code></pre>\n<p><img src=\"/static/svg-animation/img/ellipse.svg\" alt=\"ellipse\"></p>\n<p><em><strong>当 rx 和 ry 相等时，绘制出的 <code>&lt;ellipse&gt;</code> 和 <code>&lt;circle&gt;</code> 是相等的</strong></em></p>\n<h4>polygon 多边形</h4>\n<p>多边形最重要的属性是顶点points，每个顶点都是由x、y坐标组成的，每个点之间相互连接，最后一个点再与第一个点连接起来形成一个图形。\npoints的值需要根据多边形来决定，例如三角形有三个顶点，所以points由三个值组成，依次写每个点的x、y坐标就可以，推荐每个点的坐标x、y用逗号隔开，每个定点之间用空格隔开：</p>\n<pre><code class=\"hljs\" lang=\"xml\"><span class=\"hljs-comment\">&lt;!-- 绘制一个五边形 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">polygon</span>\n  <span class=\"hljs-attr\">points</span>=<span class=\"hljs-string\">\"10,10 120,10 120,120 80,150 10,120\"</span>\n  <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"pink\"</span>\n  <span class=\"hljs-attr\">stroke-width</span>=<span class=\"hljs-string\">\"2\"</span>\n  <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">\"red\"</span>\n&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">polygon</span>&gt;</span>\n</code></pre>\n<p>fill: 填充的颜色\nstroke: 边框的颜色\nstroke-width: 边框的宽度\n<em>多边形最少由三个点组成</em></p>\n<p><img src=\"/static/svg-animation/img/polygon.svg\" alt=\"polygon\"></p>\n<h4>line 直线</h4>\n<p>绘制直线要使用 <code>&lt;line&gt;</code> 标签\n两个点可以确定一条直线，那么 line 的属性对应为：\nx1: 起点的 x 坐标\ny1: 起点的 y 坐标\nx2: 终点的 x 坐标\ny2: 终点的 y 坐标\nstroke: 直线的颜色\nstroke-width: 直线的宽度\n<em>直线是没有 fill 属性的</em></p>\n<pre><code class=\"hljs\" lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">line</span>\n  <span class=\"hljs-attr\">x1</span>=<span class=\"hljs-string\">\"10\"</span>\n  <span class=\"hljs-attr\">y1</span>=<span class=\"hljs-string\">\"50\"</span>\n  <span class=\"hljs-attr\">x2</span>=<span class=\"hljs-string\">\"200\"</span>\n  <span class=\"hljs-attr\">y2</span>=<span class=\"hljs-string\">\"50\"</span>\n  <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">\"#555\"</span>\n  <span class=\"hljs-attr\">stroke-width</span>=<span class=\"hljs-string\">\"3\"</span>\n&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">line</span>&gt;</span>\n</code></pre>\n<p><img src=\"/static/svg-animation/img/line.svg\" alt=\"line\"></p>\n<h4>polyline 折线</h4>\n<p>折线与多边形很类似，都是通过多个顶点points来绘制的，只不过最后一个点不会与第一个点连接起来，当然，使用折线也可以绘制出多边形。</p>\n<p>points: 起点、终点或折线转变方向的地方\nfill: 折线起点与终点连接起来的区域的填充颜色\nstroke: 折线的颜色\nstroke-width: 折线的宽度</p>\n<pre><code class=\"hljs\" lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">polyline</span>\n  <span class=\"hljs-attr\">points</span>=<span class=\"hljs-string\">\"30,30 30,70 70,70 70,120 120,50\"</span>\n  <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">\"red\"</span>\n  <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"none\"</span>\n&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">polyline</span>&gt;</span>\n</code></pre>\n<p><img src=\"/static/svg-animation/img/polyline.svg\" alt=\"polyline\"></p>\n<h4>path 路径</h4>\n<p>SVG中所有的图形都可以用path来绘制</p>\n<p>属性：</p>\n<p>stroke：路径的颜色</p>\n<p>stroke-width：路径的宽度</p>\n<p>stroke-dasharray：它是一个 <code>&lt;length&gt;</code> 和 <code>&lt;percentage&gt;</code> 数列，数与数之间用逗号或者空白隔开：<code>4 6 4 6</code>， 指定短划线和缺口的长度。如果提供了奇数个值，则这个值的数列重复一次，从而变成偶数个值。因此，<code>5,3,2</code> 等同于 <code>5,3,2,5,3,2</code></p>\n<p>stroke-dashoffset：标识 dash 的起始位置</p>\n<p><img src=\"/static/svg-animation/img/stroke-dasharray.png\" alt=\"stroke-dasharray\"></p>\n<p>d：路径命令的集合，包含多个指令：</p>\n<p><strong>其中参数大写代表绝对坐标，小写代表与前一个坐标的相对坐标</strong></p>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>M</td>\n<td>x y</td>\n<td>起始点的坐标x, y（Move to）</td>\n</tr>\n<tr>\n<td>L</td>\n<td>x y</td>\n<td>从当前点的坐标画直线到指定点的x，y坐标（Line to）</td>\n</tr>\n<tr>\n<td>H</td>\n<td>x</td>\n<td>从当前点的坐标画水平直线到指定的x轴坐标（Horizontal line to）</td>\n</tr>\n<tr>\n<td>V</td>\n<td>y</td>\n<td>从当前点的坐标画垂直直线到指定的y轴坐标（Vertical line to）</td>\n</tr>\n<tr>\n<td>C</td>\n<td>x1 y1 x2 y2 x y</td>\n<td>从当前点的坐标画贝塞尔曲线到指定点的x, y坐标，其中x1，y1及x2，y2为控制点（Curve）</td>\n</tr>\n<tr>\n<td>S</td>\n<td>x2 y2 x y</td>\n<td>从当前点的坐标画反射的贝塞尔曲线到指定点的x，y坐标，其中x2，y2为反射的控制点（Smooth curve）</td>\n</tr>\n<tr>\n<td>Q</td>\n<td>x1 y1 x y</td>\n<td>从当前点的坐标画反射二次贝塞尔曲线到指定点的x y坐标，其中x1 y1为控制点（Quadratic Bézier curve）</td>\n</tr>\n<tr>\n<td>T</td>\n<td>x y</td>\n<td>从当前点到坐标画反射二次贝塞尔曲线到指定点的x, y坐标，以前一个坐标为反射控制点（Smooth Quadratic Bézier curve）</td>\n</tr>\n<tr>\n<td>A</td>\n<td>rx ry x-axis-rotation large-arc-flag-sweep-flag x y</td>\n<td>从当前点的坐标画椭圆形到指定点的x，y坐标，其中rx，ry为椭圆形的x轴及y轴的半径，x-axis-rotation是弧线与x轴的旋转角度，large-arc-flag则设定1(最大角度的弧线)或0(最小角度的弧线)，sweep-flag设定方向为1(顺时针方向)或0(逆时针方向)（Arc）</td>\n</tr>\n<tr>\n<td>Z</td>\n<td></td>\n<td>关闭路径，将当前坐标与第一个点的坐标连接起来（Closepath）</td>\n</tr>\n</tbody>\n</table>\n<p>示例如下：</p>\n<pre><code class=\"hljs\" lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">path</span>\n  <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"none\"</span>\n  <span class=\"hljs-attr\">d</span>=<span class=\"hljs-string\">\"M2,82 L240,206 C254,214 272,209 279,195 L323,117\"</span>\n  <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">\"#D31E1E\"</span>\n  <span class=\"hljs-attr\">stroke-width</span>=<span class=\"hljs-string\">\"3\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">path</span>&gt;</span>\n</code></pre>\n<p><img src=\"/static/svg-animation/img/path.svg\" alt=\"path\"></p>\n<h3>其他标签</h3>\n<h4>g</h4>\n<p>g 标签表示分组，可以把任意图形划为一组：</p>\n<pre><code class=\"hljs\" lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">g</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"demo\"</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">\"green\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"white\"</span> <span class=\"hljs-attr\">stroke-width</span>=<span class=\"hljs-string\">\"5\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">\"25\"</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">\"25\"</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">\"15\"</span>/&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">\"40\"</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">\"25\"</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">\"15\"</span>/&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">\"55\"</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">\"25\"</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">\"15\"</span>/&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">\"70\"</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">\"25\"</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">\"15\"</span>/&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">g</span>&gt;</span>\n</code></pre>\n<p>分组里可以有标签的描述：<code>&lt;desc&gt;</code></p>\n<pre><code class=\"hljs\" lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">g</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"demo\"</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">\"green\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"white\"</span> <span class=\"hljs-attr\">stroke-width</span>=<span class=\"hljs-string\">\"5\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">desc</span>&gt;</span>Just Demo<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">desc</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">\"25\"</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">\"25\"</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">\"15\"</span>/&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">g</span>&gt;</span>\n</code></pre>\n<h4>use</h4>\n<p>use 标签可以复用 <code>&lt;g&gt;</code> 标签的分组</p>\n<p>将 <code>xlink:href</code> 属性的值设为 group 的 id，就可以引用 group 的图形：</p>\n<pre><code class=\"hljs\" lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">g</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"Port\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"fill: inherit;\"</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">\"10\"</span>/&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">g</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">use</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">\"30\"</span> <span class=\"hljs-attr\">xlink:href</span>=<span class=\"hljs-string\">\"#Port\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"classA\"</span>/&gt;</span>\n</code></pre>\n<p>use 标签不可覆盖 g 分组内图形的原有样式</p>\n<p>style &gt; 行内属性样式</p>\n<h4>defs</h4>\n<p>defs 可以保存代码，不被浏览器解析，可以被 use 引用，其中包含的分组可以被 use 标签的 style 属性覆盖掉样式：</p>\n<pre><code class=\"hljs\" lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">defs</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">g</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"Port\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"fill: inherit;\"</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">\"10\"</span>/&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">g</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">defs</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">use</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">xlink:href</span>=<span class=\"hljs-string\">\"#Port\"</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"fill: blue;\"</span>/&gt;</span>\n</code></pre>\n<h3>symbol</h3>\n<p>symbol 与 g 标签类似，也可以分组并定义一些模板且不被浏览器解析，使用 use 来使用模板：</p>\n<pre><code class=\"hljs\" lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">symbol</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"sym01\"</span> <span class=\"hljs-attr\">viewBox</span>=<span class=\"hljs-string\">\"0 0 150 110\"</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">\"40\"</span> <span class=\"hljs-attr\">stroke-width</span>=<span class=\"hljs-string\">\"8\"</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">\"red\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"red\"</span>/&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">\"90\"</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">\"60\"</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">\"40\"</span> <span class=\"hljs-attr\">stroke-width</span>=<span class=\"hljs-string\">\"8\"</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">\"green\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"white\"</span>/&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">symbol</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">use</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"#sym01\"</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">\"0\"</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">\"0\"</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span>/&gt;</span>\n</code></pre>\n<h2>SVG 动画</h2>\n<h3>animate</h3>\n<p>SVG 标签的 style 属性可以定义 SVG 的样式与动画效果，除此以外还可以使用 animate 标签</p>\n<p>属性：</p>\n<p>attributeName：需要被动画改变的属性名</p>\n<p>attributeType：定义了目标属性的命名空间 CSS | XML | auto</p>\n<p>form：动画发生时，被修改属性的初始值</p>\n<p>to：动画发生时，被修改属性的最终值</p>\n<p>begin：动画的开始时间</p>\n<p>dur：动画持续的时长</p>\n<p>repeatCount：动画重复的次数。indefinite：无限反复</p>\n<p>用 animate 元素定义 SVG 的动画效果：</p>\n<pre><code class=\"hljs\" lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"#2196F3\"</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">\"10\"</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"20\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"100\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">animate</span>\n    <span class=\"hljs-attr\">attributeName</span>=<span class=\"hljs-string\">\"width\"</span>\n    <span class=\"hljs-attr\">attributeType</span>=<span class=\"hljs-string\">\"XML\"</span>\n    <span class=\"hljs-attr\">to</span>=<span class=\"hljs-string\">\"300\"</span>\n    <span class=\"hljs-attr\">begin</span>=<span class=\"hljs-string\">\"0s\"</span>\n    <span class=\"hljs-attr\">dur</span>=<span class=\"hljs-string\">\"3s\"</span>\n    <span class=\"hljs-attr\">repeatCount</span>=<span class=\"hljs-string\">\"indefinite\"</span>\n  &gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">animate</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">animate</span>\n    <span class=\"hljs-attr\">attributeName</span>=<span class=\"hljs-string\">\"fill\"</span>\n    <span class=\"hljs-attr\">attributeType</span>=<span class=\"hljs-string\">\"XML\"</span>\n    <span class=\"hljs-attr\">to</span>=<span class=\"hljs-string\">\"#F44336\"</span>\n    <span class=\"hljs-attr\">begin</span>=<span class=\"hljs-string\">\"0s\"</span>\n    <span class=\"hljs-attr\">dur</span>=<span class=\"hljs-string\">\"3s\"</span>\n    <span class=\"hljs-attr\">repeatCount</span>=<span class=\"hljs-string\">\"indefinite\"</span>\n  &gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">animate</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">rect</span>&gt;</span>\n</code></pre>\n<p><img src=\"/static/svg-animation/img/animate.svg\" alt=\"animate\"></p>\n<h3>animationTransform</h3>\n<p>animationTransform 标签用来做变形动画</p>\n<p>属性：</p>\n<p>type：定义了动画 <code>transform</code> 的类型</p>\n<p>其他属性与 <code>&lt;animate&gt;</code> 一致</p>\n<pre><code class=\"hljs\" lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">polygon</span> <span class=\"hljs-attr\">points</span>=<span class=\"hljs-string\">\"30,30 100,30 100,100 30,100\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"#f44333\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">animateTransform</span>\n    <span class=\"hljs-attr\">attributeName</span>=<span class=\"hljs-string\">\"transform\"</span>\n    <span class=\"hljs-attr\">attributeType</span>=<span class=\"hljs-string\">\"XML\"</span>\n    <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"rotate\"</span>\n    <span class=\"hljs-attr\">from</span>=<span class=\"hljs-string\">\"0 60 70\"</span>\n    <span class=\"hljs-attr\">to</span>=<span class=\"hljs-string\">\"360 60 70\"</span>\n    <span class=\"hljs-attr\">dur</span>=<span class=\"hljs-string\">\"10s\"</span>\n    <span class=\"hljs-attr\">repeatCount</span>=<span class=\"hljs-string\">\"indefinite\"</span> /&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">polygon</span>&gt;</span>\n</code></pre>\n<p><img src=\"/static/svg-animation/img/animateTransform.svg\" alt=\"animateTransform\"></p>\n<h3>animate morph</h3>\n<p>animate morph 可以做图形内部的渐变</p>\n<h3>animateMotion</h3>\n<p>animateMotion 可以让图形按指定路径运动</p>\n<p>属性：</p>\n<p>from / to：指定运动两点的位置，以元素的坐标为原点</p>\n<p>dur：动画执行时长</p>\n<p>fill：指定动画结束后的元素的位置。freeze：停留在原地；remove：回到起始位置</p>\n<p>rotate：旋转角度。 auto：让物体垂直于路径的切线方向运动；auto-reverse：如 auto对称相反；Number：自定义旋转角度</p>\n<pre><code class=\"hljs\" lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">\"25\"</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">\"25\"</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">\"25\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"#2196F3\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">animateMotion</span> <span class=\"hljs-attr\">from</span>=<span class=\"hljs-string\">\"0,0\"</span> <span class=\"hljs-attr\">to</span>=<span class=\"hljs-string\">\"100,100\"</span> <span class=\"hljs-attr\">dur</span>=<span class=\"hljs-string\">\"1s\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"freeze\"</span> /&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">circle</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"#F44336\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">animateMotion</span> <span class=\"hljs-attr\">from</span>=<span class=\"hljs-string\">\"0,0\"</span> <span class=\"hljs-attr\">to</span>=<span class=\"hljs-string\">\"100,100\"</span> <span class=\"hljs-attr\">dur</span>=<span class=\"hljs-string\">\"1s\"</span> <span class=\"hljs-attr\">repeatCount</span>=<span class=\"hljs-string\">\"indefinite\"</span> /&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">rect</span>&gt;</span>\n</code></pre>\n<p><img src=\"/static/svg-animation/img/animateMotion1.svg\" alt=\"animateMotion1\"> <img src=\"/static/svg-animation/img/animateMotion2.svg\" alt=\"animateMotion2\"></p>\n<p>复杂的路径可以使用 <code>path</code> 属性：</p>\n<pre><code class=\"hljs\" lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"#F44336\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">animateMotion</span>\n    <span class=\"hljs-attr\">path</span>=<span class=\"hljs-string\">\"M3,52.98c47.18-38,36.11-50.25,18.3-43.49S7.33,36.93,38.15,52.98S53.56,18.35,83.89,4.42\n\ts65.96,53.2,64.04,56.58\"</span>\n    <span class=\"hljs-attr\">dur</span>=<span class=\"hljs-string\">\"3s\"</span>\n    <span class=\"hljs-attr\">repeatCount</span>=<span class=\"hljs-string\">\"indefinite\"</span> /&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">rect</span>&gt;</span>\n</code></pre>\n<p><img src=\"/static/svg-animation/img/animateMotion3.svg\" alt=\"animateMotion3\"></p>\n<p>也可以使用 <code>&lt;mpath&gt;</code> 标签来引用 <code>&lt;path&gt;</code> 的路径：</p>\n<pre><code class=\"hljs\" lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">path</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"path\"</span>\n  <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"none\"</span>\n  <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">\"red\"</span>\n  <span class=\"hljs-attr\">d</span>=<span class=\"hljs-string\">\"M3,95.26C69.71,25.41,54.05,2.91,28.87,15.32S9.13,65.77,52.69,95.26s21.78-63.64,64.67-89.25 s93.26,97.78,90.53,103.99\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">path</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">\"5\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"#2196F3\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">animateMotion</span> <span class=\"hljs-attr\">rotate</span>=<span class=\"hljs-string\">\"auto-reverse\"</span> <span class=\"hljs-attr\">dur</span>=<span class=\"hljs-string\">\"5s\"</span> <span class=\"hljs-attr\">repeatCount</span>=<span class=\"hljs-string\">\"indefinite\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">mpath</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"#path\"</span>/&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">animateMotion</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">circle</span>&gt;</span>\n</code></pre>\n<p><img src=\"/static/svg-animation/img/animateMotion4.svg\" alt=\"animateMotion4\"></p>\n<p>修改 rotate 属性：</p>\n<p><code>auto-reverse</code></p>\n<pre><code class=\"hljs\" lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">path</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"path\"</span>\n  <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"none\"</span>\n  <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">\"red\"</span>\n  <span class=\"hljs-attr\">d</span>=<span class=\"hljs-string\">\"M3,95.26C69.71,25.41,54.05,2.91,28.87,15.32S9.13,65.77,52.69,95.26s21.78-63.64,64.67-89.25 s93.26,97.78,90.53,103.99\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">path</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"10\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"10\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"#2196F3\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">animateMotion</span> <span class=\"hljs-attr\">rotate</span>=<span class=\"hljs-string\">\"auto-reverse\"</span> <span class=\"hljs-attr\">dur</span>=<span class=\"hljs-string\">\"5s\"</span> <span class=\"hljs-attr\">repeatCount</span>=<span class=\"hljs-string\">\"indefinite\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">mpath</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"#path\"</span>/&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">animateMotion</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">rect</span>&gt;</span>\n</code></pre>\n<p><img src=\"/static/svg-animation/img/animateMotion5.svg\" alt=\"animateMotion5\"></p>\n<p><code>auto</code></p>\n<pre><code class=\"hljs\" lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">path</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"path\"</span>\n  <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"none\"</span>\n  <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">\"red\"</span>\n  <span class=\"hljs-attr\">d</span>=<span class=\"hljs-string\">\"M3,95.26C69.71,25.41,54.05,2.91,28.87,15.32S9.13,65.77,52.69,95.26s21.78-63.64,64.67-89.25 s93.26,97.78,90.53,103.99\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">path</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"10\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"10\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"#2196F3\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">animateMotion</span> <span class=\"hljs-attr\">rotate</span>=<span class=\"hljs-string\">\"auto\"</span> <span class=\"hljs-attr\">dur</span>=<span class=\"hljs-string\">\"5s\"</span> <span class=\"hljs-attr\">repeatCount</span>=<span class=\"hljs-string\">\"indefinite\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">mpath</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"#path\"</span>/&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">animateMotion</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">rect</span>&gt;</span>\n</code></pre>\n<p><img src=\"/static/svg-animation/img/animateMotion6.svg\" alt=\"animateMotion6\"></p>\n<h3>线条动画</h3>\n<p>利用 path 的  <code>stroke-dasharray</code> 和 <code>stroke-dashoffset</code> 来实现线条运动。</p>\n<p>因为 dasharray 可以定义实线长度与间隙长度，并且 dashoffset 可以'移动'线段，所以可以通过改变这些属性的数值来实现动画效果</p>\n<table>\n<thead>\n<tr>\n<th>方式</th>\n<th>起始值</th>\n<th>终止值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>stroke-dasharray: 0 max;</td>\n<td>stroke-dasharray: max 0;</td>\n</tr>\n<tr>\n<td>2</td>\n<td>stroke-dasharray: 0 max;</td>\n<td>stroke-dasharray: max max;</td>\n</tr>\n<tr>\n<td>3</td>\n<td>stroke-dashoffset: 0;<br/>stroke-dasharray: max max;</td>\n<td>stroke-dashoffset: max;<br/>stroke-dasharray: max max;</td>\n</tr>\n</tbody>\n</table>\n<p><em>(max为path总长度)</em></p>\n<p>还有一个问题，就是我们如何知道 path 图形的 stroke 有多长呢？</p>\n<p>噔噔！很简单，使用 path 元素的 <code>getTotalLength</code> 方法即可：</p>\n<pre><code class=\"hljs\" lang=\"js\"><span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'path'</span>).getTotalLength()\n</code></pre>\n<p>接下来我们做一条会动的线，首先，我们定义一条路径：</p>\n<pre><code class=\"hljs\" lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://www.w3.org/2000/svg\"</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"400\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"250\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">path</span>\n    <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"move\"</span>\n    <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"path\"</span>\n    <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"path\"</span>\n    <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"none\"</span>\n    <span class=\"hljs-attr\">d</span>=<span class=\"hljs-string\">\"M9,183.36C133.52,69,104.3,32.15,57.28,52.48s-36.85,82.59,44.47,130.87S142.42,79.17,222.46,37.24\ns174.08,160.1,168.99,170.26\"</span>\n    <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">\"red\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">path</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span>\n</code></pre>\n<p>然后定义动画样式：</p>\n<pre><code class=\"hljs\" lang=\"css\"><span class=\"hljs-selector-class\">.move</span> {\n  <span class=\"hljs-attribute\">animation</span>: move <span class=\"hljs-number\">3s</span> linear infinite;\n}\n@<span class=\"hljs-keyword\">keyframes</span> move {\n  <span class=\"hljs-selector-tag\">from</span> {\n    <span class=\"hljs-attribute\">stroke-dasharray</span>: <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">857.92</span>;\n  }\n  <span class=\"hljs-selector-tag\">to</span> {\n    <span class=\"hljs-attribute\">stroke-dasharray</span>: <span class=\"hljs-number\">857.92</span> <span class=\"hljs-number\">0</span>;\n  }\n}\n</code></pre>\n<p>这样就可以简单实现一个线条动画啦：<a href=\"/static/svg-animation/dome/demo.html\">查看效果</a></p>\n<p>来看下详细的实现：</p>\n<p><a href=\"https://codesandbox.io/s/10x1m122o4\">https://codesandbox.io/s/10x1m122o4</a>(外网)</p>\n<iframe src=\"https://codesandbox.io/embed/ym78qx2vzv?module=%2Fsrc%2Fcomponents%2Fpath-attributes.vue\" style=\"width:100%; height:700px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n`,\n    wordCount: 12202\n  }\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/docs/SVG Animation.mdjs\n// module id = Jz86\n// module chunks = 0 1","module.exports = {\n    info: {\n    title: 'MacOS 环境安装 MongoDB',\n    poster: '',\n    date: '2018-07-06',\n    id: '2018-07-06',\n    desc: '在 MacOS 环境中安装 MongoDB'\n},\n    content: `<h2>Install MongoDB in Mac</h2>\n<ol>\n<li>\n<p>使用 <a href=\"https://brew.sh/\">brew</a> 安装</p>\n<blockquote>\n<p>brew 是 MacOS 上的一个包管理器</p>\n</blockquote>\n<p>安装 mongodb：</p>\n<pre><code class=\"hljs\" lang=\"bash\"><span class=\"hljs-comment\"># sudo 命令可以获得系统权限，输入账户密码即可执行</span>\nsudo brew install mongodb\n</code></pre>\n<p>查看 brew 是否已安装：</p>\n<pre><code class=\"hljs\" lang=\"bash\">brew list\n</code></pre>\n<p>若之前已安装过 MongoDB，可以使用命令来升级：</p>\n<pre><code class=\"hljs\" lang=\"bash\">brew upgrade mongodb\n</code></pre>\n</li>\n<li>\n<p>手动安装</p>\n<p>在 MongoDB <a href=\"https://www.mongodb.com/download-center#community\">官网下载</a> <code>mongodb-osx-ssl-x86_64-4.0.0.tgz</code> 文件（具体版本请以当前发行版本为主），放入 <code>/usr/local</code> 目录中</p>\n<p>进入\b <code>/usr/local</code> 目录：</p>\n<pre><code class=\"hljs\" lang=\"bash\"><span class=\"hljs-built_in\">cd</span> /usr/<span class=\"hljs-built_in\">local</span>\n</code></pre>\n<p>解压文件：</p>\n<pre><code class=\"hljs\" lang=\"bash\">sudo tar -zxvf mongodb-osx-ssl-x86_64-4.0.0.tgz\n</code></pre>\n<p>重命名文件夹</p>\n<pre><code class=\"hljs\" lang=\"bash\">sudo mv mongodb-osx-ssl-x86_64-4.0.0 mongodb\n</code></pre>\n</li>\n</ol>\n<h2>Run MongoDB</h2>\n<p>为 MongoDB 添加配置</p>\n<p>运行前，首先需要一个 <code>数据库储存</code> 目录。当启动 MongoDB 时，默认数据库目录为 <code>/data/db</code>，所以我们直接在根目录下创建即可：</p>\n<pre><code class=\"hljs\" lang=\"bash\"><span class=\"hljs-built_in\">cd</span> /\n\n<span class=\"hljs-comment\"># 使用 sudo 命令创建</span>\nsudo mkdir -p /data/db\n</code></pre>\n<blockquote>\n<p>也可以在启动 mongod 的时候，通过 <code>--dbpath</code> 指定 <code>data/db</code> 目录： <code>mongod --dbpath ./my-data</code></p>\n</blockquote>\n<hr>\n<p>接下来就可以启动 MongoDB 了：</p>\n<p>在没有设置全局路径时，需要进入 <code>mongodb/bin</code> 目录下启动：</p>\n<pre><code class=\"hljs\" lang=\"bash\"><span class=\"hljs-comment\"># 进入 mongodb 目录</span>\n<span class=\"hljs-built_in\">cd</span> /usr/<span class=\"hljs-built_in\">local</span>/mongodb/bin\n\n<span class=\"hljs-comment\"># 启动 mongod</span>\n./mongod\n</code></pre>\n<pre><code class=\"hljs\" lang=\"bash\"><span class=\"hljs-comment\"># 新打开一个终端窗口并进入 /usr/local/mongodb/bin，启动 mongo</span>\n<span class=\"hljs-built_in\">cd</span> /usr/<span class=\"hljs-built_in\">local</span>/mongodb/bin\n\n./mongo\n</code></pre>\n<p>关闭服务：</p>\n<pre><code class=\"hljs\" lang=\"bash\">&gt; db.shutdownServer()\n&gt; <span class=\"hljs-built_in\">exit</span>\n</code></pre>\n`,\n    wordCount: 1240\n  }\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/docs/MacOS 环境安装 MongoDB.mdjs\n// module id = PU9U\n// module chunks = 0 1","module.exports = {\n    info: {\n  title: 'ts',\n  poster: '',\n  date: '2018-08-30',\n  id: '2018-08-30',\n  desc: 'TypeScript 是 JavaScript 的超集，她为 JavaScript 提供了类型注解、静态类型检查的功能，以及一些新的特性，TypeScript 可以编译成 JavaScript 代码，在不同平台上运行'\n},\n    content: `<blockquote>\n<p>TypeScript 是 JavaScript 的超集，她为 JavaScript 提供了类型注解、静态类型检查的功能，以及一些新的特性，TypeScript 可以编译成 JavaScript 代码，在不同平台上运行</p>\n</blockquote>\n<h2>TypeScript 基本类型的定义：</h2>\n<p>\b### 数字、字符串、布尔值</p>\n<pre><code class=\"hljs\" lang=\"ts\"><span class=\"hljs-keyword\">let</span> age: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">18</span>\n<span class=\"hljs-keyword\">let</span> name: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">'tom'</span>\n<span class=\"hljs-keyword\">let</span> show: <span class=\"hljs-built_in\">boolean</span> = <span class=\"hljs-literal\">false</span>\n</code></pre>\n<h3>数组 一种特殊的元祖</h3>\n<pre><code class=\"hljs\" lang=\"ts\"><span class=\"hljs-keyword\">let</span> list: <span class=\"hljs-built_in\">number</span>[] = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>]\n<span class=\"hljs-keyword\">let</span> list <span class=\"hljs-built_in\">Array</span>&lt;<span class=\"hljs-built_in\">number</span>&gt; = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>]\n</code></pre>\n<h3>元组</h3>\n<pre><code class=\"hljs\" lang=\"ts\"><span class=\"hljs-keyword\">let</span> list: [<span class=\"hljs-built_in\">string</span>, <span class=\"hljs-built_in\">number</span>]\nlist = [<span class=\"hljs-string\">'tom'</span>, <span class=\"hljs-number\">18</span>]\n</code></pre>\n<p>当越界访问\b或创建元素时，以联合类型为标准：</p>\n<pre><code class=\"hljs\" lang=\"ts\">list 的联合类型为(<span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span>)\nlist[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">123</span> <span class=\"hljs-comment\">// 123</span>\nlist[<span class=\"hljs-number\">3</span>] = <span class=\"hljs-literal\">true</span> <span class=\"hljs-comment\">// Error! 不能将 true 分配给 (string | number) 类型</span>\n</code></pre>\n<h3>枚举</h3>\n<pre><code class=\"hljs\" lang=\"ts\"><span class=\"hljs-keyword\">enum</span> Animal {dog, cat, pig = <span class=\"hljs-number\">100</span>}\n<span class=\"hljs-keyword\">let</span> dog: Animal = Animal.dog\n<span class=\"hljs-keyword\">let</span> cat: Animal = Animal.cat\n<span class=\"hljs-keyword\">let</span> pig: Animal = Animal.pig\n<span class=\"hljs-keyword\">let</span> petName: <span class=\"hljs-built_in\">string</span> = Animal[<span class=\"hljs-number\">1</span>] <span class=\"hljs-comment\">// 通过值获取 key</span>\ndog <span class=\"hljs-comment\">// 0</span>\ncat <span class=\"hljs-comment\">// 1</span>\npig <span class=\"hljs-comment\">// 100</span>\npetName <span class=\"hljs-comment\">// cat</span>\n</code></pre>\n<h3>Any</h3>\n<p>给不确定的类型定义 any 时，ts 将不进行类型检查：</p>\n<pre><code class=\"hljs\" lang=\"ts\"><span class=\"hljs-keyword\">let</span> someValue: <span class=\"hljs-built_in\">any</span> = <span class=\"hljs-number\">18</span>\nsomeValue = <span class=\"hljs-string\">'tom'</span>\nsomeValue = <span class=\"hljs-literal\">false</span>\n</code></pre>\n<h3>Void</h3>\n<p>void 类型表示没有任何类型，当函数没有返回值时则是 void 类型</p>\n<pre><code class=\"hljs\" lang=\"ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span> (<span class=\"hljs-params\"></span>): <span class=\"hljs-title\">void</span> </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'no return'</span>)\n}\n</code></pre>\n<p>void 类型只能赋值为 undefiend 和 null</p>\n<h3>Null、Undefined</h3>\n<p>null 和 undefined 拥有各自的类型，并且他们也是所有类型的子类型，所以可以赋值给其他类型的变量：</p>\n<pre><code class=\"hljs\" lang=\"ts\"><span class=\"hljs-keyword\">let</span> a: <span class=\"hljs-literal\">undefined</span> = <span class=\"hljs-literal\">undefined</span>\na = <span class=\"hljs-literal\">null</span>\n<span class=\"hljs-keyword\">let</span> b: <span class=\"hljs-literal\">null</span> = <span class=\"hljs-literal\">undefined</span>\nb = <span class=\"hljs-literal\">undefined</span>\n<span class=\"hljs-keyword\">let</span> n: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">123</span>\nn = <span class=\"hljs-literal\">undefined</span> <span class=\"hljs-comment\">// 将 undefined 赋值给 number 类型</span>\n</code></pre>\n<p>使用 --strictNullChecks 模式，undefined 只能\b赋值给 undefined 和 void 类型；null 只能赋值给 null 类型</p>\n<h3>Never</h3>\n<p>never 类型表示不会有值存在的类型，例如永远没有返回值的函数，</p>\n<pre><code class=\"hljs\" lang=\"ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span> (<span class=\"hljs-params\"></span>): <span class=\"hljs-title\">never</span> </span>{\n  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>()\n}\n<span class=\"hljs-keyword\">var</span> a: never = (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">'ads'</span>)\n})()\n</code></pre>\n<h3>类型断言</h3>\n<p>当你确切知道值的类型，可以使用类型断言来手动指定类型，告诉 ts 应该按你说的做\n类型断言有两种方式，可以根据你的喜好来书写，但是在 jsx 中只有 as 的方式可以使用：</p>\n<ol>\n<li>&lt;类型&gt;值</li>\n<li>值 as 类型</li>\n</ol>\n<pre><code class=\"hljs\" lang=\"ts\"><span class=\"hljs-keyword\">let</span> value: (<span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span>) = <span class=\"hljs-string\">'My name is Tom'</span>\n<span class=\"hljs-keyword\">let</span> isLongString: <span class=\"hljs-built_in\">boolean</span> = (value <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">string</span>).length &gt; <span class=\"hljs-number\">10</span>\n<span class=\"hljs-keyword\">let</span> hi: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">'hello! '</span> + &lt;<span class=\"hljs-built_in\">string</span>&gt;value\n</code></pre>\n<p>对引用类型做类型检查</p>\n`,\n    wordCount: 1761\n  }\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/docs/ts.md\n// module id = c3ki\n// module chunks = 0 1","const context = require.context('@/docs', true, /\\.mdjs$/)\n\nexport const fileList = context.keys()\n\nexport const articleList = fileList.map(path => {\n  const mdjs = require('@/docs/' + path.slice(2))\n  return {\n    ...mdjs.info,\n    content: mdjs.content,\n    wordCount: mdjs.wordCount,\n  }\n}).sort((a, b) => +new Date(b.date) - +new Date(a.date))\n\n\n\n// WEBPACK FOOTER //\n// ./src/service/mock.js","module.exports = {\n    info: {\n  title: '浅析 AMD CMD UMD CommonJS 模块规范',\n  poster: '',\n  date: '2018-07-17',\n  id: '2018-07-17',\n  desc: 'js 中有各种模块规范，例如 AMD CMD UMD CommonJS 等，他们是怎样规定的呢？一起来看一看'\n},\n    content: `<p>在传统的 html 网页中，js 代码都是通过 script 标签加载到页面上来的，不同功能的代码混合在一起时，很多问题就会暴露出来：</p>\n<ol>\n<li>全局变量造成命名空间污染</li>\n<li>代码不易复用，无法拆分</li>\n<li>\bjs 引入顺序问题</li>\n<li>维护困难</li>\n</ol>\n<h2>AMD（Asynchronous Module Definition）</h2>\n<p>RequireJS 是为 js 实现 AMD 模块规范第三方库</p>\n<p>AMD 采用异步的方式加载模块，将所有依赖前置，依赖这些模块的代码都放在一个回调函数中，等所有模块加载完成后才会执行这个回调函数，很适合在浏览器端处理异步获取的模块</p>\n<h3>加载 RequireJS：</h3>\n<pre><code class=\"hljs\" lang=\"html\">/* index.html */\n\n<span class=\"hljs-meta\">&lt;!DOCTYPE html&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">\"en\"</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"UTF-8\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>AMD<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n  name: <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"name\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n\n  <span class=\"hljs-comment\">&lt;!-- 引入 require.js 与 main.js --&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"require.js\"</span> <span class=\"hljs-attr\">data-main</span>=<span class=\"hljs-string\">\"main\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n<h3>定义模块：</h3>\n<pre><code class=\"hljs\" lang=\"js\"><span class=\"hljs-comment\">/* 模块 module.js */</span>\n\n<span class=\"hljs-comment\">// 依赖数组 与 回调函数</span>\ndefine([<span class=\"hljs-string\">'lodash'</span>, <span class=\"hljs-string\">'jquery'</span>], <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">_, $</span>) </span>{\n\n  <span class=\"hljs-comment\">// 局部变量</span>\n  <span class=\"hljs-keyword\">var</span> names = [<span class=\"hljs-string\">'tom'</span>, <span class=\"hljs-string\">'jerry'</span>, <span class=\"hljs-string\">'oliver'</span>]\n  $(<span class=\"hljs-string\">'.name'</span>).html(_.last(names))\n\n  <span class=\"hljs-comment\">// 导出</span>\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">names</span>: names\n  }\n})\n</code></pre>\n<p>define 函数的第一个参数是一个数组，所有的依赖项都放在其中；第二个\b参数是回调函数，回调函数的参数就是依赖模块导出的值。</p>\n<h3>引入模块</h3>\n<pre><code class=\"hljs\" lang=\"js\"><span class=\"hljs-comment\">/* 主入口 main.js */</span>\n\n<span class=\"hljs-built_in\">require</span>([<span class=\"hljs-string\">'module.js'</span>], <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">m</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(m.names)  <span class=\"hljs-comment\">// ['tom', 'jerry', 'oliver']</span>\n})\n</code></pre>\n<p>要引入其他模块时，同样将\u001b依赖数组传给 require 函数；第二个\b参数是回调函数，回调函数的参数就是依赖模块导出的值。</p>\n<h2>CMD（Common Module Definition）</h2>\n<p><a href=\"https://www.zhangxinxu.com/sp/seajs/#intro\">SeaJS</a> 是 <a href=\"https://github.com/seajs/seajs/issues/242\">CMD</a> 规范的代表框架，它以懒加载的方式去加载模块，推崇依赖就近</p>\n<h3>引入与导出模块</h3>\n<pre><code class=\"hljs\" lang=\"js\"><span class=\"hljs-comment\">/*  utils.js */</span>\n\ndefine(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">require, exports, module</span>) </span>{\n  <span class=\"hljs-comment\">// ...</span>\n\n  <span class=\"hljs-comment\">// 使用 require 引入模块</span>\n  <span class=\"hljs-keyword\">if</span> (flag) {\n    <span class=\"hljs-comment\">// 只有条件成立才会引入</span>\n    <span class=\"hljs-keyword\">const</span> h = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'hello'</span>)\n    <span class=\"hljs-comment\">// ...</span>\n  }\n\n  <span class=\"hljs-comment\">// 在 exports 上暴露一个方法</span>\n  exports.add = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a, b</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> a + b\n  }\n})\n</code></pre>\n<pre><code class=\"hljs\" lang=\"js\"><span class=\"hljs-comment\">/*  main.js */</span>\n\ndefine(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">require, exports, module</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> utils = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'utils'</span>)\n  <span class=\"hljs-built_in\">console</span>.log(utils.add(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>))  <span class=\"hljs-comment\">// 3</span>\n})\n</code></pre>\n<h2>UMD（Universal Module Definition）</h2>\n<p>由于 AMD 与 CommonJS 规范的差异，导致模块引用方式出现浏览器端与 node 端的分化，UMD 正是对 AMD 与 CommonJS 两种规范的兼容，它会判断当前环境是否支持某一规范，然后运用此规范去加载\b模块，如果不支持任何模式，将会\u001b挂在到全局</p>\n<pre><code class=\"hljs\" lang=\"js\">(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">factory</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> define === <span class=\"hljs-string\">'function'</span> &amp;&amp; define.amd) {\n    <span class=\"hljs-comment\">// AMD. Register as an anonymous module.</span>\n    define([<span class=\"hljs-string\">'jquery'</span>], factory)\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">module</span> === <span class=\"hljs-string\">'object'</span> &amp;&amp; <span class=\"hljs-built_in\">module</span>.exports) {\n    <span class=\"hljs-comment\">// Node/CommonJS</span>\n    <span class=\"hljs-built_in\">module</span>.exports = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">root, jQuery</span>) </span>{\n      <span class=\"hljs-keyword\">if</span> (jQuery === <span class=\"hljs-literal\">undefined</span>) {\n        <span class=\"hljs-comment\">// require('jQuery') returns a factory that requires window to</span>\n        <span class=\"hljs-comment\">// build a jQuery instance, we normalize how we use modules</span>\n        <span class=\"hljs-comment\">// that require this pattern but the window provided is a noop</span>\n        <span class=\"hljs-comment\">// if it's defined (how jquery works)</span>\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">window</span> !== <span class=\"hljs-string\">'undefined'</span>) {\n          jQuery = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'jquery'</span>)\n        } <span class=\"hljs-keyword\">else</span> {\n          jQuery = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'jquery'</span>)(root)\n        }\n      }\n      factory(jQuery)\n      <span class=\"hljs-keyword\">return</span> jQuery\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// Browser globals</span>\n    factory(jQuery)\n  }\n}(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">$</span>) </span>{\n  $.fn.jqueryPlugin = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n  }\n}))\n</code></pre>\n<h2>CommonJS</h2>\n<p>CommonJS 是 NodeJS 采用的模块规范</p>\n<p>每一个文件被视为一个模块，每一个模块拥有独立的作用域，模块的内部变量、函数、类无法被其他模块访问。</p>\n<h3>导出模块</h3>\n<p>在模块内部 module.exports 上指定额外的属性，会被添加到模块的根部，可作为导出的内容：</p>\n<pre><code class=\"hljs\" lang=\"js\"><span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-number\">1</span>\n<span class=\"hljs-keyword\">const</span> b = <span class=\"hljs-number\">2</span> <span class=\"hljs-comment\">// b 未导出，只作为局部变量</span>\n\n<span class=\"hljs-comment\">// a 被导出</span>\n<span class=\"hljs-built_in\">module</span>.exports.a = a\n</code></pre>\n<pre><code class=\"hljs\" lang=\"js\"><span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-number\">1</span>\n<span class=\"hljs-keyword\">const</span> b = <span class=\"hljs-number\">2</span> <span class=\"hljs-comment\">// b 未导出，只作为局部变量</span>\n\n<span class=\"hljs-comment\">// a 被导出</span>\n<span class=\"hljs-built_in\">module</span>.exports = {\n  <span class=\"hljs-attr\">a</span>: a\n}\n</code></pre>\n<p>模块内部的 exports 变量指向了 module.exports，可以方便的作为模块的出口：</p>\n<pre><code class=\"hljs\" lang=\"js\">exports.a = <span class=\"hljs-number\">1</span>\n</code></pre>\n<pre><code class=\"hljs\" lang=\"js\">exports = {\n  <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>\n}\n</code></pre>\n<p><strong>区分 exports 与 module.exports：</strong></p>\n<p>因为 exports 只是单纯作为 module.exports 的引用，所以当 module.exports 被赋值后，exports 原来指向的内容将无法导出：</p>\n<pre><code class=\"hljs\" lang=\"js\">exports.a = <span class=\"hljs-number\">1</span>\n\n<span class=\"hljs-built_in\">module</span>.exports = {\n  <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">2</span>\n}\n\n<span class=\"hljs-comment\">// 只有 b 被导出</span>\n</code></pre>\n<h3>\b引入模块</h3>\n<p>CommonJS 加载模块的方式是同步的，通过 require 引入外部模块：</p>\n<pre><code class=\"hljs\" lang=\"js\"><span class=\"hljs-keyword\">const</span> myModule = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'myModule'</span>)\n\nmyModule.foo({\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./data'</span>)\n})\n</code></pre>\n<p>如果模块名与核心模块一致时，NodeJS 会优先加载核心模块，如：http, fs：</p>\n<pre><code class=\"hljs\" lang=\"js\"><span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'fs'</span>)\n\nfs.unlink(<span class=\"hljs-string\">'/tmp/hello'</span>, (err) =&gt; {\n  <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">throw</span> err\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'成功删除 /tmp/hello'</span>)\n})\n</code></pre>\n<p>由于模块加载是同步的，所以异步导出的模块是获取不到的：</p>\n<pre><code class=\"hljs\" lang=\"js\">setTimeOut(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n  exports.a = <span class=\"hljs-number\">1</span>\n}, <span class=\"hljs-number\">1000</span>)\n\n<span class=\"hljs-comment\">// 在其他模块引入时是 {}</span>\n</code></pre>\n<p>require 是每个模块的内置对象</p>\n<ul>\n<li>require.main 是当前文件的 module</li>\n<li>require.main.filename 是 NodeJS 程序的入口（文件路径）</li>\n</ul>\n`,\n    wordCount: 3892\n  }\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/docs/浅析 AMD CMD UMD CommonJS 模块规范.mdjs\n// module id = h4K6\n// module chunks = 0 1","<template>\n  <div class=\"detail__wrap\">\n    <h1 class=\"title text--c w-b--word\">{{detail.title}}</h1>\n    <!-- <p class=\"desc\">{desc}</p> -->\n    <div v-html=\"'<h1>Loading...</h1>'\" ref=\"contentContainer\" class=\"content md\" />\n    <div class=\"date m-t--50\">{{detail.date}}</div>\n  </div>\n</template>\n\n<script>\nimport { articleList } from \"@/service/mock.js\"\nimport types from '@/store/mutations'\n\nexport default {\n  name: 'ArticleDetail',\n  props: {\n    id: {\n      type: String,\n      required: true\n    }\n  },\n  data() {\n    return {\n      detail: {\n        title: \"\",\n        desc: \"\",\n        poster: \"\",\n        content: \"\",\n        date: \"\",\n        id: null\n      }\n    }\n  },\n  methods: {\n    toggleSideBar(isShow) {\n      this.$store.commit(types.SWITCH_SIDE_NAV, isShow)\n    },\n  },\n  mounted() {\n    const id = this.id\n    this.mock(articleList.find(v => v.id === id))\n      .then(res => {\n        Object.assign(this.detail, res)\n\n        const contentHtml = this.detail.content\n        const containerEle = this.$refs.contentContainer\n        if (contentHtml && containerEle) {\n          containerEle.innerHTML = contentHtml || ''\n\n          this.$emit('content-render', containerEle)\n          this.toggleSideBar(true)\n        }\n      })\n  },\n  beforeDestroy() {\n    this.toggleSideBar(false)\n  },\n}\n</script>\n\n<style src=\"@/style/markdown.css\"></style>\n<style src=\"@/style/hljs.css\"></style>\n<style scoped lang=\"stylus\">\n@import '../../style/mix.styl'\n.detail__wrap\n  min-height 200px\n  padding 20px 40px\n  border-radius 6px\n  background #fff\n.title\n  padding 50px 0 100px\n  font-size $font-title + 5px\n  color $font-color-title\n.desc\n  padding 10px 0\n  font-size $font-content + 2px\n.content\n  font-size $font-content\n.date\n  padding 20px 0\n.md >>> ul\n  list-style disc\n.md >>> ol\n  list-style decimal\n\n\n@media screen and (max-width 640px)\n  .detail__wrap\n    padding 20px\n    border-radius 0\n</style>\n\n\n\n// WEBPACK FOOTER //\n// src/views/Article/ArticleDetail.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"detail__wrap\"},[_c('h1',{staticClass:\"title text--c w-b--word\"},[_vm._v(_vm._s(_vm.detail.title))]),_vm._v(\" \"),_c('div',{ref:\"contentContainer\",staticClass:\"content md\",domProps:{\"innerHTML\":_vm._s('<h1>Loading...</h1>')}}),_vm._v(\" \"),_c('div',{staticClass:\"date m-t--50\"},[_vm._v(_vm._s(_vm.detail.date))])])}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-f98fd170\",\"hasScoped\":true,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/views/Article/ArticleDetail.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-f98fd170\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!@/style/markdown.css\")\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-f98fd170\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!@/style/hljs.css\")\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-f98fd170\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!stylus-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/selector?type=styles&index=2!./ArticleDetail.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./ArticleDetail.vue\"\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./ArticleDetail.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-f98fd170\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./ArticleDetail.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-f98fd170\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/views/Article/ArticleDetail.vue\n// module id = null\n// module chunks = ","var map = {\n\t\"./MacOS 环境安装 MongoDB.mdjs\": \"PU9U\",\n\t\"./SVG Animation.mdjs\": \"Jz86\",\n\t\"./chrome extension.mdjs\": \"7K+T\",\n\t\"./linux学习笔记.mdjs\": \"4oDU\",\n\t\"./ts.md\": \"c3ki\",\n\t\"./对 javascript 执行环境的探索.mdjs\": \"7afm\",\n\t\"./浅析 AMD CMD UMD CommonJS 模块规范.mdjs\": \"h4K6\",\n\t\"./浏览器原理.mdjs\": \"I4L2\",\n\t\"./解析 npm-package.json.mdjs\": \"4MyP\",\n\t\"./随想.md\": \"+JY3\"\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\tvar id = map[req];\n\tif(!(id + 1)) // check for number or string\n\t\tthrow new Error(\"Cannot find module '\" + req + \"'.\");\n\treturn id;\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"xf8P\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/docs ^\\.\\/.*$\n// module id = xf8P\n// module chunks = 0 1"],"sourceRoot":""}