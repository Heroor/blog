webpackJsonp([0],{"/HJh":function(s,n,a){var l={"./MacOS 环境安装 MongoDB.mdjs":"PU9U","./SVG Animation.mdjs":"Jz86","./chrome extension.mdjs":"7K+T","./linux学习笔记.mdjs":"4oDU","./对 javascript 执行环境的探索.mdjs":"7afm","./浅析 AMD CMD UMD CommonJS 模块规范.mdjs":"h4K6","./浏览器原理.mdjs":"I4L2","./解析 npm-package.json.mdjs":"4MyP","./随想.mdjs":"WUj+"};function p(s){return a(e(s))}function e(s){var n=l[s];if(!(n+1))throw new Error("Cannot find module '"+s+"'.");return n}p.keys=function(){return Object.keys(l)},p.resolve=e,s.exports=p,p.id="/HJh"},"/nxT":function(s,n){},"4MyP":function(s,n){s.exports={info:{title:"解析 npm-package.json",poster:"/static/npm.png",date:"2018-07-16",id:"2018-07-16",desc:"npm-package.json 是描述一个 npm 项目的文件，它包含了很多字段，表示了项目的各种定义"},content:'<h2>前言</h2>\n<p><code>npm</code> 是 <code>nodejs</code> 的包管理工具，它让 <code>javascript</code> 开发者可以方便的分享、复用代码，并以强大的方式组装构建它们，这些可以重复引入的代码被称为 包（package）或模块（module），作为项目的依赖项独立存在。如今 <code>npm</code> 上已有 <code>700,000+</code> 个包，其中有很多优秀的、受开发者欢迎的包，例如 <code>lodash</code>、<code>webpack</code>、<code>react</code>、<code>express</code> 等，世界各地的 <code>javascript</code> 开发者都在使用 <code>npm</code> 或贡献代码，任何人都可以发布一个 <code>npm</code> 包。</p>\n<p>管理本地安装的 <code>npm</code> 包的最佳方法是创建一个 <code>package.json</code> 文件，一个 <code>package.json</code> 文件可以:</p>\n<ol>\n<li>\n<p>列出项目依赖的包。</p>\n</li>\n<li>\n<p>指定项目所使用的依赖项的版本。</p>\n</li>\n<li>\n<p>重新构建更加方便，更容易与他人共享开发。</p>\n</li>\n</ol>\n<p>使用 <code>npm init -y</code> 可以快速创建一个 <code>package.json</code>：</p>\n<pre><code class="hljs" lang="json">$ npm init -y\n\n// ./package.json\n{\n  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"app"</span>,\n  <span class="hljs-attr">"version"</span>: <span class="hljs-string">"1.0.0"</span>,\n  <span class="hljs-attr">"description"</span>: <span class="hljs-string">""</span>,\n  <span class="hljs-attr">"main"</span>: <span class="hljs-string">"index.js"</span>,\n  <span class="hljs-attr">"scripts"</span>: {\n    <span class="hljs-attr">"test"</span>: <span class="hljs-string">"echo "Error: no test specified" &amp;&amp; exit 1"</span>\n  },\n  <span class="hljs-attr">"repository"</span>: {\n    <span class="hljs-attr">"type"</span>: <span class="hljs-string">"git"</span>,\n    <span class="hljs-attr">"url"</span>: <span class="hljs-string">"git+https://github.com/ben/app.git"</span>\n  },\n  <span class="hljs-attr">"keywords"</span>: [],\n  <span class="hljs-attr">"author"</span>: <span class="hljs-string">""</span>,\n  <span class="hljs-attr">"license"</span>: <span class="hljs-string">"ISC"</span>,\n  <span class="hljs-attr">"bugs"</span>: {\n    <span class="hljs-attr">"url"</span>: <span class="hljs-string">"https://github.com/ben/app/issues"</span>\n  },\n  <span class="hljs-attr">"homepage"</span>: <span class="hljs-string">"https://github.com/ben/app#readme"</span>\n}\n</code></pre>\n<p>可以为 <code>init</code> 命令设置多个配置选项：</p>\n<pre><code class="hljs" lang="bash">&gt; npm <span class="hljs-built_in">set</span> init.author.email <span class="hljs-string">"ben@npmjs.com"</span>\n&gt; npm <span class="hljs-built_in">set</span> init.author.name <span class="hljs-string">"ag_dubs"</span>\n&gt; npm <span class="hljs-built_in">set</span> init.license <span class="hljs-string">"MIT"</span>\n</code></pre>\n<blockquote>\n<p>注意：如果 <code>package.json</code> 中没有 <code>description</code> 字段，则 <code>package.json</code> 使用 <code>README.md</code> 或 <code>README</code> 的第一行。<code>description</code> 可帮助开发者在搜索 <code>npm</code> 时找到你的包，因此在 <code>package.json</code> 中编写描述非常有用。</p>\n</blockquote>\n<h2>属性</h2>\n<p><code>package.json</code> 包含了很多属性，当发布一个 <code>npm</code> 包时，<code>name</code> 和 <code>version</code> 字段是必填的。</p>\n<ol>\n<li>\n<p>name：当然就是这个 <code>npm</code> 包的名字。</p>\n<p><code>name</code> 的命名不能以点或下划线开始，不能有大写字母和空格，并且不能与 <code>node</code> 的核心模块相同（例如 <code>path</code>、<code>fs</code>）；考虑到 <code>name</code> 作为一个 <code>npm</code> 包的名字，它可能会出现在 <code>url</code> 引用中、命令行参数中，或是作为一个文件夹的名字，所以有很多限制，非安全的字符是不能出现的，同时也要尽量保持简短。</p>\n<blockquote>\n<p>当你想要发布一个 <code>npm</code> 包时，最好先在<a href="https://www.npmjs.com/">npm</a>搜索你的包名是否已经被占用了。</p>\n</blockquote>\n</li>\n<li>\n<p>version：版本号，使用了 <a href="https://github.com/npm/node-semver">node-semver</a> 管理。</p>\n<p>例如 <code>\'1.0.4\'</code>，<code>\'12.4.5\'</code>，版本号有三位数字，分别代表不同的含义：</p>\n<ul>\n<li>\n<p><code>\'X.0.0\'</code>：表示 <code>主版本</code>，有较大变动，但是向下不兼容的</p>\n</li>\n<li>\n<p><code>\'0.Y.0\'</code>：表示 <code>次版本</code>，有新增功能，并且向下兼容</p>\n</li>\n<li>\n<p><code>\'0.0.Z\'</code>：表示 <code>补丁版本</code>，一般是修复了上个版本的bug</p>\n</li>\n</ul>\n<blockquote>\n<p>当发布 <code>npm</code> 包的迭代时，版本号必需高于之前的版本。</p>\n</blockquote>\n</li>\n<li>\n<p>description：对这个包的表述。有利于使用者快速了解这个包的作用，因为它会出现在 <code>npm</code> 搜索结果里，而 <code>README.md</code> 不会。</p>\n</li>\n<li>\n<p>keywords：包的关键字。同样利于包出现在搜索结果里。</p>\n</li>\n<li>\n<p>homepage：项目的主页的链接，例如 <code>GitHub</code> 地址。</p>\n</li>\n<li>\n<p>bugs：跟踪或提出项目问题的途径，可以是 <code>GitHub</code> 的 <code>issues</code> 地址及你的邮箱:</p>\n<pre><code class="hljs" lang="json"><span class="hljs-string">"bugs"</span>: <span class="hljs-string">"https://github.com/ben/npm-program/issues"</span>\n</code></pre>\n<pre><code class="hljs" lang="json"><span class="hljs-string">"bugs"</span>: {\n    <span class="hljs-attr">"url"</span> : <span class="hljs-string">"https://github.com/ben/npm-program/issues"</span>,\n    <span class="hljs-attr">"email"</span> : <span class="hljs-string">"ben@gmail.com"</span>\n}\n</code></pre>\n</li>\n<li>\n<p>license：许可类型。</p>\n<p>开源世界的软件并不都是可以自由使用的，不同的许可协议赋予了使用者不同的权利，<code>npm</code> 的许可类型多达300多种，通过 <a href="https://opensource.org/about">OSI</a> 认证的有80种，比较常见的开源许可有 <code>MIT</code>、<code>ISC</code>、<code>GPL</code>、<code>Apache</code>等。</p>\n<blockquote>\n<p>参考自：<a href="https://github.phodal.com/">《GitHub漫游指南》</a></p>\n</blockquote>\n</li>\n<li>\n<p>author、contributors：作者或贡献者。</p>\n<p>以一个 <code>people</code> 对象为单位，包含<code>name</code>、<code>url</code>、<code>email</code>字段；<code>author</code> 是一个 <code>people</code> 对象，<code>contributors</code> 是多个。</p>\n<pre><code class="hljs" lang="json"><span class="hljs-string">"author"</span>: {\n    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"ben"</span>,\n    <span class="hljs-attr">"url"</span>: <span class="hljs-string">"http://www.ben.com"</span>,\n    <span class="hljs-attr">"email"</span>: <span class="hljs-string">"ben@gmail.com"</span>\n}\n</code></pre>\n<pre><code class="hljs" lang="json"><span class="hljs-string">"contributors"</span>: [{\n    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"ben"</span>,\n    <span class="hljs-attr">"url"</span>: <span class="hljs-string">"http://www.ben.com"</span>,\n    <span class="hljs-attr">"email"</span>: <span class="hljs-string">"ben@gmail.com"</span>\n}]\n</code></pre>\n<pre><code class="hljs" lang="json">// 同样可以简写为字符串的形式，npm会自动解析\n<span class="hljs-string">"author"</span>: <span class="hljs-string">"ben &lt;ben@gmail.com&gt; (http://www.ben.com)"</span>\n</code></pre>\n</li>\n<li>\n<p>files：描述了 <code>npm</code> 包当做依赖安装时要包含的目录，默认会包含全部文件。</p>\n<p>// vue package.json 中的 files</p>\n<pre><code class="hljs" lang="json"><span class="hljs-string">"files"</span>: [\n    <span class="hljs-string">"src"</span>,\n    <span class="hljs-string">"dist/*.js"</span>,\n    <span class="hljs-string">"types/*.d.ts"</span>\n]\n</code></pre>\n<p>也可以声明一个 <code>.npmignore</code> 文件来确定包含的文件。</p>\n</li>\n<li>\n<p>main：指定程序的入口文件。</p>\n<p>在 <code>require(\'myapp\')</code> 这个模块时，<code>main</code> 字段的文件将被返回。</p>\n<p>使用 <code>npm init</code> 或 <code>yarn init</code> 初始化时会默认为项目根目录下的 <code>index.js</code>。</p>\n</li>\n<li>\n<p>bin：用来指定可执行文件的路径。</p>\n<p>如果你的项目有可执行文件，就需要在 <code>bin</code> 字段中指定文件路径作为映射，当项目作为依赖安装时，<code>npm</code> 会在全局或 <code>./node_modules/.bin/</code> 安装这些可执行文件。</p>\n<pre><code class="hljs" lang="json"><span class="hljs-string">"bin"</span>: {\n    <span class="hljs-attr">"myapp"</span>: <span class="hljs-string">"./cli.js"</span>\n}\n</code></pre>\n<blockquote>\n<p>可执行脚本需要以 <code>#!/usr/bin/env node</code> 开头。</p>\n</blockquote>\n</li>\n<li>\n<p>repository：标识项目代码所在的位置，可以帮助开发者找到项目或为项目贡献代码。</p>\n<pre><code class="hljs" lang="json"><span class="hljs-string">"repository"</span>: {\n    <span class="hljs-attr">"type"</span>: <span class="hljs-string">"git"</span>,\n    <span class="hljs-attr">"url"</span>: <span class="hljs-string">"https://github.com/npm/cli.git"</span>\n}\n</code></pre>\n<p><code>npm</code> 可识别的快捷语法：</p>\n<pre><code class="hljs" lang="js"><span class="hljs-string">"repository"</span>: <span class="hljs-string">"npm/npm"</span>\n<span class="hljs-string">"repository"</span>: <span class="hljs-string">"github:user/repo"</span>\n<span class="hljs-string">"repository"</span>: <span class="hljs-string">"gist:11081aaa281"</span>\n<span class="hljs-string">"repository"</span>: <span class="hljs-string">"bitbucket:user/repo"</span>\n<span class="hljs-string">"repository"</span>: <span class="hljs-string">"gitlab:user/repo"</span>\n</code></pre>\n</li>\n<li>\n<p>scripts：一个包含特定脚本命令的对象。</p>\n<p><code>key</code> 是命令的事件名，<code>value</code> 是执行时所运行的命令。</p>\n<pre><code class="hljs" lang="json"><span class="hljs-string">"scripts"</span>: {\n    <span class="hljs-attr">"dev"</span>: <span class="hljs-string">"node app.js"</span>\n}\n</code></pre>\n<p>如果根目录中有 <code>server.js</code> 文件，那 scripts 的默认值如下：</p>\n<pre><code class="hljs" lang="json"><span class="hljs-string">"scripts"</span>: {\n    <span class="hljs-attr">"start"</span>: <span class="hljs-string">"node server.js"</span>\n}\n</code></pre>\n</li>\n<li>\n<p>dependencies：项目依赖的文件组成的对象，键值对将包名映射到了版本范围，一般描述为生产环境的依赖关系。</p>\n<p><code>-S</code> 或 <code>--save</code> 添加的依赖会被加到这里来：</p>\n<pre><code class="hljs" lang="js">$ npm i vue --save\n\n<span class="hljs-string">"dependencies"</span>: {\n    <span class="hljs-string">"vue"</span>: <span class="hljs-string">"^2.5.2"</span>\n}\n</code></pre>\n<pre><code>version  版本必须完全匹配\n&gt;version  必须大于此版本\n&gt;=version  大于等于此版本\n&lt;version  小于此版本\n&lt;=version  小于等于系版本\n~version  约等于此版本\n^version  兼容版本\n1.2.X  可以是 1.2.0, 1.2.1, ..., 而不是1.3.0\nhttp://...  以 URL 作为依赖\n*  匹配任何版本\n&quot;&quot;  空字符串和 * 是一样的\nversion1 - version2  相当于 &gt;=version1 &lt;=version2\nrange1 || range2  当range1可用时用range1，否则用range2\ngit...  使用 Git URLs 作为依赖\nuser/repo  同上\ntag  使用一个公开的 tag 版本\npath/path/path  使用本地路径\n</code></pre>\n<pre><code class="hljs" lang="json"><span class="hljs-string">"dependencies"</span>: {\n    <span class="hljs-attr">"foo"</span>: <span class="hljs-string">"1.0.0 - 2.9999.9999"</span>,\n    <span class="hljs-attr">"bar"</span>: <span class="hljs-string">"&gt;=1.0.2 &lt;2.1.2"</span>,\n    <span class="hljs-attr">"baz"</span>: <span class="hljs-string">"&gt;1.0.2 &lt;=2.3.4"</span>,\n    <span class="hljs-attr">"boo"</span>: <span class="hljs-string">"2.0.1"</span>,\n    <span class="hljs-attr">"qux"</span>: <span class="hljs-string">"&lt;1.0.0 || &gt;=2.3.1 &lt;2.4.5 || &gt;=2.5.2 &lt;3.0.0"</span>,\n    <span class="hljs-attr">"asd"</span>: <span class="hljs-string">"http://asdf.com/asdf.tar.gz"</span>,\n    <span class="hljs-attr">"til"</span>: <span class="hljs-string">"~1.2"</span>,\n    <span class="hljs-attr">"elf"</span>: <span class="hljs-string">"~1.2.3"</span>,\n    <span class="hljs-attr">"two"</span>: <span class="hljs-string">"2.x"</span>,\n    <span class="hljs-attr">"thr"</span>: <span class="hljs-string">"3.3.x"</span>,\n    <span class="hljs-attr">"lat"</span>: <span class="hljs-string">"latest"</span>,\n    <span class="hljs-attr">"dyl"</span>: <span class="hljs-string">"file:../dyl"</span>\n}\n\n</code></pre>\n</li>\n<li>\n<p>devDependencies：如果有人在项目中想使用你的模块，那么一定不希望也不需要下载你模块中的开发或测试环境依赖，这种情况下，最好把这些附加依赖映射到 <code>devDependencies</code> 字段中。</p>\n<p><code>-D</code> 或 <code>--save-dev</code> 添加的依赖会被加到这里来：</p>\n<pre><code class="hljs" lang="json">$ npm i stylus --save-dev\n\n<span class="hljs-string">"devDependencies"</span>: {\n    <span class="hljs-attr">"stylus"</span>: <span class="hljs-string">"^0.54.5"</span>\n}\n</code></pre>\n</li>\n<li>\n<p>peerDependencies、bundledDependencies、optionalDependencies</p>\n</li>\n<li>\n<p>engines：指定项目的 <code>nodejs</code> 版本（例如 webpack 4.0.0+ 只支持 nodejs 6.11.5 以上）；如果省略了 <code>engines</code> 字段或指定为 <code>&quot;*&quot;</code>，则表示可以支持任何版本。</p>\n<blockquote>\n<p>注意：除非用户设置了 <code>engine-strict</code> 标识， 否则此字段仅供参考，并且将项目作为依赖项时才起作用。<code>engineStrict</code> 字段已经在npm 3.0.0 是移除了，如果想使用可以用 <a href="https://www.npmjs.com/package/engine-strict">engine-strict</a> 这个模块</p>\n</blockquote>\n<p>当然除了指定 <code>nodejs</code> 版本，还可以指定 <code>npm</code> 版本：</p>\n<pre><code class="hljs" lang="json"><span class="hljs-string">"engines"</span>: {\n    <span class="hljs-attr">"node"</span>: <span class="hljs-string">"&gt;=6.11.5"</span>,\n    <span class="hljs-attr">"npm"</span>: <span class="hljs-string">"~5.0.0"</span>\n}\n</code></pre>\n</li>\n<li>\n<p>os：为模块指定操作系统。</p>\n<pre><code class="hljs" lang="json"><span class="hljs-string">"os"</span>: [<span class="hljs-string">"darwin"</span>, <span class="hljs-string">"linux"</span>]\n\n// 如果你想设置黑名单，只需要在操作系统前加 \'!\'\n<span class="hljs-string">"os"</span>: [<span class="hljs-string">"!win32"</span>]\n</code></pre>\n<blockquote>\n<p>主机操作系统由 <code>process.arch</code> 确定</p>\n</blockquote>\n</li>\n<li>\n<p>cpu：如果你的代码仅可以在某些cpu体系上运行，那么这个字段可以帮到你。</p>\n<pre><code class="hljs" lang="json"><span class="hljs-string">"cpu"</span> : [ <span class="hljs-string">"x64"</span>, <span class="hljs-string">"ia32"</span> ]\n\n// 同样支持黑名单：\n<span class="hljs-string">"cpu"</span> : [ <span class="hljs-string">"!arm"</span>, <span class="hljs-string">"!mips"</span> ]\n</code></pre>\n<blockquote>\n<p>主机架构由 <code>process.arch</code> 确定</p>\n</blockquote>\n</li>\n<li>\n<p>private：如果你设置了 <code>private</code> 为 <code>true</code>，那么 <code>npm</code> 将拒绝发布它。这是一种防止私有库被意外发布的方法。</p>\n</li>\n</ol>\n<p>当运行 <code>npm install</code> 时，<code>npm</code> 会根据 <code>package.json</code> 的 <code>dependencies</code> 与 <code>devDependencies</code> 字段映射的所有依赖版本，将依赖包安装到 <code>./node_modules/</code> 中。</p>\n<h2>定制 <code>package.json</code></h2>\n<p>如果你希望敲下 <code>npm init</code> 就能生成你想要的 <code>package.json</code>，那么你可以定制你的 <code>package.json</code>：</p>\n<p>创建 <code>~/.npm-init.js</code> 文件:</p>\n<pre><code class="hljs" lang="js"><span class="hljs-built_in">module</span>.exports = {\n  <span class="hljs-attr">customField</span>: <span class="hljs-string">\'Custom Field\'</span>,\n  <span class="hljs-attr">otherCustomField</span>: <span class="hljs-string">\'This field is really cool\'</span>\n}\n</code></pre>\n<pre><code class="hljs" lang="js">$ npm init\n\n<span class="hljs-comment">// ./package.json</span>\n{\n  <span class="hljs-attr">customField</span>: <span class="hljs-string">\'Custom Field\'</span>,\n  <span class="hljs-attr">otherCustomField</span>: <span class="hljs-string">\'This field is really cool\'</span>\n}\n</code></pre>\n<p>使用 <code>prompt</code> 加入自定义问题：</p>\n<pre><code class="hljs" lang="js"> <span class="hljs-built_in">module</span>.exports = prompt(<span class="hljs-string">"what\'s your favorite flavor of ice cream, buddy?"</span>, <span class="hljs-string">"I LIKE THEM ALL"</span>);\n</code></pre>\n<h2>发布一个 npm 包</h2>\n<blockquote>\n<p>在此之前，你需要注册一个 <code>npm</code> 账号。</p>\n</blockquote>\n<ul>\n<li>\n<p>配置好 <code>package.json</code> 文件，为你的包起一个好名字</p>\n</li>\n<li>\n<p>检查项目的开源许可类型，减少一些纠纷</p>\n</li>\n<li>\n<p>最好有一些单元测试，让开发者放心食用</p>\n</li>\n<li>\n<p>编写一个清晰的 <code>README.md</code>，项目的使用文档，花里胡哨的配图</p>\n</li>\n</ul>\n<pre><code class="hljs" lang="bash"><span class="hljs-comment"># 登录 npm 账号</span>\n$ npm login\n\n<span class="hljs-comment"># 输入用户名 密码</span>\nUsername: ben\nPassword:\nEmail: (this IS public) ben@npmjs.com\n\n<span class="hljs-comment"># 登录成功</span>\nLogged <span class="hljs-keyword">in</span> as ben on https://registry.npmjs.org/.\n\n<span class="hljs-comment"># 发布</span>\n$ npm publish\n</code></pre>\n<p><img src="https://img.shields.io/badge/package-json-ff69b4.svg" alt="http://shields.io/"></p>\n',wordCount:7509}},"4oDU":function(s,n){s.exports={info:{title:"Linux学习笔记",poster:"",date:"2020-03-07",id:"2020-03-07",desc:"学习linux的常用命令，文件系统，权限系统，软件安装，远程登录等知识"},content:'<h1>linux-note</h1>\n<h2>命令</h2>\n<h3>关于参数</h3>\n<p>参数常常跟在命令后面，用于改变命令的行为</p>\n<ol>\n<li>短参数\n<code>-p</code>  短参数 一个连字符与一个字母\n<code>-p -a</code> 多个短参数\n<code>-pasf</code> 多个短参数可以合并在一起\n<code>-p 10</code>  短参数传递值</li>\n<li>长参数\n<code>—para</code> 长参数 两个连字符与多个字母\n<em>多个长参数不可合并</em>\n<code>—para=10</code> 长参数传递值</li>\n</ol>\n<ul>\n<li>\n<p><code>&lt;xxx&gt;</code> 必填内容</p>\n</li>\n<li>\n<p><code>[xxx]</code> 选填内容</p>\n</li>\n<li>\n<p><code>&lt;xxx|xxx&gt;</code> 至少选择一项</p>\n</li>\n<li>\n<p><code>[xxx]...</code> 可多次重复</p>\n</li>\n<li>\n<p><code>&amp;&amp;</code> 前面命令成功，才执行后面命令</p>\n</li>\n<li>\n<p><code>||</code> 前面命令失败，才执行后面命令</p>\n</li>\n<li>\n<p><code>;</code> 执行完前面命令就执行后面命令</p>\n</li>\n</ul>\n<h3>常用命令</h3>\n<p><code>whoami</code> 显示当前用户</p>\n<p><code>hostname</code> 显示主机名</p>\n<p><code>date</code> 显示日期</p>\n<p><code>history</code> 历史运行过的命令</p>\n<p><code>clear</code> 清屏</p>\n<p><code>exit</code> 退出终端或当前账户</p>\n<p><code>pwd</code> 显示当前工作目录 <code>print working directory</code></p>\n<p><code>which</code> 显示一个命令的对应可执行文件的路径</p>\n<ul>\n<li><code>which pwd</code></li>\n</ul>\n<h3>文件操作</h3>\n<h4>基本命令</h4>\n<p><code>ls</code> 列举目录下的文件和目录 <em><code>list</code></em></p>\n<ul>\n<li><code>ls</code> 列举当前目录</li>\n<li><code>ls dir</code> 列举 <code>dir</code> 目录</li>\n<li><code>-a</code> 显示全部文件、目录，包括隐藏文件、目录 (all)。以 <code>.</code> 开头的是隐藏文件或目录：<code>.git</code></li>\n<li><code>-l</code> 显示详细信息的列表</li>\n<li><code>-t</code> 按最近修改时间排序</li>\n<li><code>-h</code> 以便于阅读的方式展示</li>\n<li><code>-i</code> 显示文件的 <em><code>inode</code></em></li>\n</ul>\n<p><code>cd</code> 切换目录 <em><code>change directory</code></em></p>\n<ul>\n<li><code>cd /</code> 跳转至根目录</li>\n<li><code>cd ../</code> 跳转至上级目录</li>\n</ul>\n<p><code>du</code> 统计j目录的大小，他会向下遍历每一层目录 <em><code>disk usage</code></em></p>\n<ul>\n<li>\n<p><code>du</code> 显示当前目录的大小</p>\n</li>\n<li>\n<p><code>du test.txt</code>  显示 <code>test.txt</code> 文件的大小</p>\n</li>\n<li>\n<p><code>du -a</code> 统计目录以及文件的大小</p>\n</li>\n<li>\n<p><code>du -s</code> 至显示总计大小</p>\n</li>\n</ul>\n<p><code>cat</code> 显示文件内容，显示文件所有内容</p>\n<ul>\n<li><code>cat -n test.txt</code> 显示行号</li>\n<li><code>cat 1.txt 2.txt</code>  显示多个文件内容</li>\n</ul>\n<p><code>less</code> 读取部分文件内容</p>\n<p>浏览模式下的快捷键：</p>\n<ul>\n<li><code>d</code> 前进半页</li>\n<li><code>b</code> 后退一页</li>\n<li><code>y</code> 后退一行</li>\n<li><code>u</code> 后退半页</li>\n<li><code>q</code> 停止读取</li>\n<li><code>=</code> 显示当前在文件中什么位置</li>\n<li><code>/</code> 搜索内容</li>\n<li><code>n</code> 显示下一个搜索匹配结果</li>\n<li><code>N</code> 显示上一个搜索匹配结果</li>\n</ul>\n<p><code>head</code> 显示文件开头</p>\n<ul>\n<li><code>-n</code> 显示行号</li>\n</ul>\n<p><code>tail</code> 显示文件结尾</p>\n<ul>\n<li><code>-n</code> 显示行号</li>\n<li><code>-f</code> 实时显示文件追加的内容</li>\n<li><code>-s</code> 指定检查文件更新的频率 默认为1秒</li>\n</ul>\n<p><code>touch</code> 修改文件的创建时间或修改时间；如果文件不存在，就会创建这个文件，所以可以用这个命令来创建文件</p>\n<ul>\n<li>\n<p><code>touch newfile</code> 创建 <code>newfile</code>  文件</p>\n</li>\n<li>\n<p><code>touch file1 file2</code> 同时创建多个文件</p>\n</li>\n<li>\n<p><code>touch &quot;new file&quot;</code> 创建文件名带空格的文件，需要使用双引号</p>\n</li>\n</ul>\n<p><code>mkdir</code> 创建目录</p>\n<ul>\n<li>\n<p><code>mkdir newfloder</code> 创建 <code>newfloder</code>  目录</p>\n</li>\n<li>\n<p><code>mkdir floder1 floder2</code> 同时创建多个目录</p>\n</li>\n<li>\n<p><code>mkdir &quot;new floder&quot;</code> 创建目录名带空格的目录，需要使用双引号</p>\n</li>\n<li>\n<p><code>-p</code> 递归创建目录结构 <code>mkdir a/b/c</code></p>\n</li>\n</ul>\n<p><code>cp</code> 拷贝文件或目录</p>\n<ul>\n<li><code>cp file1 file2</code> 复制 <code>file1</code> 为 <code>file2</code></li>\n<li><code>cp file floder</code> 拷贝 <code>file</code> 至 <code>floder</code> 目录下</li>\n<li><code>-r</code> 递归拷贝，也就是拷贝目录</li>\n<li><code>cp *.img images</code> 将当前目录下所有以 <code>.img</code> 结尾的文件拷贝到 <code>images</code> 目录</li>\n<li><code>cp icon-* images</code> 将当前目录下所有以 <code>icon-</code> 开头的文件拷贝到 <code>images</code> 目录</li>\n</ul>\n<p><code>mv</code> 移动文件或目录</p>\n<ul>\n<li><code>mv file floder/</code> 将文件 <code>file</code> 移动至 <code>floder/</code> 目录下</li>\n<li><code>mv file1 file2</code>  将 <code>file1</code> 重命名为 <code>file2</code></li>\n</ul>\n<p><code>rm</code> 删除文件或目录</p>\n<ul>\n<li><code>rm file</code> 删除当前目录下的 <code>file</code> 文件</li>\n<li><code>rm fil1 fil2</code> 同时删除多个文件</li>\n<li><code>-i</code> 询问是否删除</li>\n<li><code>-f</code> 强制删除，不会询问</li>\n<li><code>-r</code> 递归删除</li>\n</ul>\n<p><code>rmdir</code> 删除空目录</p>\n<p><code>ln</code> 创建链接 <em><code>link</code></em></p>\n<blockquote>\n<p>linux链接分为 硬链接 和 软连接 两种</p>\n<p>硬链接：（一般只能创建文件的硬链接）不同的文件名指向相同的文件内容 <code>inode</code> ，当修改一个文件时，也是在修改另一个文件；删除其中一个文件，不会对其他文件造成影响</p>\n<p>软连接：（可以指向文件或目录）创建一个文件，指向某文件的文件名，相当于快捷方式；删除软链接，源文件不收影响，但是删除源文件，软链接会失效</p>\n</blockquote>\n<ul>\n<li><code>ln file1 file2</code> 创建 <code>file1</code> 的硬链接 <code>file2</code></li>\n<li><code>-s</code> 创建软链接 symbolic</li>\n<li><code>ln -s file1 file2</code> 创建 <code>file1</code>  的软链接 <code>file2</code></li>\n</ul>\n<p><code>find</code> 查找命令</p>\n<ul>\n<li>\n<p><code>find [path] &lt;file-name&gt; [action]</code> 可指定路径下查找文件，还可以指定查找后的动作</p>\n</li>\n<li>\n<p><code>find -name &lt;file-name&gt;</code> 在当前目录下查找所有符合 <code>file-name</code> 的文件或目录</p>\n</li>\n<li>\n<p><code>find /home -name file</code> 在 <code>/home</code> 目录下查找 <code>file</code> 文件</p>\n</li>\n<li>\n<p><code>find pre*</code> 当前目录下查找所有以 <code>pre</code> 开头的文件或目录</p>\n</li>\n<li>\n<p><code>find *.txt</code> 当前目录下查找所有以 <code>.txt</code> 结尾的文件或目录</p>\n</li>\n<li>\n<p><code>-size</code> 指定大小查找</p>\n<ul>\n<li><code>-size -20M</code> 小于 <code>20M</code> 的文件</li>\n<li><code>-size 1G</code> 等于 <code>1G</code> 的文件</li>\n</ul>\n</li>\n<li>\n<p><code>-atime</code> 按访问时间查找 <em><code>access time</code></em></p>\n<ul>\n<li><code>-atime 10</code> 最近10天</li>\n<li><code>-atime -10</code> 10天之内</li>\n</ul>\n</li>\n<li>\n<p><code>-type</code> 文件类型</p>\n<ul>\n<li><code>-type d</code> 查找的目标是目录</li>\n<li><code>-type f</code> 查找的目标是文件</li>\n</ul>\n</li>\n<li>\n<p><code>-printf</code> 格式化打印结果</p>\n<ul>\n<li><code>-printf &quot;%p - %u/n&quot;</code> 按格式打印查找的结果</li>\n<li><code>%p</code> 文件名</li>\n<li><code>%u</code> 用户名</li>\n</ul>\n</li>\n<li>\n<p><code>-delete</code> 删除查找到的文件</p>\n</li>\n<li>\n<p><code>-exec</code> 对结果文件执行命令，命令以 <code>;</code> 结尾</p>\n<ul>\n<li><code>-exec cp {} ./result ;</code> 将匹配到的每个文件（用 <code>{}</code> 表示）复制到 <code>./result</code> 目录</li>\n</ul>\n</li>\n<li>\n<p><code>-ok</code> 与 <code>-exec</code> 用法一致，但是会在执行命令前让用户确认</p>\n</li>\n</ul>\n<p><code>grep</code> 全局搜索正则表达式并打印</p>\n<ul>\n<li><code>grep &lt;word&gt; &lt;file&gt;</code> 在文件中搜索</li>\n<li><code>-i</code> 忽略大小写</li>\n<li><code>-n</code> 显示行号</li>\n<li><code>-v</code> 只显示文本不在的行</li>\n<li><code>-r</code> 在目录中递归查找</li>\n<li><code>-E</code> 使用正则表达式搜索</li>\n</ul>\n<p><code>wc</code> 文件统计 <em><code>word count</code></em></p>\n<ul>\n<li><code>wc file</code> 打印行数、单词数，字节数</li>\n<li><code>-l</code> 统计行数</li>\n<li><code>-w</code> 统计单词数</li>\n<li><code>-c</code> 统计字节数</li>\n<li><code>-m</code> 统计字符数</li>\n</ul>\n<h4>压缩</h4>\n<p><code>tar</code> 将多个文件归并成归档</p>\n<ul>\n<li><code>-c</code> 创建 <em><code>create</code></em></li>\n<li><code>-v</code> 显示过程</li>\n<li><code>-f</code> 指定文件 <em><code>file</code></em></li>\n<li><code>-t</code>  <em><code>list</code></em></li>\n<li><code>-x</code> 解开归档</li>\n<li><code>-z</code> 压缩文件</li>\n<li><code>tar -cvf file.tar file</code> 将 <code>file</code> 文件归档</li>\n<li><code>tar -zcvf file.tar.gz file</code> 将文件归档并压缩</li>\n<li><code>tar -tf file.tar</code> 显示归档内容而不解开归档</li>\n<li><code>tar -rvf file.tar file</code> 追加文件 <code>file</code> 到归档 <code>file.tar</code></li>\n<li><code>tar -xvf file.tar</code> 解开归档</li>\n<li><code>tar -zxvf file.tar.gz</code> 解压并解开归档</li>\n</ul>\n<p><code>gzip</code> 压缩文件</p>\n<ul>\n<li><code>gzip file.tar</code> 压缩一个归档</li>\n</ul>\n<p><code>gunzip</code> 解压文件</p>\n<ul>\n<li><code>gunzip file.tar.gz</code> 解压文件</li>\n</ul>\n<p><code>zip</code> 压缩成 <code>zip</code> 文件</p>\n<ul>\n<li><code>zip file.zip file</code> 压缩 <code>file</code> 文件为 <code>file.zip</code></li>\n<li><code>zip -r dir.zip ./dir/</code> 递归压缩目录</li>\n</ul>\n<p><code>unzip</code> 解压文件</p>\n<ul>\n<li><code>unzip file.zip</code> 解压文件</li>\n<li><code>unzip -l file.zip</code> 不解压只查看内容</li>\n</ul>\n<p><code>wget</code> 下载器</p>\n<ul>\n<li><code>wget xxxxxx</code> 下载一个链接的文件</li>\n</ul>\n<h4>流、管道、重定向</h4>\n<p>linux中的数据可以通过命令输出到屏幕上，也可以保存在文件中，甚至作为另一个命令的输入，这样的方式叫做管道，管道中的数据就是流 <code>stream</code></p>\n<h5>重定向 <code>&gt;</code> <code>&gt;&gt;</code></h5>\n<p><strong>重定向到文件时，没有文件会默认新建，有则会覆盖</strong></p>\n<p>标准输出使用 <code>&gt;</code> 或 <code>&gt;&gt;</code> (标准输出符是1)</p>\n<p><code>ls &gt; dir.txt</code> 将目录信息从定向到文件 <code>dir.txt</code> 中保存</p>\n<p><code>groups &gt;&gt; log</code> 将群组信息追加到 <code>log</code> 文件末尾</p>\n<p>标准错误输出使用 <code>2&gt;</code> （标准错误输出符是2)</p>\n<p><code>cp not_exist_file file 2&gt; err_log</code> 将错误信息输出至 <code>err_log</code> 文件中</p>\n<p><code>cp file file &gt; log 2&gt; err_log</code> 成功输出至 <code>log</code> ，若失败则错误信息输出至 <code>err_log</code> 文件中</p>\n<p><code>cp file file &gt; log 2&gt;&gt; err_log</code> 成功输出至 <code>log</code> ，若失败则错误信息追加至 <code>err_log</code> 文件中</p>\n<p><code>cp file file &gt; log 2&gt;&amp;1 err_log</code> 成功输出至 <code>log</code> ，若失败也将错误信息输出至 <code>err_log</code> 文件中； <code>2&gt;&amp;1</code> 表示标准错误输出与标准输出一致</p>\n<p><code>cp file file &gt;&gt; log 2&gt;&amp;1 err_log</code> 追加只改变标准输出就可以 <code>&gt;&gt;</code></p>\n<h4>文本编辑器 vim</h4>\n<p><code>vim</code> 是一个 <code>linux</code> 常用的文本编辑器之一，具有强大的快捷键操作功能。</p>\n<p><code>vimtutor</code> 命令可以进去 <code>vim</code> 的教程进行学习</p>\n<p><code>vim</code> 快捷键：</p>\n<p><code>h</code> 向左移动光标</p>\n<p><code>l</code> 向右移动光标</p>\n<p><code>j</code> 向下移动光标</p>\n<p><code>k</code> 向上移动光标</p>\n<p><code>x</code> 删除光标所在的字符</p>\n<p><code>i</code> 在光标所在字符位置插入</p>\n<p><code>a</code> 在光标所在字符后插入</p>\n<p><code>A</code> 在行尾插入</p>\n<p><code>o</code> 在光标下方新起一行插入</p>\n<p><code>O</code> 在光标上方新起一行插入</p>\n<p><code>r</code> 替换光标所在字符</p>\n<p><code>R</code> 连续替换模式</p>\n<p><code>dw</code> 删除单词，从光标位置直到下一个单词起始处</p>\n<p><code>de</code> 删除从光标直到单词末尾，包括最后一个字符</p>\n<p><code>d$</code> 从光标删除到行末</p>\n<p><code>d2w</code> 删除后 <code>2</code> 个单词</p>\n<p><code>cw</code> 删除单词，从光标位置直到下一个单词起始处，并进入编辑模式</p>\n<p><code>ce</code> 删除从光标直到单词末尾，包括最后一个字符，并进入编辑模式</p>\n<p><code>c$</code> 从光标删除到行末，并进入编辑模式</p>\n<p><code>w</code> 移动到下一个单词的开始</p>\n<p><code>2w</code> 移动到  <code>2</code> 个单词后的开始</p>\n<p><code>e</code> 移动到下一个单词的末尾</p>\n<p><code>3e</code> 移动到  <code>3</code> 个单词后的末尾</p>\n<p><code>0</code> 移动到行首</p>\n<p><code>$</code> 移动到行尾</p>\n<p><code>dd</code> 删除一行</p>\n<p><code>2dd</code> 删除 <code>2</code> 行</p>\n<p><code>u</code> 撤销最后的操作命令</p>\n<p><code>U</code> 撤销整行的修改</p>\n<p><code>ctrl+r</code>  重做被撤消的命令</p>\n<p><code>ctrl+g</code> 显示光标所在行位置以及文件状态信息</p>\n<p><code>G</code> 跳转文件最后一行</p>\n<p><code>gg</code> 跳转文件第一行</p>\n<p><code>30G</code> 跳转到第 <code>30</code> 行</p>\n<p><code>ctrl+o</code> 跳回较旧位置</p>\n<p><code>ctrl+i</code> 跳回较新位置</p>\n<p><code>/word</code> 搜索，按 <code>n</code> 搜索下一个，<code>N</code> 搜索上一个</p>\n<p><code>?word</code> 向上搜索</p>\n<p><code>%</code> 查找匹配的括号</p>\n<p><code>:s/old/new</code> 在一行内的第一个 <code>old</code> 替换成 <code>new</code></p>\n<p><code>:s/old/new/g</code> 在一行内所有 <code>old</code> 替换成 <code>new</code></p>\n<p><code>:5,10s/old/new</code> 指定 <code>5</code> 到 <code>10</code> 行</p>\n<p><code>:%s/old/new/g</code> 全文替换所有 <code>old</code> 为 <code>new</code></p>\n<p><code>:%s/old/new/gc</code> 在替换时提示是否替换</p>\n<p><code>:!ls</code> 执行外部命令 <code>ls</code>，按 <code>enter</code> 返回 <code>vim</code></p>\n<p><code>:w file.txt</code> 以 <code>file.txt</code> 文件名保存</p>\n<p><code>v</code> 进入选择模式，按 <code>:</code> 确认选择。可以将所选文本保存成文件 <code>:\'&lt;,\'&gt;w file.txt</code></p>\n<p><code>:r fileName</code> 从光标处插入文件内容</p>\n<p><code>:r !ls</code> 还可以插入外部命令的输出</p>\n<p><code>y</code> 复制 <code>v</code> 模式选择的文本</p>\n<p><code>yw</code> 复制一个单词</p>\n<p><code>ye</code> 复制光标处到单词结尾的字符</p>\n<p><code>yy</code> 复制一行</p>\n<p><code>p</code> 在光标处粘贴</p>\n<p><code>:set ic</code> 忽略搜索大小写</p>\n<p><code>:set noic</code> 启用搜索大小写</p>\n<p><code>:set hls</code> 高亮搜索结果</p>\n<p><code>:set is</code> 找短语时显示部分匹配</p>\n<p><code>f1</code> 打开帮助，<code>ctrl+w ctrl+w</code> 切换窗口</p>\n<p><code>:help</code> 打开帮助</p>\n<p><code>:help a</code> 查看某指令的帮助</p>\n<p>新建 <code>vim ~/.vimrc</code> 文件，插入默认配置：<code>:r $VIMRUNTIME/vimrc_example.vim</code></p>\n<p>vim 的插件管理：<a href="https://github.com/junegunn/vim-plug">vim-plug</a></p>\n<h3>用户与群组</h3>\n<p><code>sudo</code> 以 <code>root</code> 用户运行命令 <em><code>substitute user do</code></em></p>\n<ul>\n<li><code>sudo su</code> 切换为 <code>root</code> 用户</li>\n<li><code>-i</code> 切换到家目录</li>\n</ul>\n<p><code>su</code> 切换用户</p>\n<ul>\n<li>\n<p><code>su</code> 切换为 <code>root</code> 用户</p>\n</li>\n<li>\n<p><code>su user1</code> 切换为 <code>user1</code> 用户</p>\n</li>\n<li>\n<p><code>su -</code> 切换为 <code>root</code> 用户并切换到 <code>root</code> 的家目录</p>\n</li>\n</ul>\n<p><code>useradd</code> 添加用户</p>\n<ul>\n<li><code>useradd tom</code> 创建用户</li>\n</ul>\n<p><code>passwd</code> 操作用户密码</p>\n<ul>\n<li><code>passwd user1</code> 修改user1用户的密码</li>\n</ul>\n<p><code>userdel</code> 删除用户</p>\n<ul>\n<li><code>userdel user1</code> 删除user1用户</li>\n<li><code>-r</code> <code>—remove</code> 删除用户的 <code>home</code> 目录</li>\n</ul>\n<p><code>groups</code> 获取用户群组</p>\n<ul>\n<li><code>groups user1</code> 获取用户user1的群组</li>\n</ul>\n<p><code>groupadd</code> 添加群组</p>\n<ul>\n<li><code>groupadd group1</code> 添加一个叫 <code>group1</code> 的群组</li>\n</ul>\n<p><code>groupdel</code> 删除群组</p>\n<ul>\n<li><code>groupdel group1</code> 删除 <code>group1</code> 群组</li>\n</ul>\n<p><code>usermod</code> 修改用户账户</p>\n<ul>\n<li><code>usermod -g group1 user1</code>  将用户user1添加进group1群组</li>\n<li><code>usermod -G group1,group2 user1</code>  将用户user1添加进group1、group2群组</li>\n<li><code>-l</code> 对用户重命名 (用户的家目录名称不会修改)</li>\n<li><code>-g</code> 修改用户所在群组</li>\n<li><code>-G</code> 修改多个群组 群组名之间用逗号分隔</li>\n<li><code>-a</code> 追加到用户组，会将用户保留在原有的组里；需要时用 <code>-G</code>，例如<code>-aG</code></li>\n</ul>\n<p><code>chown</code> 改变文件的所有者 <em><code>change owner</code></em></p>\n<ul>\n<li><code>chown user1 file1</code> 将文件 <code>file1</code> 的所有者变为 <code>user1</code></li>\n<li><code>chown user1:group1 file1</code> 将文件 <code>file1</code> 的所有者改为 <code>user1</code>，文件的群组改为 <code>group1</code></li>\n<li><code>-R</code> 递归设置子目录和子文件</li>\n</ul>\n<p><code>chgrp</code> 改变文件的群组 <code>change group</code></p>\n<ul>\n<li><code>chown group1 file1</code> 将文件 <code>file1</code> 的群组变为 <code>group1</code></li>\n<li><code>-R</code> 递归设置子目录和子文件</li>\n</ul>\n<h2>权限</h2>\n<h3>权限符</h3>\n<p>根目录下输入 <code>ls -l</code> ，会显示所有文件以及其信息，其中类似这样的 <code>drwxr-xr-x.</code> 文件信息，代表文件访问权限符</p>\n<table>\n<thead>\n<tr>\n<th>权限符号</th>\n<th>含义</th>\n<th>代表权限</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>d</td>\n<td><em>directory</em></td>\n<td>表示文件是目录</td>\n</tr>\n<tr>\n<td>l</td>\n<td><em>link</em></td>\n<td>表示文件是链接</td>\n</tr>\n<tr>\n<td>r</td>\n<td><em>read</em></td>\n<td>可读权限</td>\n</tr>\n<tr>\n<td>w</td>\n<td><em>write</em></td>\n<td>可写和可删除权限</td>\n</tr>\n<tr>\n<td>x</td>\n<td><em>execute</em></td>\n<td>可执行权限</td>\n</tr>\n<tr>\n<td>.</td>\n<td></td>\n<td>安全标签</td>\n</tr>\n<tr>\n<td>-</td>\n<td></td>\n<td>普通文件或无相应权限</td>\n</tr>\n</tbody>\n</table>\n<p>一个完整的文件权限的表示方式：</p>\n<table>\n  <tr>\n  \t<td></td>\n  \t<td>文件属性</td>\n  \t<td colspan="3">所有者权限</td>\n  \t<td colspan="3">群组用户</td>\n  \t<td colspan="3">其他用户</td>\n  \t<td colspan="3">安全标签</td>\n  </tr>\n  <tr>\n  \t<td>权限符</td>\n  \t<td>d, l, -</td>\n  \t<td>r</td>\n  \t<td>w</td>\n  \t<td>x</td>\n  \t<td>r</td>\n  \t<td>w</td>\n  \t<td>x</td>\n  \t<td>r</td>\n  \t<td>w</td>\n  \t<td>x</td>\n  \t<td>.</td>\n  </tr>\n  <tr>\n  \t<td>权限值</td>\n  \t<td></td>\n  \t<td>4</td>\n  \t<td>2</td>\n  \t<td>1</td>\n  \t<td>4</td>\n  \t<td>2</td>\n  \t<td>1</td>\n  \t<td>4</td>\n  \t<td>2</td>\n  \t<td>1</td>\n  \t<td></td>\n  </tr>\n</table>\n<p>例如表示一个文件的权限就是这样：<code>drwxrwx---.</code> ，指明这是一个目录文件，所有者对此文件可读可写可执行，群组用户也可读可写可执行，其他用户没有任何权限。</p>\n<p>权限符对应的值进行相加就是文件的权限</p>\n<blockquote>\n<p>除普通用户外，<code>root</code> 用户拥有系统最高权限，也就是拥有文件的所有权限。</p>\n</blockquote>\n<h3>修改文件的权限</h3>\n<p><code>chmod</code> 命令可以修改文件的权限 <em><code>change mode</code></em></p>\n<p>将权限对应的值相加就是文件的权限：</p>\n<table>\n<thead>\n<tr>\n<th>权限</th>\n<th>值</th>\n<th>计算方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>---</td>\n<td>0</td>\n<td>0+0+0</td>\n</tr>\n<tr>\n<td>—x</td>\n<td>1</td>\n<td>0+0+1</td>\n</tr>\n<tr>\n<td>-w-</td>\n<td>2</td>\n<td>0+2+0</td>\n</tr>\n<tr>\n<td>-wx</td>\n<td>3</td>\n<td>0+2+1</td>\n</tr>\n<tr>\n<td>r--</td>\n<td>4</td>\n<td>4+0+0</td>\n</tr>\n<tr>\n<td>r-x</td>\n<td>5</td>\n<td>4+0+1</td>\n</tr>\n<tr>\n<td>rw-</td>\n<td>6</td>\n<td>4+2+0</td>\n</tr>\n<tr>\n<td>rwx</td>\n<td>7</td>\n<td>4+2+1</td>\n</tr>\n</tbody>\n</table>\n<h4>1. 通过权限值修改</h4>\n<p>例如对文件分配权限 <code>777</code>，表示 <code>用户|群组|其他用户</code> 权限分别为 <code>7</code>，所以执行命令 <code>chmod 777 file</code> ，文件权限将变为：<code>rwxrwxrwx</code></p>\n<h4>2. 通过权限符修改</h4>\n<p>通过权限符可以细粒度的控制不同用户的权限</p>\n<p>通过组合用户、修改行为、权限符，来修改一个文件的权限：</p>\n<p>用户：</p>\n<table>\n<thead>\n<tr>\n<th>所属用户 user</th>\n<th>群组 group</th>\n<th>其他用户 other</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>u</td>\n<td>g</td>\n<td>o</td>\n</tr>\n</tbody>\n</table>\n<p>修改行为：</p>\n<table>\n<thead>\n<tr>\n<th>赋予权限</th>\n<th>添加权限</th>\n<th>删除权限</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>=</td>\n<td>+</td>\n<td>-</td>\n</tr>\n</tbody>\n</table>\n<p>权限码：</p>\n<table>\n<thead>\n<tr>\n<th>可读 read</th>\n<th>可写 write</th>\n<th>可执行 execute</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>r</td>\n<td>w</td>\n<td>x</td>\n</tr>\n</tbody>\n</table>\n<p>组合之后可以修改文件权限了：</p>\n<ul>\n<li><code>chmode u+rw file1</code> 增加所属用户的读写权限</li>\n<li><code>chmode g-w file1</code> 去除群组的写权限</li>\n<li><code>chmod o=- file1</code> 设置其他用户无任何权限</li>\n<li><code>chmod u=rw,g=rw file1</code> 同时设置多种权限</li>\n<li><code>-R</code> 递归修改所有子目录和文件</li>\n</ul>\n<h2>系统管理</h2>\n<h3>进程管理</h3>\n<p><code>w</code> 显示系统运行时间，负载，以及正在登录的用户</p>\n<p><code>uptime</code> 显示系统运行时长</p>\n<p><code>toload</code> 显示负载变化图</p>\n<p><code>who</code> 显示登录中的 用户</p>\n<p><code>ps</code> 查看进程 <em><code>process status</code></em></p>\n<ul>\n<li><code>-ef</code> 列出所有用户的所有进程</li>\n<li><code>-u</code> 指定列出某用户</li>\n<li><code>-aux</code> 根据cpu和内存使用率过滤\n<ul>\n<li><code>--sort</code> 排序\n<ul>\n<li><code>-aux --sort -pcpu</code> 根据cpu使用率排序</li>\n<li><code>-aux --sort -pmem</code> 根据内存使用率排序</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><code>top</code> 进程的动态列表</p>\n<p><code>top</code> 面板的快捷键：</p>\n<ul>\n<li><code>q</code> 退出</li>\n<li><code>h</code> 帮助</li>\n<li><code>f</code> 编辑表头、排序</li>\n<li><code>u</code> 筛选用户</li>\n<li><code>k</code> 结束进程</li>\n<li><code>s</code> 改变刷新时间</li>\n</ul>\n<p><code>htop</code> 是一款比 <code>top</code> 命令功能更多的终端工具</p>\n<p>安装 <code>htop</code>：</p>\n<ol>\n<li><code>yum install -y epel-release</code></li>\n<li><code>yum install htop -y</code></li>\n</ol>\n<p><code>kill</code> 终止某个进程</p>\n<ul>\n<li><code>kill PID ...</code> 结束进程ID</li>\n<li><code>kill -9 PID</code> 立即结束进程；<code>-9</code> 是一个命令参数</li>\n</ul>\n<p><code>halt</code> 关闭系统</p>\n<p><code>reboot</code> 重启系统</p>\n<p><code>shutdown</code> 执行重启、关机等操作</p>\n<p><code>poweroff</code> 关机，普通用户也可以使用</p>\n<p><code>&amp;</code> 命令结束加 <code>&amp;</code>，可以让进程在后台运行，终端关闭进程就会关闭</p>\n<ul>\n<li><code>find tom &amp;</code> 在后台搜索，可以继续输入命令</li>\n</ul>\n<p><code>nohup</code> 进程与终端分离，关闭终端也不会终止进程 <em><code>no hangup</code></em></p>\n<p><code>bg</code> 将前台进程或后台暂停的进程转至后台运行，或将最近一次转到后台运行的程序转至前台运行</p>\n<p><code>fg</code> 将后台进程转至前台运行</p>\n<p><code>jobs</code> 查看后台信息</p>\n<p>进程状态：</p>\n<ol>\n<li><code>r</code> 运行中</li>\n<li><code>s</code> 休眠中，终端</li>\n<li><code>d</code> 不可终端</li>\n<li><code>z</code> 僵死</li>\n<li><code>t</code> 停止</li>\n</ol>\n<h3>远程登录</h3>\n<p><code>ssh</code> 可以远程登录主机</p>\n<ul>\n<li><code>ssh root@192.169.0.100</code> 登录主机名为 <code>192.168.0.100</code> 的主机，用户名为 <code>root</code>，也就是登录 <code>root</code> 用户，之后会要求输入密码验证</li>\n</ul>\n<p>配置客户机的 <code>ssh</code> 配置，可以方便的登录主机：</p>\n<ol>\n<li>\n<p>打开 <code>~/.ssh/</code> 目录下 <code>config</code> 文件；如果没有可以新建 <code>config</code>；如果没有 <code>.ssh</code> 目录，可以执行 <code>ssh localhost</code> 生成</p>\n</li>\n<li>\n<p>配置主机信息：</p>\n<pre><code>Host serverName\n  HostName 192.168.0.100\n  Post 22\n  User root\n</code></pre>\n</li>\n<li>\n<p>配置保存后，执行 <code>ssh serverName</code> 就可以自动连接主机 <code>roor</code> 账户了</p>\n</li>\n</ol>\n<h3>免密登录</h3>\n<p>通过设置秘钥可以实现免密登录：</p>\n<ol>\n<li>生成本地秘钥：<code>ssh-keygen</code>；相当于：<code>ssh-keygen -t rsa</code>，公钥秘钥默认生成在 <code>~/.ssh/</code> 目录下</li>\n<li>将公钥传输到服务器：<code>ssh-copy-id root@192.168.0.100</code>，然后输入主机密码即可。这个命令相当于执行了 <code>ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.0.100</code>，作用是将本机公钥追加到服务器的 <code>~/.ssh/authorized_keys</code> 文件中，在登录时进行验证。</li>\n<li>设置完毕直接登录主机 <code>ssh root@192.168.0.100</code> 就可以免密码登录主机了</li>\n</ol>\n<blockquote>\n<p>设置了免密登录后使用密码登录：<code>ssh -o PreferredAuthentications=password -o PubkeyAuthentication=no root@192.168.0.100</code></p>\n</blockquote>\n<h2>快捷键</h2>\n<p><code>ctrl+d</code> 给终端传递 <em><code>EOF(end of file)</code></em>，退出终端或账号</p>\n<p><code>ctrl+l</code> 清屏</p>\n<p><code>ctrl+a</code> 光标跳转命令开头</p>\n<p><code>ctrl+e</code> 光标跳转命令结尾</p>\n<p><code>ctrl+u</code> 删除光标左侧所有字符</p>\n<p><code>ctrl+k</code> 删除光标右侧所有字符</p>\n<p><code>ctrl+w</code> 删除光标左侧的一个单词</p>\n<p><code>ctrl+y</code> 粘贴 <code>ctrl+u</code> <code>ctrl+k</code> <code>ctrl+w</code> 删除的内容</p>\n<p><code>ctrl+c</code> 终止当前程序</p>\n<p><code>ctrl+z</code> 将进程转到后台挂起，暂停运行</p>\n<h2>系统文件目录摘要</h2>\n<p><code>/</code> 表示根目录</p>\n<p><code>.</code> 表示当前目录</p>\n<p><code>..</code> 表示上一级目录</p>\n<p><code>~</code> 当前用户的 <code>home</code> 目录</p>\n<p><code>/bin</code> 存放二进制文件 <em><code>binary</code></em></p>\n<p><code>/sbin</code> 存放系统二进制文件，包含重要的可执行程序    <em><code>system bin</code></em></p>\n<p><code>/boot</code> 系统启动相关文件的目录</p>\n<p><code>/dev</code> 保存了外设与驱动器文件的目录 <em><code>device</code></em></p>\n<p><code>/etc</code> 存放了一些配置文件与其他零零碎碎的文件</p>\n<p><code>/home</code> 用户的私人目录</p>\n<p><code>/lib</code> 程序调用的库文件  <em><code>library</code></em></p>\n<p><code>/media</code> 访问外设媒体的目录</p>\n<p><code>/mnt</code> 临时挂载一些装置 <em><code>mount</code></em></p>\n<p><code>/opt</code> 表示可选的应用软件包，用于安装第三方软件及插件 <em><code>optional application software package</code></em></p>\n<p><code>/root</code> 超级用户的 <code>home</code> 目录</p>\n<p><code>/srv</code>  网络服务相关的目录 <em><code>service</code></em></p>\n<p><code>/tmp</code> 临时文件存放的目录</p>\n<p><code>/usr</code> 操作系统软件资源，这里有用户大量要调用的程序 <em><code>Unix software resource</code></em></p>\n<p><code>/var</code>  包含程序的数据日志记录文件等 <em><code>variable</code></em></p>\n<ul>\n<li><code>*.log</code> 日志记录文件</li>\n</ul>\n<h2>linux的软件</h2>\n<h3>软件与源</h3>\n<p>因为linux是一个开源的系统，他都软件也都是开源的，世界上有许多个服务器作为软件仓库存放了linux的软件可供使用，我们可以切换任意的<a href="https://www.centos.org/download/mirrors/">仓库源</a>去下载。</p>\n<p><code>/ect/yum.repos.d/CentOS-Base.repo</code>  这个文件配置了仓库的地址，为了达到更快的下载速度，我们可以找到国内比较好的源来替换这个文件：</p>\n<p>阿里巴巴：https://developer.aliyun.com/mirror/centos?spm=a2c6h.13651102.0.0.3e221b11BPhjUY</p>\n<p>华为：https://mirrors.huaweicloud.com/</p>\n<p>网易：<a href="http://mirrors.163.com/.help/centos.html">http://mirrors.163.com/.help/centos.html</a></p>\n<p>清华大学：https://mirrors.tuna.tsinghua.edu.cn/help/centos/</p>\n<h3>使用yum管理软件</h3>\n<p><code>yum</code> 是linux的包管理工具，可以方便的下载、卸载和更新系统软件包</p>\n<p><code>yum update</code> 和 <code>yum updrade</code> 可以更新本地安装的软件，<code>upgrade</code> 会删除原有的软件包再更新</p>\n<p><code>yum update &lt;pkg-name&gt;</code> 更新指定软件包</p>\n<p><code>yum search &lt;pkg-name&gt;</code> 搜索软件包</p>\n<p><code>yum install &lt;pkg-name&gt;</code> 安装软件包</p>\n<p><code>yum remove &lt;pkg-name&gt;</code> 删除软件包</p>\n<p>也可以下载 <code>.rpm</code> 格式的软件包，用 <code>rpm</code> 命令本地安装：</p>\n<p><code>rpm -i &lt;pkg-name.rpm&gt;</code> 安装本地软件包</p>\n<p>还可以用 <code>yum</code> 命令安装：</p>\n<p><code>yum localinstall &lt;pkg-name.rpm&gt;</code></p>\n<p><code>rpm -e &lt;pkg-name&gt;</code> 卸载包</p>\n<h2>使用手册</h2>\n<ol>\n<li>\n<p><code>man</code> 命令可以阅读手册获取帮助信息 <code>manual</code></p>\n<p>安装手册 <code>yum install man-pages</code></p>\n<p>更新手册 <code>mandb</code></p>\n<p>查询命令手册 <code>man &lt;command&gt;</code></p>\n</li>\n<li>\n<p>大多数命令的 <code>--help</code> 参数可以获取简要的帮助信息</p>\n<p>查看命令的帮助信息 <code>ls --help</code></p>\n</li>\n<li>\n<p><code>wathis &lt;command&gt;</code> 获取一个命令的简要信息</p>\n</li>\n<li>\n<p>在不知道命令是什么的时候，可以搜索关键字来查找命令：<code>apropos &lt;keyword&gt;</code></p>\n</li>\n</ol>\n',wordCount:13284}},"7K+T":function(s,n){s.exports={info:{title:"chrome extension",poster:"static/chrome_icon.png",date:"2019-04-03",id:"2019-04-03",desc:"教你 chrome extension 入门"},content:'<h2>介绍</h2>\n<p>Chrome Extension 是 Chrome 的扩展程序，也就是大家常说的「插件」。</p>\n<p><code>扩展程序</code> 本质上其实是网页，开发者运用 web 技术，并基于 <a href="https://developers.chrome.com/extensions/api_index">Chrome Extension API</a> 来增强 Chrome 的能力，实现诸如控制网络请求、自定义右键菜单、管理书签、在页面中插入 CSS 与 JavaScript、主题美化、定制主页等功能。</p>\n<p><a href="https://chrome.google.com/webstore/category/extensions">Chrome webstore</a> 上聚集了大量优秀的插件、主题、应用，你可以使用并且自己开发。</p>\n<p>Chrome Extension 一般有多种类型，大致有插件类、主题类、APP类：</p>\n<img src="/static/google-translate_icon.png" width="50"/>\n<img src="/static/theme_icon.png" width="55"/>\n<img src="/static/postman_icon.png" width="50"/>\n<h2>组成</h2>\n<p>Chrome Extension 的几个重要组成部分:</p>\n<ol>\n<li>\n<p><code>manifest.json</code>  扩展程序的组成清单</p>\n<p><code>manifest.json</code> 这个文件定义了扩展程序的方方面面，就像你的身份证、户口本一样，这个我们等下介绍它</p>\n</li>\n<li>\n<p><code>background script</code>  后台运行脚本</p>\n<p><code>background script</code> 可以在后台一直运行，用来监听各种事件、响应用户的操作</p>\n</li>\n<li>\n<p><code>content script</code>  注入页面脚本</p>\n<p><code>content script</code> 可以将脚本注入进页面中，用来对页面进行修改</p>\n</li>\n<li>\n<p><code>popup page</code>  侧边栏按钮弹窗</p>\n<p><code>popup page</code> 用来展示工具栏中图标按钮点击后出现的弹窗</p>\n</li>\n</ol>\n<p>我们常见的主要功能就是这些啦</p>\n<h3>manifest.json</h3>\n<p><code>manifest.json</code> 是描述插件的清单文件，包含了扩展程序的大部分信息：</p>\n<pre><code class="hljs" lang="json">{\n  <span class="hljs-attr">"manifest_version"</span>: <span class="hljs-number">2</span>,  // 扩展标准\n  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"插件的名称"</span>,\n  <span class="hljs-attr">"version"</span>: <span class="hljs-string">"0.0.1"</span>,\n  <span class="hljs-attr">"description"</span>: <span class="hljs-string">"插件的描述"</span>,\n  <span class="hljs-attr">"icons"</span>: {\n    <span class="hljs-attr">"16"</span>: <span class="hljs-string">"imgs/icons-16.png"</span>,  // 扩展程序页面上的图标\n    <span class="hljs-attr">"32"</span>: <span class="hljs-string">"imgs/icons-32.png"</span>,  // windows计算机通常需要此大小，防止失真\n    <span class="hljs-attr">"48"</span>: <span class="hljs-string">"imgs/icons-48.png"</span>,  // 显示在扩站程序管理页面上\n    <span class="hljs-attr">"128"</span>: <span class="hljs-string">"imgs/icons-128.png"</span>  // 在安装和chrome webstore中显示\n  },\n  <span class="hljs-attr">"background"</span>: {\n    <span class="hljs-attr">"page"</span>: <span class="hljs-string">"background.html"</span>,\n    <span class="hljs-attr">"scripts"</span>: [<span class="hljs-string">"background.js"</span>],\n    <span class="hljs-attr">"persistent"</span>: <span class="hljs-literal">false</span>\n  },\n  <span class="hljs-attr">"browser_action"</span>: {\n    <span class="hljs-attr">"default_icon"</span>: <span class="hljs-string">"imgs/icon.png"</span>,\n    <span class="hljs-attr">"default_title"</span>: <span class="hljs-string">"悬浮在工具栏插件图标时的tooltip内容"</span>,\n    <span class="hljs-attr">"default_popup"</span>: <span class="hljs-string">"popup.html"</span>  // 不允许内联 javascript\n  },\n  <span class="hljs-attr">"content_scripts"</span>: [{\n    <span class="hljs-attr">"js"</span>: [<span class="hljs-string">"inject.js"</span>],\n    <span class="hljs-attr">"matches"</span>: [<span class="hljs-string">"http://*/*"</span>, <span class="hljs-string">"https://*/*"</span>],\n    <span class="hljs-attr">"run_at"</span>: <span class="hljs-string">"document_start"</span>\n  }],\n  <span class="hljs-attr">"permissions"</span>: [\n    <span class="hljs-string">"contextMenus"</span>,\n    <span class="hljs-string">"tabs"</span>\n  ],\n  <span class="hljs-attr">"web_accessible_resources"</span>: [<span class="hljs-string">"dist/*"</span>, <span class="hljs-string">"dist/**/*"</span>]\n}\n</code></pre>\n<ul>\n<li>\n<p><code>manifest_version</code> 是扩展程序的清单文件格式的版本，从 <code>chrome18</code> 开始，都应指定为 <code>2</code></p>\n</li>\n<li>\n<p><code>name</code> 就是这个扩展程序的名字</p>\n</li>\n<li>\n<p><code>version</code> 是当前发布的版本，每一次发布都应该更新版本</p>\n</li>\n<li>\n<p><code>description</code> 是对扩展程序的描述，这个描述会在 chrome 应用商店的扩展程序主页显示</p>\n</li>\n<li>\n<p><code>icons</code> 定义了在各个地方展示的图标</p>\n</li>\n<li>\n<p><code>background</code> 可以理解为后台运行的脚本，与浏览器打开的页面不存才关联</p>\n</li>\n<li>\n<p><code>browser_action</code> 定义了浏览器工具栏上的表现行为</p>\n</li>\n<li>\n<p><code>content_script</code> 是一个独立插入页面的脚本，可以获取 <code>window</code>、<code>DOM</code> 元素，并且不会与页面中的命名空间发生冲突</p>\n</li>\n<li>\n<p><code>permissions</code> chrome extension 提供了很多 <code>api</code>，在 <code>background</code> 中使用 <code>api</code> 需要事先定义</p>\n</li>\n<li>\n<p><code>web_accessible_resources</code> 可以授予访问其他资源的权限，比如你的 <code>css</code>、<code>js</code> 库</p>\n</li>\n</ul>\n<h2>开始我们的第一款插件</h2>\n<p>我们创建一个文件夹 <code>my-plugin</code>，作为我们的项目。</p>\n<p>先在根目录创建一个 manifest.json 文件:</p>\n<pre><code class="hljs" lang="json">{\n  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"my-plugin"</span>,\n  <span class="hljs-attr">"version"</span>: <span class="hljs-string">"0.0.1"</span>,\n  <span class="hljs-attr">"manifest_version"</span>: <span class="hljs-number">2</span>\n}\n</code></pre>\n<blockquote>\n<p>Chrome 规定了一个 Chrome Extension 只允许包含一个 manifest.json 文件</p>\n</blockquote>\n<p>配置一个这样的清单文件就可以创建出一个扩展啦，就是这么简单粗暴。</p>\n<p>但是它现在什么功能都没有，什么都做不了，我们现在来加一些东西上去。</p>\n<p>首先，我们可以为插件添加一个 icon:</p>\n<pre><code class="hljs" lang="json">{\n  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"my-plugin"</span>,\n  <span class="hljs-attr">"version"</span>: <span class="hljs-string">"0.0.1"</span>,\n  <span class="hljs-attr">"manifest_version"</span>: <span class="hljs-number">2</span>,\n  <span class="hljs-attr">"icons"</span>: {\n    <span class="hljs-attr">"16"</span>: <span class="hljs-string">"imgs/icon16.png"</span>,\n    <span class="hljs-attr">"32"</span>: <span class="hljs-string">"imgs/icon32.png"</span>,\n    <span class="hljs-attr">"48"</span>: <span class="hljs-string">"imgs/icon48.png"</span>,\n    <span class="hljs-attr">"128"</span>: <span class="hljs-string">"imgs/icon128.png"</span>\n  }\n}\n</code></pre>\n<p>你可以添加任何喜欢的图标，只需要配置 <code>icons</code> 选项即可。</p>\n<p>这里定义四种规格的图标，分别会作用在工具栏、插件管理页、插件商店等地方。</p>\n<p>一般扩展程序在浏览器上的表现分为两种：</p>\n<ol>\n<li><code>browser_action</code> 适用于任何页面的扩展 （例如 Google 翻译）</li>\n<li><code>page_action</code> 作用于某一页面的扩展（例如 Vue.js devtools）</li>\n</ol>\n<p>接下来我们创建一个常见的工具栏弹窗，在 <code>browser_action</code> 中定义:</p>\n<pre><code class="hljs" lang="json">{\n  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"my-plugin"</span>,\n  <span class="hljs-attr">"version"</span>: <span class="hljs-string">"0.0.1"</span>,\n  <span class="hljs-attr">"manifest_version"</span>: <span class="hljs-number">2</span>,\n  <span class="hljs-attr">"icons"</span>: {\n    <span class="hljs-attr">"16"</span>: <span class="hljs-string">"imgs/icon16.png"</span>,\n    <span class="hljs-attr">"32"</span>: <span class="hljs-string">"imgs/icon32.png"</span>,\n    <span class="hljs-attr">"48"</span>: <span class="hljs-string">"imgs/icon48.png"</span>,\n    <span class="hljs-attr">"128"</span>: <span class="hljs-string">"imgs/icon128.png"</span>\n  },\n  <span class="hljs-attr">"browser_action"</span>: {\n    <span class="hljs-attr">"default_icon"</span>: <span class="hljs-string">"imgs/icon.png"</span>,\n    <span class="hljs-attr">"default_title"</span>: <span class="hljs-string">"hello chrome"</span>,\n    <span class="hljs-attr">"default_popup"</span>: <span class="hljs-string">"popup.html"</span>\n  }\n}\n</code></pre>\n<p>我们现在设定插件作用于任何页面：使用 <code>browser_action</code> 选项，popup 需要指定一个 <code>html</code> 文件：</p>\n<pre><code class="hljs" lang="html"><span class="hljs-comment">&lt;!-- popup.html --&gt;</span>\n<span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>my-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">\n      <span class="hljs-selector-tag">body</span> { <span class="hljs-attribute">width</span>: <span class="hljs-number">65px</span>; }\n    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn"</span>\n      <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span>\n      <span class="hljs-attr">value</span>=<span class="hljs-string">"click me!"</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"popup.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>\n</code></pre>\n<p>在这里要注意：<code>popup html</code> 文件是不可以内联书写 <code>javscript</code> 的，也就是说只能使用 <code>script</code> 标签来引用外部的 <code>javascript</code> 脚本，所以我们还需定义一个 <code>popup.js</code>。</p>\n<pre><code class="hljs" lang="js"><span class="hljs-comment">// popup.js</span>\n<span class="hljs-keyword">const</span> btnEle = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">\'.btn\'</span>)\nbtnEle.onclick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n  alert(<span class="hljs-string">\'hello chrome!\'</span>)\n}\n</code></pre>\n<p>点击按钮弹出 <code>hello chrome!</code>，好了，我们迫不及待想要看看效果了！</p>\n<h3>调试</h3>\n<p>想要看到效果，我们需要把插件先装到 chrome 上：</p>\n<p>菜单中找到扩展程序入口：</p>\n<p><img src="/static/install-chrome-plugin-1.png" alt="install-chrome-plugin-1"></p>\n<p>右上角开启开发者模式：</p>\n<p><img src="/static/install-chrome-plugin-2.png" alt="install-chrome-plugin-2"></p>\n<p>点击 <code>加载已解压的扩展程序</code> 选择 <code>my-plugin</code> 项目：</p>\n<p><img src="/static/install-chrome-plugin-3.png" alt="install-chrome-plugin-3"></p>\n<p><img src="/static/install-chrome-plugin-4.png" alt="install-chrome-plugin-4"></p>\n<p>这样就添加到了插件管理页：</p>\n<p><img src="/static/install-chrome-plugin-5.png" alt="install-chrome-plugin-5"></p>\n<p>这时浏览器工具栏就会出现刚刚添加的插件，图标时自定义的：</p>\n<p><img src="/static/install-chrome-plugin-6.png" alt="install-chrome-plugin-6"></p>\n<p>点击插件图标，会显示 <code>popup.html</code> 页面：</p>\n<p><img src="/static/install-chrome-plugin-7.png" alt="install-chrome-plugin-7"></p>\n<p>click me!</p>\n<p><img src="/static/install-chrome-plugin-8.png" alt="install-chrome-plugin-8"></p>\n<h3>与页面交互</h3>\n<p>我们现在只能在页面外做动作，怎样与页面交互呢？</p>\n<p>前面说到 <code>content_script</code> 可以拿到浏览器当前打开页面的资源，这样我们就可以获取到 <code>window</code> 以及 <code>DOM</code>，并可以修改和插入 <code>html</code>、<code>css</code>、<code>js</code>。</p>\n<p>在 <code>manifest.json</code> 中配置 <code>content_script</code>：</p>\n<pre><code class="hljs" lang="json">{\n  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"my-plugin"</span>,\n  <span class="hljs-attr">"version"</span>: <span class="hljs-string">"0.0.1"</span>,\n  <span class="hljs-attr">"manifest_version"</span>: <span class="hljs-number">2</span>,\n  <span class="hljs-attr">"icons"</span>: {\n    <span class="hljs-attr">"16"</span>: <span class="hljs-string">"imgs/icon16.png"</span>,\n    <span class="hljs-attr">"32"</span>: <span class="hljs-string">"imgs/icon32.png"</span>,\n    <span class="hljs-attr">"48"</span>: <span class="hljs-string">"imgs/icon48.png"</span>,\n    <span class="hljs-attr">"128"</span>: <span class="hljs-string">"imgs/icon128.png"</span>\n  },\n  <span class="hljs-attr">"browser_action"</span>: {\n    <span class="hljs-attr">"default_icon"</span>: <span class="hljs-string">"imgs/icon.png"</span>,\n    <span class="hljs-attr">"default_title"</span>: <span class="hljs-string">"hello chrome"</span>,\n    <span class="hljs-attr">"default_popup"</span>: <span class="hljs-string">"popup.html"</span>\n  },\n  <span class="hljs-attr">"content_scripts"</span>: [{\n    <span class="hljs-attr">"js"</span>: [<span class="hljs-string">"inject.js"</span>],\n    <span class="hljs-attr">"matches"</span>: [\n      <span class="hljs-string">"http://*/*"</span>,\n      <span class="hljs-string">"https://*/*"</span>\n    ]\n  }]\n}\n</code></pre>\n<ul>\n<li><code>js</code> 字段定义了需要加载的js脚本文件，这里是一个数组，所以脚本文件会按找数组顺序注入，如果我们的程序需要依赖于第三方库，就可以先注入他们。</li>\n<li><code>matches</code> 可以让你选择这些脚本在页面匹配到什么样的 <code>URI</code> 时被注入，以此来实现更复杂的功能。</li>\n</ul>\n<p>我们定义一个叫 <code>inject.js</code> 的文件，还是老套路，打印 <code>hello chrome</code> 或者你可以删掉某个 <code>DOM</code> 试试看：</p>\n<pre><code class="hljs" lang="js"><span class="hljs-comment">// inject.js</span>\nalert(<span class="hljs-string">\'hello chrome\'</span>)\n</code></pre>\n<p>此时随便打开一个 <code>http(s)://**/*</code> 页面时， chrome 就会帮我们注入 <code>inject.js</code> 到页面中并执行：</p>\n<p><img src="/static/install-chrome-plugin-9.png" alt="install-chrome-plugin-9"></p>\n<p>随便打开一个页面，弹窗就出来了（不要这样做哦）。</p>\n<h3>一个全局的后台脚本 background</h3>\n<p>有些时候，我们在不同页面都需要出发一些事件、统一处理操作等，就需要一个全局的脚本在运行，这就是 <code>background script</code> 的作用。</p>\n<p>我们再来新建一个 <code>background.js</code> 并注册在 <code>manifest.json</code> 里：</p>\n<pre><code class="hljs" lang="js"><span class="hljs-comment">// background.js</span>\n<span class="hljs-keyword">let</span> timeout = <span class="hljs-number">10000</span>\n<span class="hljs-built_in">window</span>.setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n  alert(<span class="hljs-string">\'hello chrome!\'</span>)\n}, timeout)\n</code></pre>\n<pre><code class="hljs" lang="json">{\n  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"my-plugin"</span>,\n  <span class="hljs-attr">"version"</span>: <span class="hljs-string">"0.0.1"</span>,\n  <span class="hljs-attr">"manifest_version"</span>: <span class="hljs-number">2</span>,\n  <span class="hljs-attr">"icons"</span>: {\n    <span class="hljs-attr">"16"</span>: <span class="hljs-string">"imgs/icon16.png"</span>,\n    <span class="hljs-attr">"32"</span>: <span class="hljs-string">"imgs/icon32.png"</span>,\n    <span class="hljs-attr">"48"</span>: <span class="hljs-string">"imgs/icon48.png"</span>,\n    <span class="hljs-attr">"128"</span>: <span class="hljs-string">"imgs/icon128.png"</span>\n  },\n  <span class="hljs-attr">"browser_action"</span>: {\n    <span class="hljs-attr">"default_icon"</span>: <span class="hljs-string">"imgs/icon.png"</span>,\n    <span class="hljs-attr">"default_title"</span>: <span class="hljs-string">"hello chrome"</span>,\n    <span class="hljs-attr">"default_popup"</span>: <span class="hljs-string">"popup.html"</span>\n  },\n  <span class="hljs-attr">"content_scripts"</span>: [{\n    <span class="hljs-attr">"js"</span>: [<span class="hljs-string">"inject.js"</span>],\n    <span class="hljs-attr">"matches"</span>: [\n      <span class="hljs-string">"http://*/*"</span>,\n      <span class="hljs-string">"https://*/*"</span>\n    ]\n  }],\n  <span class="hljs-attr">"background"</span>: {\n    <span class="hljs-attr">"scripts"</span>: [<span class="hljs-string">"background.js"</span>],\n    <span class="hljs-attr">"persistent"</span>: <span class="hljs-literal">false</span>\n  }\n}\n</code></pre>\n<ul>\n<li><code>scripts</code> 用来注入我们的 <code>background.js</code>。</li>\n<li><code>persistent</code> 字段为 <code>true</code> 时会持续在后台运行；<code>false</code>，会在事件触发时被才唤醒。</li>\n</ul>\n<p>这里写了一个定时器，每过 <code>10</code> 秒就会打印 <code>hello chrome!</code>。</p>\n<p>到这个时候，你可能会疑问：这些脚本之间如何通信？</p>\n<h3>通信</h3>\n<p>接下来我们看看怎么通信，我们在 <code>inject.js</code> 中发送消息，怎么样在 <code>background.js</code> 中收到？</p>\n<p><code>chrome API</code> 中有一个 <code>sendMessage</code> 方法，可以发送消息，我们在 <code>inject.js</code> 这样写：</p>\n<pre><code class="hljs" lang="js"><span class="hljs-comment">// inject.js</span>\nchrome.runtime.sendMessage(\n  message,\n  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>{\n    <span class="hljs-comment">// do something...</span>\n  }\n)\n</code></pre>\n<p>这样就能向 <code>background.js</code> 发送消息了，<code>sendMessage</code> 方法的第一个参数 <code>message</code> 为发送的消息内容（基础数据类型），第二个参数是一个回调函数，回调函数的第一个参数为 <code>background scripts</code> 接收消息后返回的消息（如果有的话）。</p>\n<p>接下来只需在 <code>background.js</code> 中接收消息了：</p>\n<pre><code class="hljs" lang="js"><span class="hljs-comment">// background.js</span>\nchrome.runtime.onMessage.addListener(\n  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">request, sender, sendResponse</span>) </span>{\n    sendResponse(<span class="hljs-string">"It\'s "</span> + request)\n  }\n)\n</code></pre>\n<p><code>addListener</code> 方法可以监听到发来的消息，第一个参数 <code>request</code> 表示发来消息的内容，第三个参数 <code>sendResponse</code> 是一个函数，用于对消息进行回应，如 <code>sendResponse(\'我已收到你的消息：\'+JSON.stringify(request))</code>。</p>\n<h3>发布</h3>\n<p>当我们完成了插件所有的功能后，就可以发布插件啦~</p>\n<p>进入<a href="https://chrome.google.com/webstore/category/extensions">chrome 扩展程序商店</a>,右上角菜单中点击<code>开发者信息中心</code>，点击 <code>添加新内容</code>：</p>\n<p><img src="/static/publish-chrome-plugin-1.png" alt="publish-chrome-plugin-1"></p>\n<p>上传插件的压缩文件：</p>\n<p><img src="/static/publish-chrome-plugin-3.png" alt="publish-chrome-plugin-3"></p>\n<p><img src="/static/publish-chrome-plugin-2.png" alt="publish-chrome-plugin-2"></p>\n<p>填写插件信息、上传预览图后，就可以发布更改了</p>\n<p><img src="/static/publish-chrome-plugin-4.png" alt="publish-chrome-plugin-4"></p>\n<h2>参考资料:</h2>\n<ol>\n<li>https://welearnmore.gitbook.io/chrome-extension-book/</li>\n<li>https://juejin.im/post/5c135a275188257284143418#heading-10</li>\n<li>http://www.dahouduan.com/2017/08/12/make-chrome-extension/</li>\n</ol>\n',wordCount:8219}},"7afm":function(s,n){s.exports={info:{title:"对 javascript 执行环境的探索",poster:"/static/poster.png",date:"2018-06-08",id:"2018-06-08",desc:"执行上下文 执行环境 作用域 作用域链 函数调用栈 执行队列 执行上下文队列 变量对象 活动对象 解析器interpreter 声明declared"},content:'<blockquote>\n<p>执行上下文 执行环境 作用域 作用域链 函数调用栈 执行队列 执行上下文队列 变量对象 活动对象 解析器interpreter 声明declared\n执行上下文是动态的，作用域是静态的，两者是不一样的</p>\n</blockquote>\n<blockquote>\n<p>函数的执行环境会在调用时才创建，不同的调用方式(比如call、apply)执行环境也会不同，也就是说一个函数的执行环境不是固定的，是可能会变的，执行环境的改变会导致this指向的改变；而函数作用域是在定义函数时就确定了，全局就是全局的，局部就是局部的，不会再改变了，如果这个函数被赋值给一个变量或对象的方法后(函数在其他地方被引用)，函数调用者就不一定是之前的了，所以函数中的this会发生变化，但是函数内变量查找的规则还是会<strong>回到</strong>这个函数体被定义的地方根据作用域链向上查找</p>\n</blockquote>\n<h2>执行上下文(执行环境) Execution Context</h2>\n<p><strong>执行上下文</strong>可以理解为当前代码所运行在的环境与范围（并不是<strong>作用域</strong>），分为以下三种：</p>\n<h3>全局上下文</h3>\n<p>全局上下文是代码运行时第一时间会进入的默认执行环境</p>\n<ul>\n<li><strong>浏览器</strong>中的全局上下文指 <code>window</code> 对象</li>\n<li><strong>nodejs</strong>中的全局上下文指 <code>global</code> 对象</li>\n</ul>\n<h3>函数上下文</h3>\n<p>函数 <code>function</code> 或方法 <code>method</code> 在调用时所在的执行环境。</p>\n<pre><code class="hljs" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHello</span> (<span class="hljs-params">name</span>) </span>{\n  <span class="hljs-keyword">return</span> <span class="hljs-string">\'hello \'</span> + name\n}\nsayHello()\n\n<span class="hljs-keyword">const</span> person = {\n  <span class="hljs-attr">name</span>: <span class="hljs-string">\'tom\'</span>,\n  say () {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'I am \'</span> + <span class="hljs-keyword">this</span>.name)\n  }\n}\nperson.say()\n</code></pre>\n<h3>eval上下文</h3>\n<p><code>eval()</code> 函数创建的执行环境。</p>\n<pre><code class="hljs" lang="javascript"><span class="hljs-built_in">eval</span>(<span class="hljs-string">\'console.log("in eval")\'</span>)\n</code></pre>\n<h2>函数调用栈(执行上下文栈) Execution Stack</h2>\n<p>首先浏览器中的javascript引擎是单线程，所有的事件和行为都在一个栈结构中储存与调用。</p>\n<ol>\n<li>\n<p>js代码开始执行时，首先会进入到 <strong>全局上下文</strong>，全局上下文总是存在于函数调用栈的最底部。</p>\n</li>\n<li>\n<p>当在全局调用一个 <strong>函数</strong> 时，执行流程会进入到当前函数内，js引擎会创建一个新的函数执行上下文，压入函数调用栈顶部，位于全局上下文之上，并且调用栈(在内存资源充足的情况下)可以压入无限个函数执行上下文。</p>\n</li>\n<li>\n<p>此时如果在一个 <strong>函数内调用了另一个函数</strong> ，执行流程便进入被调用的函数，并创建新的执行上下文，将它压入函数调用栈的顶部，调用栈的顶部此时已是新创建的执行上下文，在函数执行完毕时，执行上下文在没有被引用的情况下(被引用会有闭包的问题)，js引擎会将它从调用栈中弹出，并将控制权返回给之前的执行上下文。</p>\n</li>\n</ol>\n<h2>执行上下文的创建</h2>\n<p>执行上下文的创建可以分为创建和执行两个阶段：</p>\n<h3>创建阶段</h3>\n<p>在执行代码之前会先创建执行上下文：</p>\n<ol>\n<li>初始化作用域链</li>\n<li>创建变量对象\n<ul>\n<li>收集函数的参数</li>\n<li>声明函数，并指向函数的引用</li>\n<li>声明局部变量，并初始化为 <code>undefined</code></li>\n</ul>\n</li>\n<li>确定 <code>this</code> 的指向</li>\n</ol>\n<h3>执行阶段</h3>\n<p>执行代码，进行变量赋值、流程控制、函数调用等操作</p>\n<p>执行上下文创建示意：</p>\n<pre><code class="hljs" lang="javascript">execytionContext = {\n  <span class="hljs-string">\'scopeChain\'</span>: [\n    <span class="hljs-comment">// 当前执行环境的变量对象variableObject</span>\n    <span class="hljs-comment">// 栈中所有父级执行环境的变量对象</span>\n  ],\n  <span class="hljs-string">\'variableObject\'</span>: {\n    <span class="hljs-comment">// 函数参数</span>\n    <span class="hljs-comment">// 函数声明</span>\n    <span class="hljs-comment">// 变量声明</span>\n  },\n  <span class="hljs-string">\'this\'</span>: {}\n};\n</code></pre>\n<h2>创建变量对象</h2>\n<p>为了我们可以使用到当前上下文中声明的所有变量，在生成执行上下文时，js引擎会进行预解析，创建 <strong>变量对象 <code>variable object</code></strong> 来保存所有信息。</p>\n<p>变量对象的创建包括以下几个步骤：</p>\n<h3>1. 初始化变量对象与函数参数</h3>\n<p>创建 <strong>函数参数对象 <code>arguments object</code></strong>，检查参数的上下文，初始化参数的变量名和值，并将它们拷贝一份</p>\n<p>这里导致了参数中的变量会在 <code>var</code> <code>let</code> <code>const</code> <code>function</code> 等主动声明的变量之前被创建，值为参数传入了值，如果未传入参数，默认为 <code>undefined</code>：</p>\n<pre><code class="hljs" lang="JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params">arg</span>) </span>{\n  <span class="hljs-built_in">console</span>.log(arg);\n};\nfoo();  <span class="hljs-comment">// undefined</span>\nfoo(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 1</span>\n</code></pre>\n<pre><code class="hljs" lang="JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params">arg</span>) </span>{\n  <span class="hljs-built_in">console</span>.log(arg); <span class="hljs-comment">// 这里打印有值，也证明了函数或变量在执行代码前会先提升声明</span>\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">arg</span> (<span class="hljs-params"></span>) </span>{}; <span class="hljs-comment">// 覆盖掉了参数arg</span>\n};\nfoo();  <span class="hljs-comment">// ƒ arg() {}</span>\nfoo(<span class="hljs-number">1</span>);  <span class="hljs-comment">// ƒ arg() {}</span>\n</code></pre>\n<pre><code class="hljs" lang="JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params">arg</span>) </span>{ <span class="hljs-comment">// 这里会先声明一次</span>\n  <span class="hljs-keyword">let</span> arg; <span class="hljs-comment">// 声明第二次就会报错</span>\n};\nfoo(); <span class="hljs-comment">// Identifier \'arg\' has already been declared</span>\n</code></pre>\n<pre><code class="hljs" lang="JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params">arg, arg=<span class="hljs-number">1</span></span>) </span>{ <span class="hljs-comment">// 声明两次并赋予默认值时会报错</span>\n  <span class="hljs-built_in">console</span>.log(arg);\n};\n<span class="hljs-comment">// Uncaught SyntaxError: Duplicate parameter name not allowed in this context</span>\n</code></pre>\n<h3>2. 内部函数的声明</h3>\n<p>扫描上下文中的 <strong>函数声明</strong>，每找到一个函数声明，就在变量对象中创建一个同名属性，它保存了函数内存地址的引用，如果函数已存在，引用将会被覆盖：</p>\n<pre><code class="hljs" lang="JavaScript"><span class="hljs-built_in">console</span>.log(f);   <span class="hljs-comment">// 函数的声明被提前了，</span>\nf();              <span class="hljs-comment">// 在这里是可以访问到的。</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span> (<span class="hljs-params"></span>) </span>{\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"I\'m here!"</span>)\n};\n</code></pre>\n<pre><code class="hljs" lang="javascript">foo(); <span class="hljs-comment">// 2</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params"></span>) </span>{\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);\n};\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params"></span>) </span>{  <span class="hljs-comment">// 覆盖了上面已声明的同名函数</span>\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);\n};\n</code></pre>\n<h3>3. 局部变量的声明</h3>\n<p>函数声明结束后，才是变量的声明。</p>\n<p>扫描上下文中的 <strong>变量声明</strong>，每找到一个变量声明，就会在变量对象中创建一个属性，并将它初始化为 <code>undefined</code>，(这也就是为什么当我们声明一个变量后未赋值时，立即访问它会是 <code>undefined</code> 的原因)如果发现重新声明的变量，则会忽略它。</p>\n<pre><code class="hljs" lang="javascript"><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// undefined   声明在先，但还未赋值</span>\n<span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;      <span class="hljs-comment">// a被赋值为1</span>\n<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 1</span>\n</code></pre>\n<pre><code class="hljs" lang="JavaScript">a(); <span class="hljs-comment">// 2</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span> (<span class="hljs-params"></span>) </span>{log(<span class="hljs-number">1</span>)};  <span class="hljs-comment">// 函数声明</span>\na(); <span class="hljs-comment">// 2</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span> (<span class="hljs-params"></span>) </span>{log(<span class="hljs-number">2</span>)};  <span class="hljs-comment">// 函数声明</span>\na(); <span class="hljs-comment">// 2</span>\n<span class="hljs-keyword">var</span> a = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{log(<span class="hljs-number">3</span>)};  <span class="hljs-comment">// 这里的函数表达式是赋值操作，并不是函数声明，声明的只有变量a</span>\na(); <span class="hljs-comment">// 3</span>\n</code></pre>\n<p>值得注意的都是，<a href="http://es6.ruanyifeng.com/#docs/let"><code>let</code> <code>const</code></a> 关键字有声明变量的过程，但是在声明之前的区域都属于 <strong>“暂时性死区”</strong>，变量将不可访问，尝试访问会报错，这样更有利于规范的书写代码，避免产生不必要的错误：</p>\n<pre><code class="hljs" lang="JavaScript"><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 属于“暂时性死区”</span>\n<span class="hljs-keyword">let</span> a;\n<span class="hljs-comment">// Uncaught ReferenceError: a is not defined</span>\n</code></pre>\n<pre><code class="hljs" lang="javascript"><span class="hljs-keyword">typeof</span> a;\n<span class="hljs-keyword">let</span> a;\n<span class="hljs-comment">// Uncaught ReferenceError: a is not defined</span>\n</code></pre>\n<p>下面这个例子解释了当一个函数被调用时，变量对象在上下文中的变化：</p>\n<pre><code class="hljs" lang="JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">a, b</span>) </span>{\n  <span class="hljs-keyword">var</span> x = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{};\n  <span class="hljs-keyword">var</span> y = <span class="hljs-number">2</span>;\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{};\n};\nfoo(<span class="hljs-number">1</span>);\n\n<span class="hljs-comment">// 变量对象的初始化：</span>\nfooExecutionContext = {\n  <span class="hljs-attr">scopeChain</span>: { ... },\n  <span class="hljs-attr">variableObject</span>: {\n    <span class="hljs-attr">arguments</span>: {\n      <span class="hljs-number">0</span>: <span class="hljs-number">1</span>,\n      <span class="hljs-attr">length</span>: <span class="hljs-number">1</span>,\n      <span class="hljs-comment">// callee: ƒ foo(a, b),</span>\n      <span class="hljs-comment">// Symbol(Symbol.iterator): ƒ values(),</span>\n      <span class="hljs-comment">// __proto__: Object</span>\n    },\n    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,\n    <span class="hljs-attr">b</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-comment">// 未传入的参数不会被拷贝进arguments中</span>\n    f: pointer to ƒ f()\n    x: <span class="hljs-literal">undefined</span>,\n    <span class="hljs-attr">y</span>: <span class="hljs-literal">undefined</span>\n  },\n  <span class="hljs-attr">this</span>: <span class="hljs-built_in">window</span>\n}\n\n\n<span class="hljs-comment">// 代码执行后变量对象的变化：</span>\nfooExecutionContext = {\n  <span class="hljs-attr">scopeChain</span>: { ... },\n  <span class="hljs-attr">variableObject</span>: {\n    <span class="hljs-attr">arguments</span>: {\n      <span class="hljs-number">0</span>: <span class="hljs-number">1</span>,\n      <span class="hljs-attr">length</span>: <span class="hljs-number">1</span>,\n      <span class="hljs-comment">// callee: ƒ foo(a, b),</span>\n      <span class="hljs-comment">// Symbol(Symbol.iterator): ƒ values(),</span>\n      <span class="hljs-comment">// __proto__: Object</span>\n    },\n    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,\n    <span class="hljs-attr">b</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-comment">// 未传入的参数不会被拷贝进arguments中</span>\n    f: pointer to ƒ f()\n    x: ƒ (),\n    <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>\n  },\n  <span class="hljs-attr">this</span>: <span class="hljs-built_in">window</span>\n}\n</code></pre>\n<h2>this的指向</h2>\n<p>js现为止只有全局作用域与函数作用域两种，不同作用域中的 <code>this</code> 指向是不同的</p>\n<ul>\n<li>\n<p>首先 <strong>全局作用域</strong> 中的 <code>this</code> 永远指向的是全局对象，浏览器中为 <code>window</code>对象，nodejs中为 <code>global</code>对象</p>\n</li>\n<li>\n<p>而 <strong>函数作用域</strong> 中 <code>this</code> 的指向是在创建执行上下文时被确立的，默认指向的是调用此函数的对象，所以决定 <code>this</code> 指向的关键就是——<strong>函数是如何调用的</strong></p>\n</li>\n</ul>\n<p>函数的调用有多种情况：</p>\n<h3>全局函数调用</h3>\n<p>在<strong>全局作用域</strong>中调用函数时，并没有对象在调用这个函数，<code>this</code> 本会是 <code>undefined</code>，但是会默认隐式指向<strong>全局对象</strong>：</p>\n<pre><code class="hljs" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params"></span>) </span>{\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);\n};\nfoo(); <span class="hljs-comment">// Window {...}</span>\n</code></pre>\n<p>而使用了 <strong>严格模式 <code>&quot;use strict&quot;</code></strong> ，<code>this</code> 将会是被指定的值；如果未指定，它会是 <strong><code>undefine</code></strong>：</p>\n<pre><code class="hljs" lang="javascript"><span class="hljs-meta">\'use strict\'</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params"></span>) </span>{;\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);\n};\nfoo(); <span class="hljs-comment">// undefined</span>\n</code></pre>\n<blockquote>\n<p>在<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode#Securing_JavaScript">严格模式</a>下通过 <code>this</code> 传递给一个函数的值不会被强制转换为一个对象。对一个普通的函数来说，<code>this</code> 总会是一个对象：不管调用时 <code>this</code> 它本来就是一个对象；还是用布尔值，字符串或者数字调用函数时函数里面被封装成对象的 <code>this</code>；还是使用 <code>undefined</code> 或者 <code>null</code> 调用函数时this代表的全局对象（使用call, apply或者bind方法来指定一个确定的this）。这种自动转化为对象的过程不仅是一种性能上的损耗，同时在浏览器中暴露出全局对象也会成为安全隐患，因为全局对象提供了访问那些所谓安全的JavaScript环境必须限制的功能的途径。所以对于一个开启严格模式的函数，指定的 <code>this</code> 不再被封装为对象，而且如果没有指定 <code>this</code> 的话它值是 <code>undefined</code> ：</p>\n</blockquote>\n<pre><code class="hljs" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; };\n<span class="hljs-built_in">console</span>.log(fun()); <span class="hljs-comment">// Window{...}</span>\n<span class="hljs-built_in">console</span>.log(fun.call(<span class="hljs-number">2</span>)); <span class="hljs-comment">// Number {2}</span>\n<span class="hljs-built_in">console</span>.log(fun.apply(<span class="hljs-literal">null</span>)); <span class="hljs-comment">// Window {...}</span>\n<span class="hljs-built_in">console</span>.log(fun.call(<span class="hljs-literal">undefined</span>)); <span class="hljs-comment">// Window {...}</span>\n<span class="hljs-built_in">console</span>.log(fun.bind(<span class="hljs-literal">true</span>)()); <span class="hljs-comment">// Boolean {true}</span>\n</code></pre>\n<pre><code class="hljs" lang="javascript"><span class="hljs-meta">"use strict"</span>;\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; };\n<span class="hljs-built_in">console</span>.assert(fun() === <span class="hljs-literal">undefined</span>);\n<span class="hljs-built_in">console</span>.assert(fun.call(<span class="hljs-number">2</span>) === <span class="hljs-number">2</span>);\n<span class="hljs-built_in">console</span>.assert(fun.apply(<span class="hljs-literal">null</span>) === <span class="hljs-literal">null</span>);\n<span class="hljs-built_in">console</span>.assert(fun.call(<span class="hljs-literal">undefined</span>) === <span class="hljs-literal">undefined</span>);\n<span class="hljs-built_in">console</span>.assert(fun.bind(<span class="hljs-literal">true</span>)() === <span class="hljs-literal">true</span>);\n</code></pre>\n<h3>对象方法调用</h3>\n<p>函数在对象中通常叫做方法，调用一个对象的方法时，方法中的 <code>this</code> 指向的就是这个调用它的对象：</p>\n<pre><code class="hljs" lang="JavaScript"><span class="hljs-keyword">let</span> cat = {\n  <span class="hljs-attr">nickName</span>: <span class="hljs-string">\'meow\'</span>,\n  <span class="hljs-attr">say</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.nickName);\n  }\n};\ncat.say(); <span class="hljs-comment">// \'meow\'   this指向了cat对象，并可以访问对象的属性</span>\n</code></pre>\n<p>同样，在对象之外定义的函数被设置为对象的方法时，<code>this</code> 的指向会跟着转变：</p>\n<pre><code class="hljs" lang="JavaScript"><span class="hljs-keyword">var</span> nickName = <span class="hljs-string">\'zoo\'</span>; <span class="hljs-comment">// var会声明为全局对象中的属性</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">say</span> (<span class="hljs-params"></span>) </span>{\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.nickName);\n};\n<span class="hljs-keyword">let</span> dog = {\n  <span class="hljs-attr">nickName</span>: <span class="hljs-string">\'wang\'</span>,\n  say\n};\n<span class="hljs-keyword">let</span> cat = {\n  <span class="hljs-attr">nickName</span>: <span class="hljs-string">\'meow\'</span>,\n  say\n};\nsay();     <span class="hljs-comment">// \'zoo\'    this指向window</span>\ncat.say(); <span class="hljs-comment">// \'meow\'   this指向cat</span>\ndog.say(); <span class="hljs-comment">// \'wang\'   this指向dog</span>\n</code></pre>\n<h3>构造函数调用</h3>\n<p><code>new</code> 操作符将函数通过构造函数的形式调用，它会创建一个新对象来作为构造函数的实例，将构造函数中的 <code>this</code> 指向这个实例并隐式返这个实例：</p>\n<pre><code class="hljs" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Animal</span> (<span class="hljs-params">name</span>) </span>{\n  <span class="hljs-keyword">this</span>.name = name;  <span class="hljs-comment">// this指向实例</span>\n  <span class="hljs-keyword">this</span>.color = <span class="hljs-string">"white"</span>;\n  <span class="hljs-comment">// 隐式返回了实例</span>\n};\n<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> Animal(<span class="hljs-string">\'cat\'</span>));  <span class="hljs-comment">// 构造函数调用   {name: "cat", color: "white"}</span>\nAnimal(); <span class="hljs-comment">// 函数调用</span>\n</code></pre>\n<h3>使用 <code>call</code> <code>apply</code> <code>bind</code> 调用</h3>\n<p><code>call</code> <code>apply</code> <code>bind</code> 属于函数自身的方法，用以改变 <code>this</code> 的指向。</p>\n<ul>\n<li>\n<p><code>call</code> 传入参数为：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call#%E8%AF%AD%E6%B3%95">( thisArg, arg1, arg2, ... )</a>，第一个参数为指定函数 <code>this</code> 的值，以后的参数都为调用函数时传入的参数</p>\n</li>\n<li>\n<p><code>apply</code> 传入的参数为：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply#Syntax">( thisArg, [argsArray] )</a>，第一个参数为指定函数的 <code>this</code>，第二个参数是一个传入函数所有参数的类数组</p>\n</li>\n<li>\n<p><code>bind</code> 传入的参数为：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#%E8%AF%AD%E6%B3%95">( thisArg[, arg1[, arg2[, ...]]] )</a>，第一个参数为原函数 <code>this</code> 的绑定，后面的参数依次是传入原函数的参数，在调用绑定后的函数时传递过去；调用 <code>bind</code> 函数时并不会调用原函数，而是返回一个绑定了 <code>this</code> 和指定参数的原函数拷贝</p>\n</li>\n</ul>\n<blockquote>\n<p><code>thisArg</code> 为在函数运行时指定的 <code>this</code> 值。需要注意的是，指定的 <code>this</code> 值并不一定是该函数执行时真正的 <code>this</code> 值，如果这个函数处于<strong>非严格模式</strong>下，则指定为 <code>null</code> 和 <code>undefined</code> 的 <code>this</code> 值会自动指向全局对象(浏览器中就是window对象)，同时值为原始值(数字，字符串，布尔值)的 <code>this</code> 会指向该原始值的自动包装对象。</p>\n</blockquote>\n<pre><code class="hljs" lang="JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">a, b</span>) </span>{\n  <span class="hljs-built_in">console</span>.log(a);\n  <span class="hljs-built_in">console</span>.log(b);\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);\n};\nfoo.call(<span class="hljs-literal">undefined</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 1  2  Window {...}</span>\nfoo.apply(<span class="hljs-literal">null</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]);      <span class="hljs-comment">// 1  2  Window {...}</span>\nfoo.call(<span class="hljs-number">2</span>);         <span class="hljs-comment">// Number {2}</span>\nfoo.apply(<span class="hljs-literal">true</span>);         <span class="hljs-comment">// Boolean {true}</span>\n</code></pre>\n<p>apply传入带有 <code>length</code> 属性的对象时，会被识别为类数组，可以利用这一点创建指定长度的数组，每一项都是 <code>undefnied</code>：</p>\n<pre><code class="hljs" lang="JavaScript"><span class="hljs-built_in">Array</span>.apply(<span class="hljs-literal">null</span>, {<span class="hljs-attr">length</span>: <span class="hljs-number">5</span>});\n</code></pre>\n<pre><code class="hljs" lang="JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CreatePerson</span>(<span class="hljs-params">name, age</span>) </span>{\n  <span class="hljs-keyword">this</span>.name = name;\n  <span class="hljs-keyword">this</span>.age = age;\n};\n<span class="hljs-keyword">var</span> createTom = CreatePerson.bind({}, <span class="hljs-string">\'tom\'</span>);\n<span class="hljs-keyword">var</span> tom = <span class="hljs-keyword">new</span> createTom(<span class="hljs-number">12</span>);\n<span class="hljs-built_in">console</span>.log(tom);  <span class="hljs-comment">// {name: "tom", age: 12}</span>\n</code></pre>\n<h3>ES6中箭头函数的this</h3>\n<p>ES6中的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions#Syntax">箭头函数</a>语法，可以大大简化以往的函数表达式写法，不同的是，箭头函数作用域中没有绑定 <code>this</code>，它的 <code>this</code> 是继承自上一级的，而且箭头函数内是没有 <code>arguments</code> 的</p>\n<pre><code class="hljs" lang="JavaScript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];\n<span class="hljs-keyword">var</span> newArr = [];\n\nnewArr = arr.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{\n  <span class="hljs-keyword">return</span> value * <span class="hljs-number">2</span>;\n}); <span class="hljs-comment">// [2, 4, 6, 8, 10]</span>\n\nnewArr = arr.map(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {\n  <span class="hljs-keyword">return</span> value * <span class="hljs-number">2</span>;\n}); <span class="hljs-comment">// [2, 4, 6, 8, 10]</span>\n\nnewArr = arr.map(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value * <span class="hljs-number">2</span>) <span class="hljs-comment">// [2, 4, 6, 8, 10]</span>\n</code></pre>\n<pre><code class="hljs" lang="javascript"><span class="hljs-keyword">var</span> val = <span class="hljs-number">1</span>;\n<span class="hljs-keyword">var</span> obj = {\n  <span class="hljs-attr">val</span>: <span class="hljs-number">2</span>,\n  showVal() {\n    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getVal</span>(<span class="hljs-params"></span>) </span>{\n      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.val;\n    };\n    <span class="hljs-built_in">console</span>.log(getVal()); <span class="hljs-comment">// 这里的getVal()其实是全局对象在调用</span>\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.val);\n  }\n};\n\nobj.showVal(); <span class="hljs-comment">// 这儿的showVal()是obj在调用</span>\n<span class="hljs-comment">// 1</span>\n<span class="hljs-comment">// 2</span>\n</code></pre>\n<pre><code class="hljs" lang="javascript"><span class="hljs-keyword">var</span> val = <span class="hljs-number">1</span>;\n<span class="hljs-keyword">var</span> obj = {\n  <span class="hljs-attr">val</span>: <span class="hljs-number">2</span>,\n  showVal() {\n    <span class="hljs-keyword">var</span> getVal = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.val;\n    };\n    <span class="hljs-built_in">console</span>.log(getVal()); <span class="hljs-comment">// 这里的getVal()其实是全局对象在调用，但是this缺继承了上一级的this</span>\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.val);\n  }\n};\n\nobj.showVal(); <span class="hljs-comment">// 这儿的showVal()是obj在调用</span>\n<span class="hljs-comment">// 2</span>\n<span class="hljs-comment">// 2</span>\n</code></pre>\n',wordCount:9556}},I4L2:function(s,n){throw new Error("Module parse failed: Unexpected character '#' (142:4)\nYou may need an appropriate loader to handle this file type.\n| <li>内存管理。整理回收后出现的大量不连续空间的内存碎片。</li>\n| </ol>\n| <p>`### 新生代</p>\n| <p>新生代使用 Scavenge 算法处理内存回收，大多数小的对象会被放入新生代中。新生代的空间分为两个区域，一个是对象区域，一个是空闲区域，新加入的对象会放入对象区域，当对象区域快写满时就执行一次垃圾回收。</p>\n| <h2>V8 执行代码的过程</h2>")},Jz86:function(s,n){s.exports={info:{title:"SVG Animation",poster:"",date:"2018-12-12",id:"2018-12-12",desc:"这篇文章将介绍 SVG 与 SVG 基本图形的绘制，以及使用 SVG 来制作有趣的动画效果"},content:'<p>在介绍 SVG 之前，我们首先了解一下图形</p>\n<h2>图形</h2>\n<p>计算机中图形的表示方式分为两种：栅格图形 和 矢量图形</p>\n<h3>栅格图形</h3>\n<p>栅格图形又称为位图或点阵图，使用像素阵列表示图像，比如 png，jpg，gif 等图片格式都是栅格图形，每个像素都有特定的位置与颜色值，可以表示的颜色由每个像素的携带的色值决定，像素与颜色信息越多，图片储存空间就越大</p>\n<p><img src="/static/svg-animation/img/demo1.jpg" alt="demo1"></p>\n<p>一般浏览器使用的都是栅格图形，但是它也有缺点，就是当小的图形被放大显示时，图形边缘会产生锯齿，使得显示效果失真，例如这样：</p>\n<p><img src="/static/svg-animation/img/demo2.png" alt="demo2"></p>\n<h3>矢量图形</h3>\n<p>矢量图形是计算机用点、直线或者多边形等基于数学方程的几何图形表示的图像。</p>\n<p>因为矢量图形是根据坐标绘制的，所以与分辨率无关，放大与缩小都不会丢失细节，曲线的边缘更加平滑，不影响清晰度，且保存体积比栅格图形小</p>\n<p><img src="/static/svg-animation/img/tool.svg" alt="download"><img src="/static/svg-animation/img/star.svg" alt="star"><img src="/static/svg-animation/img/tree.svg" alt="tree"></p>\n<h2>SVG</h2>\n<h3>SVG 即可缩放矢量图形（Scalable Vector Graphics）</h3>\n<p>SVG 使用 XML 来描述，属于 XML 分支语言的一种，可以用于绘制矢量图形。SVG 通过定义线或形状来创建一个图形，也可以修改位图，或者将两种方式结合起来创建图形。</p>\n<p>HTML 提供了标题、段落、表格等内容的元素，与此类似，在 SVG 中也提供了一些元素，比如用于定义圆、矩形、曲线和多边形等。一个简单的SVG文档由 <code>&lt;svg&gt;</code> 根元素（相当于 <code>&lt;html&gt;</code> 根元素）和基本的形状元素构成。另外还有一个 <code>&lt;g&gt;</code> 元素，用来把若干个基本形状编写成一个组。当然 SVG 可以与 javascript、css 结合起来使用，当以 <code>.svg</code> 为后缀保存在文件里时，可以被 img、iframe、background 引用。</p>\n<p>SVG 属于 XML 语言，是区分大小写的，这一点与 HTML 不同；与 HTML 相同的是：默认先出现的元素会出现在底层，后出现的元素会绘制在顶层，子元素会继承父元素的一些属性，比如：opacity、transform。</p>\n<p><em><strong>注意：SVG 元素是无法通过 <code>z-index</code> 修改层级的</strong></em></p>\n<h3>SVG 的绘制过程</h3>\n<ol>\n<li>解析 SVG 文档</li>\n<li>列出绘制元素列表</li>\n<li>计算出每个绘制元素的 path 对应的直线长度</li>\n<li>根据动画时长和总长度，在每一帧依次画出指定长度的 path</li>\n<li>path 绘制完成后，绘制 SVG fill</li>\n</ol>\n<h3>SVG 的基本形状</h3>\n<p>svg 的命名空间：</p>\n<p>参考：https://www.jianshu.com/p/c590983dbc87</p>\n<p><code>&lt;svg xmlns=&quot;http://www.w3c.org/2000/svg&quot;&gt;&lt;/svg&gt;</code> 标记 xml 语言是 SVG，它只是一个字符串标识</p>\n<h4>SVG 元素的几个常用属性：</h4>\n<ol>\n<li>x/y 图形起始点的坐标</li>\n<li>width/height 图形的宽高</li>\n<li>fill: 图形的填充颜色（有的图形没有 <code>fill</code> 属性，例如 <code>&lt;line&gt;</code>）\n<code>fill</code> 属性的默认值为黑色 #000，将 <code>fill</code> 设置为 <code>none</code> 为透明</li>\n<li>stroke: 边框或线段的颜色\n<code>stroke</code> 的默认没有颜色</li>\n<li>stroke-width: 边框或线段的宽度\n<code>stroke-width</code> 默认为 <code>1</code></li>\n</ol>\n<h4>SVG 属性值可能是多种形式，值可以是一个数字集合，以 <code>空格</code> 或 <code>,</code> 分割：</h4>\n<p>例如 points 属性的写法：</p>\n<pre><code>points=&quot;10,20,30,40&quot; // 可以逗号分隔\npoints=&quot;10 20 30 40&quot; // 可以空格分隔\npoints=&quot;10,20 30,40&quot; // 建议用逗号分隔 x/y 的值，用空格分隔每个点\n</code></pre>\n<h4>rect 矩形</h4>\n<p>矩形就是长方形或者正方形，通过 <code>&lt;rect&gt;</code> 元素来绘制，包括圆角矩形</p>\n<p>属性：\nx: 矩形左上角的 x 坐标\ny: 矩形左上角的 y 坐标\nwidth: 矩形的宽度\nheight: 矩形的高度\nrx: 圆角效果时圆角沿 x 轴的半径\nry: 圆角效果时圆角沿 y 轴的半径\nfill: 填充的颜色\nstroke: 边框颜色\nstroke-width: 边框的宽度</p>\n<pre><code class="hljs" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">rect</span>\n  <span class="hljs-attr">x</span>=<span class="hljs-string">"10"</span>\n  <span class="hljs-attr">y</span>=<span class="hljs-string">"10"</span>\n  <span class="hljs-attr">width</span>=<span class="hljs-string">"100"</span>\n  <span class="hljs-attr">height</span>=<span class="hljs-string">"100"</span>\n  <span class="hljs-attr">fill</span>=<span class="hljs-string">"red"</span>\n  <span class="hljs-attr">stroke</span>=<span class="hljs-string">"yellow"</span>\n  <span class="hljs-attr">stroke-width</span>=<span class="hljs-string">"4"</span>\n&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">rect</span>&gt;</span>\n</code></pre>\n<p><img src="/static/svg-animation/img/rect.svg" alt="rect"></p>\n<h4>circle 圆形</h4>\n<p>圆形通过 <code>&lt;circle&gt;</code> 元素来绘制</p>\n<p>circle 具有 rect 的部分属性：\nfill: 填充的颜色\nstroke: 边框的颜色\nstroke-width: 边框的宽度</p>\n<p>自己特有的属性：\nr: 半径\ncx: 圆心在 x 轴上的坐标\ncy: 圆心在 y 轴上的坐标</p>\n<pre><code class="hljs" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">circle</span>\n  <span class="hljs-attr">cx</span>=<span class="hljs-string">"50"</span>\n  <span class="hljs-attr">cy</span>=<span class="hljs-string">"50"</span>\n  <span class="hljs-attr">r</span>=<span class="hljs-string">"40"</span>\n  <span class="hljs-attr">fill</span>=<span class="hljs-string">"#555"</span>\n  <span class="hljs-attr">stroke</span>=<span class="hljs-string">"gray"</span>\n  <span class="hljs-attr">stroke-width</span>=<span class="hljs-string">"4"</span>\n&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">circle</span>&gt;</span>\n</code></pre>\n<p><img src="/static/svg-animation/img/circle.svg" alt="circle"></p>\n<h4>ellipse 椭圆</h4>\n<p>椭圆与圆最大的区别是：圆拥有一个半径，椭圆有两个半径\n椭圆具有两个轴上的半径，x 轴的 <code>rx</code>，y 轴的 <code>ry</code></p>\n<p><img src="/static/svg-animation/img/ellipse.gif" alt="椭圆"></p>\n<p>属性：\ncx: 圆心在 x 轴的坐标\ncy: 圆心在 y 轴的坐标\nrx: 椭圆在 x 轴的半径\nry: 椭圆在 y 轴的半径\nfill: 填充的颜色\nstroke: 边框的颜色\nstroke-width: 边框的宽度</p>\n<pre><code class="hljs" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ellipse</span>\n  <span class="hljs-attr">cx</span>=<span class="hljs-string">"100"</span>\n  <span class="hljs-attr">cy</span>=<span class="hljs-string">"60"</span>\n  <span class="hljs-attr">rx</span>=<span class="hljs-string">"80"</span>\n  <span class="hljs-attr">ry</span>=<span class="hljs-string">"50"</span>\n  <span class="hljs-attr">fill</span>=<span class="hljs-string">"pink"</span>\n  <span class="hljs-attr">stroke</span>=<span class="hljs-string">"red"</span>\n  <span class="hljs-attr">stroke-width</span>=<span class="hljs-string">"5"</span>\n&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">ellipse</span>&gt;</span>\n</code></pre>\n<p><img src="/static/svg-animation/img/ellipse.svg" alt="ellipse"></p>\n<p><em><strong>当 rx 和 ry 相等时，绘制出的 <code>&lt;ellipse&gt;</code> 和 <code>&lt;circle&gt;</code> 是相等的</strong></em></p>\n<h4>polygon 多边形</h4>\n<p>多边形最重要的属性是顶点points，每个顶点都是由x、y坐标组成的，每个点之间相互连接，最后一个点再与第一个点连接起来形成一个图形。\npoints的值需要根据多边形来决定，例如三角形有三个顶点，所以points由三个值组成，依次写每个点的x、y坐标就可以，推荐每个点的坐标x、y用逗号隔开，每个定点之间用空格隔开：</p>\n<pre><code class="hljs" lang="xml"><span class="hljs-comment">&lt;!-- 绘制一个五边形 --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">polygon</span>\n  <span class="hljs-attr">points</span>=<span class="hljs-string">"10,10 120,10 120,120 80,150 10,120"</span>\n  <span class="hljs-attr">fill</span>=<span class="hljs-string">"pink"</span>\n  <span class="hljs-attr">stroke-width</span>=<span class="hljs-string">"2"</span>\n  <span class="hljs-attr">stroke</span>=<span class="hljs-string">"red"</span>\n&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">polygon</span>&gt;</span>\n</code></pre>\n<p>fill: 填充的颜色\nstroke: 边框的颜色\nstroke-width: 边框的宽度\n<em>多边形最少由三个点组成</em></p>\n<p><img src="/static/svg-animation/img/polygon.svg" alt="polygon"></p>\n<h4>line 直线</h4>\n<p>绘制直线要使用 <code>&lt;line&gt;</code> 标签\n两个点可以确定一条直线，那么 line 的属性对应为：\nx1: 起点的 x 坐标\ny1: 起点的 y 坐标\nx2: 终点的 x 坐标\ny2: 终点的 y 坐标\nstroke: 直线的颜色\nstroke-width: 直线的宽度\n<em>直线是没有 fill 属性的</em></p>\n<pre><code class="hljs" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">line</span>\n  <span class="hljs-attr">x1</span>=<span class="hljs-string">"10"</span>\n  <span class="hljs-attr">y1</span>=<span class="hljs-string">"50"</span>\n  <span class="hljs-attr">x2</span>=<span class="hljs-string">"200"</span>\n  <span class="hljs-attr">y2</span>=<span class="hljs-string">"50"</span>\n  <span class="hljs-attr">stroke</span>=<span class="hljs-string">"#555"</span>\n  <span class="hljs-attr">stroke-width</span>=<span class="hljs-string">"3"</span>\n&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">line</span>&gt;</span>\n</code></pre>\n<p><img src="/static/svg-animation/img/line.svg" alt="line"></p>\n<h4>polyline 折线</h4>\n<p>折线与多边形很类似，都是通过多个顶点points来绘制的，只不过最后一个点不会与第一个点连接起来，当然，使用折线也可以绘制出多边形。</p>\n<p>points: 起点、终点或折线转变方向的地方\nfill: 折线起点与终点连接起来的区域的填充颜色\nstroke: 折线的颜色\nstroke-width: 折线的宽度</p>\n<pre><code class="hljs" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">polyline</span>\n  <span class="hljs-attr">points</span>=<span class="hljs-string">"30,30 30,70 70,70 70,120 120,50"</span>\n  <span class="hljs-attr">stroke</span>=<span class="hljs-string">"red"</span>\n  <span class="hljs-attr">fill</span>=<span class="hljs-string">"none"</span>\n&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">polyline</span>&gt;</span>\n</code></pre>\n<p><img src="/static/svg-animation/img/polyline.svg" alt="polyline"></p>\n<h4>path 路径</h4>\n<p>SVG中所有的图形都可以用path来绘制</p>\n<p>属性：</p>\n<p>stroke：路径的颜色</p>\n<p>stroke-width：路径的宽度</p>\n<p>stroke-dasharray：它是一个 <code>&lt;length&gt;</code> 和 <code>&lt;percentage&gt;</code> 数列，数与数之间用逗号或者空白隔开：<code>4 6 4 6</code>， 指定短划线和缺口的长度。如果提供了奇数个值，则这个值的数列重复一次，从而变成偶数个值。因此，<code>5,3,2</code> 等同于 <code>5,3,2,5,3,2</code></p>\n<p>stroke-dashoffset：标识 dash 的起始位置</p>\n<p><img src="/static/svg-animation/img/stroke-dasharray.png" alt="stroke-dasharray"></p>\n<p>d：路径命令的集合，包含多个指令：</p>\n<p><strong>其中参数大写代表绝对坐标，小写代表与前一个坐标的相对坐标</strong></p>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>M</td>\n<td>x y</td>\n<td>起始点的坐标x, y（Move to）</td>\n</tr>\n<tr>\n<td>L</td>\n<td>x y</td>\n<td>从当前点的坐标画直线到指定点的x，y坐标（Line to）</td>\n</tr>\n<tr>\n<td>H</td>\n<td>x</td>\n<td>从当前点的坐标画水平直线到指定的x轴坐标（Horizontal line to）</td>\n</tr>\n<tr>\n<td>V</td>\n<td>y</td>\n<td>从当前点的坐标画垂直直线到指定的y轴坐标（Vertical line to）</td>\n</tr>\n<tr>\n<td>C</td>\n<td>x1 y1 x2 y2 x y</td>\n<td>从当前点的坐标画贝塞尔曲线到指定点的x, y坐标，其中x1，y1及x2，y2为控制点（Curve）</td>\n</tr>\n<tr>\n<td>S</td>\n<td>x2 y2 x y</td>\n<td>从当前点的坐标画反射的贝塞尔曲线到指定点的x，y坐标，其中x2，y2为反射的控制点（Smooth curve）</td>\n</tr>\n<tr>\n<td>Q</td>\n<td>x1 y1 x y</td>\n<td>从当前点的坐标画反射二次贝塞尔曲线到指定点的x y坐标，其中x1 y1为控制点（Quadratic Bézier curve）</td>\n</tr>\n<tr>\n<td>T</td>\n<td>x y</td>\n<td>从当前点到坐标画反射二次贝塞尔曲线到指定点的x, y坐标，以前一个坐标为反射控制点（Smooth Quadratic Bézier curve）</td>\n</tr>\n<tr>\n<td>A</td>\n<td>rx ry x-axis-rotation large-arc-flag-sweep-flag x y</td>\n<td>从当前点的坐标画椭圆形到指定点的x，y坐标，其中rx，ry为椭圆形的x轴及y轴的半径，x-axis-rotation是弧线与x轴的旋转角度，large-arc-flag则设定1(最大角度的弧线)或0(最小角度的弧线)，sweep-flag设定方向为1(顺时针方向)或0(逆时针方向)（Arc）</td>\n</tr>\n<tr>\n<td>Z</td>\n<td></td>\n<td>关闭路径，将当前坐标与第一个点的坐标连接起来（Closepath）</td>\n</tr>\n</tbody>\n</table>\n<p>示例如下：</p>\n<pre><code class="hljs" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">path</span>\n  <span class="hljs-attr">fill</span>=<span class="hljs-string">"none"</span>\n  <span class="hljs-attr">d</span>=<span class="hljs-string">"M2,82 L240,206 C254,214 272,209 279,195 L323,117"</span>\n  <span class="hljs-attr">stroke</span>=<span class="hljs-string">"#D31E1E"</span>\n  <span class="hljs-attr">stroke-width</span>=<span class="hljs-string">"3"</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span>\n</code></pre>\n<p><img src="/static/svg-animation/img/path.svg" alt="path"></p>\n<h3>其他标签</h3>\n<h4>g</h4>\n<p>g 标签表示分组，可以把任意图形划为一组：</p>\n<pre><code class="hljs" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">g</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"demo"</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">"green"</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">"white"</span> <span class="hljs-attr">stroke-width</span>=<span class="hljs-string">"5"</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">"25"</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">"25"</span> <span class="hljs-attr">r</span>=<span class="hljs-string">"15"</span>/&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">"40"</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">"25"</span> <span class="hljs-attr">r</span>=<span class="hljs-string">"15"</span>/&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">"55"</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">"25"</span> <span class="hljs-attr">r</span>=<span class="hljs-string">"15"</span>/&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">"70"</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">"25"</span> <span class="hljs-attr">r</span>=<span class="hljs-string">"15"</span>/&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span>\n</code></pre>\n<p>分组里可以有标签的描述：<code>&lt;desc&gt;</code></p>\n<pre><code class="hljs" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">g</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"demo"</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">"green"</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">"white"</span> <span class="hljs-attr">stroke-width</span>=<span class="hljs-string">"5"</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">desc</span>&gt;</span>Just Demo<span class="hljs-tag">&lt;/<span class="hljs-name">desc</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">"25"</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">"25"</span> <span class="hljs-attr">r</span>=<span class="hljs-string">"15"</span>/&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span>\n</code></pre>\n<h4>use</h4>\n<p>use 标签可以复用 <code>&lt;g&gt;</code> 标签的分组</p>\n<p>将 <code>xlink:href</code> 属性的值设为 group 的 id，就可以引用 group 的图形：</p>\n<pre><code class="hljs" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">g</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"Port"</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"fill: inherit;"</span> <span class="hljs-attr">r</span>=<span class="hljs-string">"10"</span>/&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">x</span>=<span class="hljs-string">"50"</span> <span class="hljs-attr">y</span>=<span class="hljs-string">"30"</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">"#Port"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"classA"</span>/&gt;</span>\n</code></pre>\n<p>use 标签不可覆盖 g 分组内图形的原有样式</p>\n<p>style &gt; 行内属性样式</p>\n<h4>defs</h4>\n<p>defs 可以保存代码，不被浏览器解析，可以被 use 引用，其中包含的分组可以被 use 标签的 style 属性覆盖掉样式：</p>\n<pre><code class="hljs" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">defs</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">g</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"Port"</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"fill: inherit;"</span> <span class="hljs-attr">r</span>=<span class="hljs-string">"10"</span>/&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">defs</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">x</span>=<span class="hljs-string">"50"</span> <span class="hljs-attr">y</span>=<span class="hljs-string">"50"</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">"#Port"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"fill: blue;"</span>/&gt;</span>\n</code></pre>\n<h3>symbol</h3>\n<p>symbol 与 g 标签类似，也可以分组并定义一些模板且不被浏览器解析，使用 use 来使用模板：</p>\n<pre><code class="hljs" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">symbol</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sym01"</span> <span class="hljs-attr">viewBox</span>=<span class="hljs-string">"0 0 150 110"</span>&gt;</span>\n\t<span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">"50"</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">"50"</span> <span class="hljs-attr">r</span>=<span class="hljs-string">"40"</span> <span class="hljs-attr">stroke-width</span>=<span class="hljs-string">"8"</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">"red"</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">"red"</span>/&gt;</span>\n\t<span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">"90"</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">"60"</span> <span class="hljs-attr">r</span>=<span class="hljs-string">"40"</span> <span class="hljs-attr">stroke-width</span>=<span class="hljs-string">"8"</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">"green"</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">"white"</span>/&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">symbol</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#sym01"</span> <span class="hljs-attr">x</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">y</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"100"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"50"</span>/&gt;</span>\n</code></pre>\n<h2>SVG 动画</h2>\n<h3>animate</h3>\n<p>SVG 标签的 style 属性可以定义 SVG 的样式与动画效果，除此以外还可以使用 animate 标签</p>\n<p>属性：</p>\n<p>attributeName：需要被动画改变的属性名</p>\n<p>attributeType：定义了目标属性的命名空间 CSS | XML | auto</p>\n<p>form：动画发生时，被修改属性的初始值</p>\n<p>to：动画发生时，被修改属性的最终值</p>\n<p>begin：动画的开始时间</p>\n<p>dur：动画持续的时长</p>\n<p>repeatCount：动画重复的次数。indefinite：无限反复</p>\n<p>用 animate 元素定义 SVG 的动画效果：</p>\n<pre><code class="hljs" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">rect</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">"#2196F3"</span> <span class="hljs-attr">x</span>=<span class="hljs-string">"10"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"20"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"100"</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">animate</span>\n    <span class="hljs-attr">attributeName</span>=<span class="hljs-string">"width"</span>\n    <span class="hljs-attr">attributeType</span>=<span class="hljs-string">"XML"</span>\n    <span class="hljs-attr">to</span>=<span class="hljs-string">"300"</span>\n    <span class="hljs-attr">begin</span>=<span class="hljs-string">"0s"</span>\n    <span class="hljs-attr">dur</span>=<span class="hljs-string">"3s"</span>\n    <span class="hljs-attr">repeatCount</span>=<span class="hljs-string">"indefinite"</span>\n  &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">animate</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">animate</span>\n    <span class="hljs-attr">attributeName</span>=<span class="hljs-string">"fill"</span>\n    <span class="hljs-attr">attributeType</span>=<span class="hljs-string">"XML"</span>\n    <span class="hljs-attr">to</span>=<span class="hljs-string">"#F44336"</span>\n    <span class="hljs-attr">begin</span>=<span class="hljs-string">"0s"</span>\n    <span class="hljs-attr">dur</span>=<span class="hljs-string">"3s"</span>\n    <span class="hljs-attr">repeatCount</span>=<span class="hljs-string">"indefinite"</span>\n  &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">animate</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">rect</span>&gt;</span>\n</code></pre>\n<p><img src="/static/svg-animation/img/animate.svg" alt="animate"></p>\n<h3>animationTransform</h3>\n<p>animationTransform 标签用来做变形动画</p>\n<p>属性：</p>\n<p>type：定义了动画 <code>transform</code> 的类型</p>\n<p>其他属性与 <code>&lt;animate&gt;</code> 一致</p>\n<pre><code class="hljs" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">polygon</span> <span class="hljs-attr">points</span>=<span class="hljs-string">"30,30 100,30 100,100 30,100"</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">"#f44333"</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">animateTransform</span>\n    <span class="hljs-attr">attributeName</span>=<span class="hljs-string">"transform"</span>\n    <span class="hljs-attr">attributeType</span>=<span class="hljs-string">"XML"</span>\n    <span class="hljs-attr">type</span>=<span class="hljs-string">"rotate"</span>\n    <span class="hljs-attr">from</span>=<span class="hljs-string">"0 60 70"</span>\n    <span class="hljs-attr">to</span>=<span class="hljs-string">"360 60 70"</span>\n    <span class="hljs-attr">dur</span>=<span class="hljs-string">"10s"</span>\n    <span class="hljs-attr">repeatCount</span>=<span class="hljs-string">"indefinite"</span> /&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">polygon</span>&gt;</span>\n</code></pre>\n<p><img src="/static/svg-animation/img/animateTransform.svg" alt="animateTransform"></p>\n<h3>animate morph</h3>\n<p>animate morph 可以做图形内部的渐变</p>\n<h3>animateMotion</h3>\n<p>animateMotion 可以让图形按指定路径运动</p>\n<p>属性：</p>\n<p>from / to：指定运动两点的位置，以元素的坐标为原点</p>\n<p>dur：动画执行时长</p>\n<p>fill：指定动画结束后的元素的位置。freeze：停留在原地；remove：回到起始位置</p>\n<p>rotate：旋转角度。 auto：让物体垂直于路径的切线方向运动；auto-reverse：如 auto对称相反；Number：自定义旋转角度</p>\n<pre><code class="hljs" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">"25"</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">"25"</span> <span class="hljs-attr">r</span>=<span class="hljs-string">"25"</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">"#2196F3"</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">animateMotion</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"0,0"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"100,100"</span> <span class="hljs-attr">dur</span>=<span class="hljs-string">"1s"</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">"freeze"</span> /&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">circle</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">rect</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"50"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"50"</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">"#F44336"</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">animateMotion</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"0,0"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"100,100"</span> <span class="hljs-attr">dur</span>=<span class="hljs-string">"1s"</span> <span class="hljs-attr">repeatCount</span>=<span class="hljs-string">"indefinite"</span> /&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">rect</span>&gt;</span>\n</code></pre>\n<p><img src="/static/svg-animation/img/animateMotion1.svg" alt="animateMotion1"> <img src="/static/svg-animation/img/animateMotion2.svg" alt="animateMotion2"></p>\n<p>复杂的路径可以使用 <code>path</code> 属性：</p>\n<pre><code class="hljs" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">rect</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"50"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"50"</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">"#F44336"</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">animateMotion</span>\n    <span class="hljs-attr">path</span>=<span class="hljs-string">"M3,52.98c47.18-38,36.11-50.25,18.3-43.49S7.33,36.93,38.15,52.98S53.56,18.35,83.89,4.42\n\ts65.96,53.2,64.04,56.58"</span>\n    <span class="hljs-attr">dur</span>=<span class="hljs-string">"3s"</span>\n    <span class="hljs-attr">repeatCount</span>=<span class="hljs-string">"indefinite"</span> /&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">rect</span>&gt;</span>\n</code></pre>\n<p><img src="/static/svg-animation/img/animateMotion3.svg" alt="animateMotion3"></p>\n<p>也可以使用 <code>&lt;mpath&gt;</code> 标签来引用 <code>&lt;path&gt;</code> 的路径：</p>\n<pre><code class="hljs" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"path"</span>\n  <span class="hljs-attr">fill</span>=<span class="hljs-string">"none"</span>\n  <span class="hljs-attr">stroke</span>=<span class="hljs-string">"red"</span>\n  <span class="hljs-attr">d</span>=<span class="hljs-string">"M3,95.26C69.71,25.41,54.05,2.91,28.87,15.32S9.13,65.77,52.69,95.26s21.78-63.64,64.67-89.25 s93.26,97.78,90.53,103.99"</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">r</span>=<span class="hljs-string">"5"</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">"#2196F3"</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">animateMotion</span> <span class="hljs-attr">rotate</span>=<span class="hljs-string">"auto-reverse"</span> <span class="hljs-attr">dur</span>=<span class="hljs-string">"5s"</span> <span class="hljs-attr">repeatCount</span>=<span class="hljs-string">"indefinite"</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">mpath</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#path"</span>/&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">animateMotion</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">circle</span>&gt;</span>\n</code></pre>\n<p><img src="/static/svg-animation/img/animateMotion4.svg" alt="animateMotion4"></p>\n<p>修改 rotate 属性：</p>\n<p><code>auto-reverse</code></p>\n<pre><code class="hljs" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"path"</span>\n  <span class="hljs-attr">fill</span>=<span class="hljs-string">"none"</span>\n  <span class="hljs-attr">stroke</span>=<span class="hljs-string">"red"</span>\n  <span class="hljs-attr">d</span>=<span class="hljs-string">"M3,95.26C69.71,25.41,54.05,2.91,28.87,15.32S9.13,65.77,52.69,95.26s21.78-63.64,64.67-89.25 s93.26,97.78,90.53,103.99"</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">rect</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"10"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"10"</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">"#2196F3"</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">animateMotion</span> <span class="hljs-attr">rotate</span>=<span class="hljs-string">"auto-reverse"</span> <span class="hljs-attr">dur</span>=<span class="hljs-string">"5s"</span> <span class="hljs-attr">repeatCount</span>=<span class="hljs-string">"indefinite"</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">mpath</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#path"</span>/&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">animateMotion</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">rect</span>&gt;</span>\n</code></pre>\n<p><img src="/static/svg-animation/img/animateMotion5.svg" alt="animateMotion5"></p>\n<p><code>auto</code></p>\n<pre><code class="hljs" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"path"</span>\n  <span class="hljs-attr">fill</span>=<span class="hljs-string">"none"</span>\n  <span class="hljs-attr">stroke</span>=<span class="hljs-string">"red"</span>\n  <span class="hljs-attr">d</span>=<span class="hljs-string">"M3,95.26C69.71,25.41,54.05,2.91,28.87,15.32S9.13,65.77,52.69,95.26s21.78-63.64,64.67-89.25 s93.26,97.78,90.53,103.99"</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">rect</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"10"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"10"</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">"#2196F3"</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">animateMotion</span> <span class="hljs-attr">rotate</span>=<span class="hljs-string">"auto"</span> <span class="hljs-attr">dur</span>=<span class="hljs-string">"5s"</span> <span class="hljs-attr">repeatCount</span>=<span class="hljs-string">"indefinite"</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">mpath</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#path"</span>/&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">animateMotion</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">rect</span>&gt;</span>\n</code></pre>\n<p><img src="/static/svg-animation/img/animateMotion6.svg" alt="animateMotion6"></p>\n<h3>线条动画</h3>\n<p>利用 path 的  <code>stroke-dasharray</code> 和 <code>stroke-dashoffset</code> 来实现线条运动。</p>\n<p>因为 dasharray 可以定义实线长度与间隙长度，并且 dashoffset 可以\'移动\'线段，所以可以通过改变这些属性的数值来实现动画效果</p>\n<table>\n<thead>\n<tr>\n<th>方式</th>\n<th>起始值</th>\n<th>终止值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>stroke-dasharray: 0 max;</td>\n<td>stroke-dasharray: max 0;</td>\n</tr>\n<tr>\n<td>2</td>\n<td>stroke-dasharray: 0 max;</td>\n<td>stroke-dasharray: max max;</td>\n</tr>\n<tr>\n<td>3</td>\n<td>stroke-dashoffset: 0;<br/>stroke-dasharray: max max;</td>\n<td>stroke-dashoffset: max;<br/>stroke-dasharray: max max;</td>\n</tr>\n</tbody>\n</table>\n<p><em>(max为path总长度)</em></p>\n<p>还有一个问题，就是我们如何知道 path 图形的 stroke 有多长呢？</p>\n<p>噔噔！很简单，使用 path 元素的 <code>getTotalLength</code> 方法即可：</p>\n<pre><code class="hljs" lang="js"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">\'path\'</span>).getTotalLength()\n</code></pre>\n<p>接下来我们做一条会动的线，首先，我们定义一条路径：</p>\n<pre><code class="hljs" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.w3.org/2000/svg"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"400"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"250"</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">path</span>\n    <span class="hljs-attr">class</span>=<span class="hljs-string">"move"</span>\n    <span class="hljs-attr">id</span>=<span class="hljs-string">"path"</span>\n    <span class="hljs-attr">ref</span>=<span class="hljs-string">"path"</span>\n    <span class="hljs-attr">fill</span>=<span class="hljs-string">"none"</span>\n    <span class="hljs-attr">d</span>=<span class="hljs-string">"M9,183.36C133.52,69,104.3,32.15,57.28,52.48s-36.85,82.59,44.47,130.87S142.42,79.17,222.46,37.24\ns174.08,160.1,168.99,170.26"</span>\n    <span class="hljs-attr">stroke</span>=<span class="hljs-string">"red"</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span>\n</code></pre>\n<p>然后定义动画样式：</p>\n<pre><code class="hljs" lang="css"><span class="hljs-selector-class">.move</span> {\n  <span class="hljs-attribute">animation</span>: move <span class="hljs-number">3s</span> linear infinite;\n}\n@<span class="hljs-keyword">keyframes</span> move {\n  <span class="hljs-selector-tag">from</span> {\n    <span class="hljs-attribute">stroke-dasharray</span>: <span class="hljs-number">0</span> <span class="hljs-number">857.92</span>;\n  }\n  <span class="hljs-selector-tag">to</span> {\n    <span class="hljs-attribute">stroke-dasharray</span>: <span class="hljs-number">857.92</span> <span class="hljs-number">0</span>;\n  }\n}\n</code></pre>\n<p>这样就可以简单实现一个线条动画啦：<a href="/static/svg-animation/dome/demo.html">查看效果</a></p>\n<p>来看下详细的实现：</p>\n<p><a href="https://codesandbox.io/s/10x1m122o4">https://codesandbox.io/s/10x1m122o4</a>(外网)</p>\n<iframe src="https://codesandbox.io/embed/ym78qx2vzv?module=%2Fsrc%2Fcomponents%2Fpath-attributes.vue" style="width:100%; height:700px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe>\n',wordCount:12202}},PU9U:function(s,n){s.exports={info:{title:"MacOS 环境安装 MongoDB",poster:"",date:"2018-07-06",id:"2018-07-06",desc:"在 MacOS 环境中安装 MongoDB"},content:'<h2>Install MongoDB in Mac</h2>\n<ol>\n<li>\n<p>使用 <a href="https://brew.sh/">brew</a> 安装</p>\n<blockquote>\n<p>brew 是 MacOS 上的一个包管理器</p>\n</blockquote>\n<p>安装 mongodb：</p>\n<pre><code class="hljs" lang="bash"><span class="hljs-comment"># sudo 命令可以获得系统权限，输入账户密码即可执行</span>\nsudo brew install mongodb\n</code></pre>\n<p>查看 brew 是否已安装：</p>\n<pre><code class="hljs" lang="bash">brew list\n</code></pre>\n<p>若之前已安装过 MongoDB，可以使用命令来升级：</p>\n<pre><code class="hljs" lang="bash">brew upgrade mongodb\n</code></pre>\n</li>\n<li>\n<p>手动安装</p>\n<p>在 MongoDB <a href="https://www.mongodb.com/download-center#community">官网下载</a> <code>mongodb-osx-ssl-x86_64-4.0.0.tgz</code> 文件（具体版本请以当前发行版本为主），放入 <code>/usr/local</code> 目录中</p>\n<p>进入\b <code>/usr/local</code> 目录：</p>\n<pre><code class="hljs" lang="bash"><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>\n</code></pre>\n<p>解压文件：</p>\n<pre><code class="hljs" lang="bash">sudo tar -zxvf mongodb-osx-ssl-x86_64-4.0.0.tgz\n</code></pre>\n<p>重命名文件夹</p>\n<pre><code class="hljs" lang="bash">sudo mv mongodb-osx-ssl-x86_64-4.0.0 mongodb\n</code></pre>\n</li>\n</ol>\n<h2>Run MongoDB</h2>\n<p>为 MongoDB 添加配置</p>\n<p>运行前，首先需要一个 <code>数据库储存</code> 目录。当启动 MongoDB 时，默认数据库目录为 <code>/data/db</code>，所以我们直接在根目录下创建即可：</p>\n<pre><code class="hljs" lang="bash"><span class="hljs-built_in">cd</span> /\n\n<span class="hljs-comment"># 使用 sudo 命令创建</span>\nsudo mkdir -p /data/db\n</code></pre>\n<blockquote>\n<p>也可以在启动 mongod 的时候，通过 <code>--dbpath</code> 指定 <code>data/db</code> 目录： <code>mongod --dbpath ./my-data</code></p>\n</blockquote>\n<hr>\n<p>接下来就可以启动 MongoDB 了：</p>\n<p>在没有设置全局路径时，需要进入 <code>mongodb/bin</code> 目录下启动：</p>\n<pre><code class="hljs" lang="bash"><span class="hljs-comment"># 进入 mongodb 目录</span>\n<span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/mongodb/bin\n\n<span class="hljs-comment"># 启动 mongod</span>\n./mongod\n</code></pre>\n<pre><code class="hljs" lang="bash"><span class="hljs-comment"># 新打开一个终端窗口并进入 /usr/local/mongodb/bin，启动 mongo</span>\n<span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/mongodb/bin\n\n./mongo\n</code></pre>\n<p>关闭服务：</p>\n<pre><code class="hljs" lang="bash">&gt; db.shutdownServer()\n&gt; <span class="hljs-built_in">exit</span>\n</code></pre>\n',wordCount:1240}},"WUj+":function(s,n){s.exports={info:{title:"随想",poster:"",date:"2020-09-04",id:"2020-09-04",desc:"Mig 引发的思考"},content:"<p>几个月前，我开发了 Mig 的部分功能，由于跻身其他事情(主要是懒)被搁置许久了。</p>\n<p>前几天有人询问我 Mig 的原理，其实原理很简单，我就把代码实现告诉了他，他知道后表示了“这些技术并不难啊，没有什么高深技术”之类的话。</p>\n<p>他说的没错，说到实现原理，确实没用什么高深罕见的技术，仅仅用了简单普通的技术就实现了.</p>\n<p>今天碰巧看到乔布斯早年说的一些话，顿时想到一些事情：</p>\n<p>我们在做一个产品时，是否一开始是从用户的角度出发去，然后才通过用户体验反推出我们需要用到的技术，是否时刻在思考用户需要的是什么，我们怎样才能给用户带来更多的利益，怎样去引导用户体验以及带给用户真正想要的，而不是单纯在系统考虑加入什么吊炸天的技术、内部采取多么复杂的设计，如果产品需要，那这些将是必然的，而不是先于产品去设计的。</p>\n<p>开始做 Mig 之前我做了许多的调研，体验过许多同类的插件，查遍了拦截请求的各种可能，思考了假如使用中间人服务，如何免去用户手动控制服务启动与关闭，为了减去用户的操作，甚至我还想过在 Chrome 中直接跑 nodejs，后来了解到使 Chrome 调用本地应用程序，理论上可以实现，但是这始终需要用户除扩展外再安装一个应用程序，这个体验极其不友好也不方便，还依赖系统环境，所以放弃；使用 ChromeAPI 拦截，却只能在控制台界面修改响应内容，之前考虑到使用性最终选择 option 页，所以也放弃了；在查了很多资料后，反而改写 XMLHttpRequest 是最简单最合适的方式，但是如何使页面与扩展顺畅的通信又是一大难题，庆幸的是我也解决了，还有其他一些问题等等就不再叙述了。</p>\n<p>事实上一个产品的价值，更体现在一个点以及点的落地，从用户体验回归到技术实现，如果最简洁的实现却是最适合的，那不要犹豫了，选择它吧。</p>\n",wordCount:762}},"c+JU":function(s,n){},c3ki:function(s,n){s.exports={info:{title:"ts",poster:"",date:"2018-08-30",id:"2018-08-30",desc:"TypeScript 是 JavaScript 的超集，她为 JavaScript 提供了类型注解、静态类型检查的功能，以及一些新的特性，TypeScript 可以编译成 JavaScript 代码，在不同平台上运行"},content:'<blockquote>\n<p>TypeScript 是 JavaScript 的超集，她为 JavaScript 提供了类型注解、静态类型检查的功能，以及一些新的特性，TypeScript 可以编译成 JavaScript 代码，在不同平台上运行</p>\n</blockquote>\n<h2>TypeScript 基本类型的定义：</h2>\n<p>\b### 数字、字符串、布尔值</p>\n<pre><code class="hljs" lang="ts"><span class="hljs-keyword">let</span> age: <span class="hljs-built_in">number</span> = <span class="hljs-number">18</span>\n<span class="hljs-keyword">let</span> name: <span class="hljs-built_in">string</span> = <span class="hljs-string">\'tom\'</span>\n<span class="hljs-keyword">let</span> show: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>\n</code></pre>\n<h3>数组 一种特殊的元祖</h3>\n<pre><code class="hljs" lang="ts"><span class="hljs-keyword">let</span> list: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]\n<span class="hljs-keyword">let</span> list <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]\n</code></pre>\n<h3>元组</h3>\n<pre><code class="hljs" lang="ts"><span class="hljs-keyword">let</span> list: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>]\nlist = [<span class="hljs-string">\'tom\'</span>, <span class="hljs-number">18</span>]\n</code></pre>\n<p>当越界访问\b或创建元素时，以联合类型为标准：</p>\n<pre><code class="hljs" lang="ts">list 的联合类型为(<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>)\nlist[<span class="hljs-number">2</span>] = <span class="hljs-number">123</span> <span class="hljs-comment">// 123</span>\nlist[<span class="hljs-number">3</span>] = <span class="hljs-literal">true</span> <span class="hljs-comment">// Error! 不能将 true 分配给 (string | number) 类型</span>\n</code></pre>\n<h3>枚举</h3>\n<pre><code class="hljs" lang="ts"><span class="hljs-keyword">enum</span> Animal {dog, cat, pig = <span class="hljs-number">100</span>}\n<span class="hljs-keyword">let</span> dog: Animal = Animal.dog\n<span class="hljs-keyword">let</span> cat: Animal = Animal.cat\n<span class="hljs-keyword">let</span> pig: Animal = Animal.pig\n<span class="hljs-keyword">let</span> petName: <span class="hljs-built_in">string</span> = Animal[<span class="hljs-number">1</span>] <span class="hljs-comment">// 通过值获取 key</span>\ndog <span class="hljs-comment">// 0</span>\ncat <span class="hljs-comment">// 1</span>\npig <span class="hljs-comment">// 100</span>\npetName <span class="hljs-comment">// cat</span>\n</code></pre>\n<h3>Any</h3>\n<p>给不确定的类型定义 any 时，ts 将不进行类型检查：</p>\n<pre><code class="hljs" lang="ts"><span class="hljs-keyword">let</span> someValue: <span class="hljs-built_in">any</span> = <span class="hljs-number">18</span>\nsomeValue = <span class="hljs-string">\'tom\'</span>\nsomeValue = <span class="hljs-literal">false</span>\n</code></pre>\n<h3>Void</h3>\n<p>void 类型表示没有任何类型，当函数没有返回值时则是 void 类型</p>\n<pre><code class="hljs" lang="ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params"></span>): <span class="hljs-title">void</span> </span>{\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'no return\'</span>)\n}\n</code></pre>\n<p>void 类型只能赋值为 undefiend 和 null</p>\n<h3>Null、Undefined</h3>\n<p>null 和 undefined 拥有各自的类型，并且他们也是所有类型的子类型，所以可以赋值给其他类型的变量：</p>\n<pre><code class="hljs" lang="ts"><span class="hljs-keyword">let</span> a: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>\na = <span class="hljs-literal">null</span>\n<span class="hljs-keyword">let</span> b: <span class="hljs-literal">null</span> = <span class="hljs-literal">undefined</span>\nb = <span class="hljs-literal">undefined</span>\n<span class="hljs-keyword">let</span> n: <span class="hljs-built_in">number</span> = <span class="hljs-number">123</span>\nn = <span class="hljs-literal">undefined</span> <span class="hljs-comment">// 将 undefined 赋值给 number 类型</span>\n</code></pre>\n<p>使用 --strictNullChecks 模式，undefined 只能\b赋值给 undefined 和 void 类型；null 只能赋值给 null 类型</p>\n<h3>Never</h3>\n<p>never 类型表示不会有值存在的类型，例如永远没有返回值的函数，</p>\n<pre><code class="hljs" lang="ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params"></span>): <span class="hljs-title">never</span> </span>{\n  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>()\n}\n<span class="hljs-keyword">var</span> a: never = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">\'ads\'</span>)\n})()\n</code></pre>\n<h3>类型断言</h3>\n<p>当你确切知道值的类型，可以使用类型断言来手动指定类型，告诉 ts 应该按你说的做\n类型断言有两种方式，可以根据你的喜好来书写，但是在 jsx 中只有 as 的方式可以使用：</p>\n<ol>\n<li>&lt;类型&gt;值</li>\n<li>值 as 类型</li>\n</ol>\n<pre><code class="hljs" lang="ts"><span class="hljs-keyword">let</span> value: (<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>) = <span class="hljs-string">\'My name is Tom\'</span>\n<span class="hljs-keyword">let</span> isLongString: <span class="hljs-built_in">boolean</span> = (value <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).length &gt; <span class="hljs-number">10</span>\n<span class="hljs-keyword">let</span> hi: <span class="hljs-built_in">string</span> = <span class="hljs-string">\'hello! \'</span> + &lt;<span class="hljs-built_in">string</span>&gt;value\n</code></pre>\n<p>对引用类型做类型检查</p>\n',wordCount:1761}},fPUB:function(s,n,a){"use strict";a.d(n,"a",function(){return e});var l=a("Dd8w"),p=a.n(l),e=a("/HJh").keys().map(function(s){var n=a("xf8P")("./"+s.slice(2));return p()({},n.info,{content:n.content,wordCount:n.wordCount})}).sort(function(s,n){return+new Date(n.date)-+new Date(s.date)})},h4K6:function(s,n){s.exports={info:{title:"浅析 AMD CMD UMD CommonJS 模块规范",poster:"",date:"2018-07-17",id:"2018-07-17",desc:"js 中有各种模块规范，例如 AMD CMD UMD CommonJS 等，他们是怎样规定的呢？一起来看一看"},content:'<p>在传统的 html 网页中，js 代码都是通过 script 标签加载到页面上来的，不同功能的代码混合在一起时，很多问题就会暴露出来：</p>\n<ol>\n<li>全局变量造成命名空间污染</li>\n<li>代码不易复用，无法拆分</li>\n<li>\bjs 引入顺序问题</li>\n<li>维护困难</li>\n</ol>\n<h2>AMD（Asynchronous Module Definition）</h2>\n<p>RequireJS 是为 js 实现 AMD 模块规范第三方库</p>\n<p>AMD 采用异步的方式加载模块，将所有依赖前置，依赖这些模块的代码都放在一个回调函数中，等所有模块加载完成后才会执行这个回调函数，很适合在浏览器端处理异步获取的模块</p>\n<h3>加载 RequireJS：</h3>\n<pre><code class="hljs" lang="html">/* index.html */\n\n<span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>AMD<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n  name: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"name"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>\n\n  <span class="hljs-comment">&lt;!-- 引入 require.js 与 main.js --&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"require.js"</span> <span class="hljs-attr">data-main</span>=<span class="hljs-string">"main"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n\n<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>\n</code></pre>\n<h3>定义模块：</h3>\n<pre><code class="hljs" lang="js"><span class="hljs-comment">/* 模块 module.js */</span>\n\n<span class="hljs-comment">// 依赖数组 与 回调函数</span>\ndefine([<span class="hljs-string">\'lodash\'</span>, <span class="hljs-string">\'jquery\'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_, $</span>) </span>{\n\n  <span class="hljs-comment">// 局部变量</span>\n  <span class="hljs-keyword">var</span> names = [<span class="hljs-string">\'tom\'</span>, <span class="hljs-string">\'jerry\'</span>, <span class="hljs-string">\'oliver\'</span>]\n  $(<span class="hljs-string">\'.name\'</span>).html(_.last(names))\n\n  <span class="hljs-comment">// 导出</span>\n  <span class="hljs-keyword">return</span> {\n    <span class="hljs-attr">names</span>: names\n  }\n})\n</code></pre>\n<p>define 函数的第一个参数是一个数组，所有的依赖项都放在其中；第二个\b参数是回调函数，回调函数的参数就是依赖模块导出的值。</p>\n<h3>引入模块</h3>\n<pre><code class="hljs" lang="js"><span class="hljs-comment">/* 主入口 main.js */</span>\n\n<span class="hljs-built_in">require</span>([<span class="hljs-string">\'module.js\'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">m</span>) </span>{\n  <span class="hljs-built_in">console</span>.log(m.names)  <span class="hljs-comment">// [\'tom\', \'jerry\', \'oliver\']</span>\n})\n</code></pre>\n<p>要引入其他模块时，同样将依赖数组传给 require 函数；第二个\b参数是回调函数，回调函数的参数就是依赖模块导出的值。</p>\n<h2>CMD（Common Module Definition）</h2>\n<p><a href="https://www.zhangxinxu.com/sp/seajs/#intro">SeaJS</a> 是 <a href="https://github.com/seajs/seajs/issues/242">CMD</a> 规范的代表框架，它以懒加载的方式去加载模块，推崇依赖就近</p>\n<h3>引入与导出模块</h3>\n<pre><code class="hljs" lang="js"><span class="hljs-comment">/*  utils.js */</span>\n\ndefine(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">require, exports, module</span>) </span>{\n  <span class="hljs-comment">// ...</span>\n\n  <span class="hljs-comment">// 使用 require 引入模块</span>\n  <span class="hljs-keyword">if</span> (flag) {\n    <span class="hljs-comment">// 只有条件成立才会引入</span>\n    <span class="hljs-keyword">const</span> h = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'hello\'</span>)\n    <span class="hljs-comment">// ...</span>\n  }\n\n  <span class="hljs-comment">// 在 exports 上暴露一个方法</span>\n  exports.add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>{\n    <span class="hljs-keyword">return</span> a + b\n  }\n})\n</code></pre>\n<pre><code class="hljs" lang="js"><span class="hljs-comment">/*  main.js */</span>\n\ndefine(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">require, exports, module</span>) </span>{\n  <span class="hljs-keyword">const</span> utils = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'utils\'</span>)\n  <span class="hljs-built_in">console</span>.log(utils.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))  <span class="hljs-comment">// 3</span>\n})\n</code></pre>\n<h2>UMD（Universal Module Definition）</h2>\n<p>由于 AMD 与 CommonJS 规范的差异，导致模块引用方式出现浏览器端与 node 端的分化，UMD 正是对 AMD 与 CommonJS 两种规范的兼容，它会判断当前环境是否支持某一规范，然后运用此规范去加载\b模块，如果不支持任何模式，将会挂在到全局</p>\n<pre><code class="hljs" lang="js">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">factory</span>) </span>{\n  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">\'function\'</span> &amp;&amp; define.amd) {\n    <span class="hljs-comment">// AMD. Register as an anonymous module.</span>\n    define([<span class="hljs-string">\'jquery\'</span>], factory)\n  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">module</span> === <span class="hljs-string">\'object\'</span> &amp;&amp; <span class="hljs-built_in">module</span>.exports) {\n    <span class="hljs-comment">// Node/CommonJS</span>\n    <span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root, jQuery</span>) </span>{\n      <span class="hljs-keyword">if</span> (jQuery === <span class="hljs-literal">undefined</span>) {\n        <span class="hljs-comment">// require(\'jQuery\') returns a factory that requires window to</span>\n        <span class="hljs-comment">// build a jQuery instance, we normalize how we use modules</span>\n        <span class="hljs-comment">// that require this pattern but the window provided is a noop</span>\n        <span class="hljs-comment">// if it\'s defined (how jquery works)</span>\n        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> !== <span class="hljs-string">\'undefined\'</span>) {\n          jQuery = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'jquery\'</span>)\n        } <span class="hljs-keyword">else</span> {\n          jQuery = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'jquery\'</span>)(root)\n        }\n      }\n      factory(jQuery)\n      <span class="hljs-keyword">return</span> jQuery\n    }\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-comment">// Browser globals</span>\n    factory(jQuery)\n  }\n}(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$</span>) </span>{\n  $.fn.jqueryPlugin = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>\n  }\n}))\n</code></pre>\n<h2>CommonJS</h2>\n<p>CommonJS 是 NodeJS 采用的模块规范</p>\n<p>每一个文件被视为一个模块，每一个模块拥有独立的作用域，模块的内部变量、函数、类无法被其他模块访问。</p>\n<h3>导出模块</h3>\n<p>在模块内部 module.exports 上指定额外的属性，会被添加到模块的根部，可作为导出的内容：</p>\n<pre><code class="hljs" lang="js"><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>\n<span class="hljs-keyword">const</span> b = <span class="hljs-number">2</span> <span class="hljs-comment">// b 未导出，只作为局部变量</span>\n\n<span class="hljs-comment">// a 被导出</span>\n<span class="hljs-built_in">module</span>.exports.a = a\n</code></pre>\n<pre><code class="hljs" lang="js"><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>\n<span class="hljs-keyword">const</span> b = <span class="hljs-number">2</span> <span class="hljs-comment">// b 未导出，只作为局部变量</span>\n\n<span class="hljs-comment">// a 被导出</span>\n<span class="hljs-built_in">module</span>.exports = {\n  <span class="hljs-attr">a</span>: a\n}\n</code></pre>\n<p>模块内部的 exports 变量指向了 module.exports，可以方便的作为模块的出口：</p>\n<pre><code class="hljs" lang="js">exports.a = <span class="hljs-number">1</span>\n</code></pre>\n<pre><code class="hljs" lang="js">exports = {\n  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>\n}\n</code></pre>\n<p><strong>区分 exports 与 module.exports：</strong></p>\n<p>因为 exports 只是单纯作为 module.exports 的引用，所以当 module.exports 被赋值后，exports 原来指向的内容将无法导出：</p>\n<pre><code class="hljs" lang="js">exports.a = <span class="hljs-number">1</span>\n\n<span class="hljs-built_in">module</span>.exports = {\n  <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>\n}\n\n<span class="hljs-comment">// 只有 b 被导出</span>\n</code></pre>\n<h3>\b引入模块</h3>\n<p>CommonJS 加载模块的方式是同步的，通过 require 引入外部模块：</p>\n<pre><code class="hljs" lang="js"><span class="hljs-keyword">const</span> myModule = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'myModule\'</span>)\n\nmyModule.foo({\n  <span class="hljs-attr">data</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">\'./data\'</span>)\n})\n</code></pre>\n<p>如果模块名与核心模块一致时，NodeJS 会优先加载核心模块，如：http, fs：</p>\n<pre><code class="hljs" lang="js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'fs\'</span>)\n\nfs.unlink(<span class="hljs-string">\'/tmp/hello\'</span>, (err) =&gt; {\n  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'成功删除 /tmp/hello\'</span>)\n})\n</code></pre>\n<p>由于模块加载是同步的，所以异步导出的模块是获取不到的：</p>\n<pre><code class="hljs" lang="js">setTimeOut(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n  exports.a = <span class="hljs-number">1</span>\n}, <span class="hljs-number">1000</span>)\n\n<span class="hljs-comment">// 在其他模块引入时是 {}</span>\n</code></pre>\n<p>require 是每个模块的内置对象</p>\n<ul>\n<li>require.main 是当前文件的 module</li>\n<li>require.main.filename 是 NodeJS 程序的入口（文件路径）</li>\n</ul>\n',wordCount:3892}},q2Ig:function(s,n){},tK2S:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var l=a("woOf"),p=a.n(l),e=a("fPUB"),c=a("ukYY"),t={name:"ArticleDetail",props:{id:{type:String,required:!0}},data:function(){return{detail:{title:"",desc:"",poster:"",content:"",date:"",id:null}}},methods:{toggleSideBar:function(s){this.$store.commit(c.a.SWITCH_SIDE_NAV,s)}},mounted:function(){var s=this,n=this.id;this.mock(e.a.find(function(s){return s.id===n})).then(function(n){p()(s.detail,n);var a=s.detail.content,l=s.$refs.contentContainer;a&&l&&(l.innerHTML=a||"",s.$emit("content-render",l),s.toggleSideBar(!0))})},beforeDestroy:function(){this.toggleSideBar(!1)}},o={render:function(){var s=this,n=s.$createElement,a=s._self._c||n;return a("div",{staticClass:"detail__wrap"},[a("h1",{staticClass:"title text--c w-b--word"},[s._v(s._s(s.detail.title))]),s._v(" "),a("div",{ref:"contentContainer",staticClass:"content md",domProps:{innerHTML:s._s("<h1>Loading...</h1>")}}),s._v(" "),a("div",{staticClass:"date m-t--50"},[s._v(s._s(s.detail.date))])])},staticRenderFns:[]};var d=a("VU/8")(t,o,!1,function(s){a("q2Ig"),a("c+JU"),a("/nxT")},"data-v-f98fd170",null);n.default=d.exports},xf8P:function(s,n,a){var l={"./MacOS 环境安装 MongoDB.mdjs":"PU9U","./SVG Animation.mdjs":"Jz86","./chrome extension.mdjs":"7K+T","./linux学习笔记.mdjs":"4oDU","./ts.md":"c3ki","./对 javascript 执行环境的探索.mdjs":"7afm","./浅析 AMD CMD UMD CommonJS 模块规范.mdjs":"h4K6","./浏览器原理.mdjs":"I4L2","./解析 npm-package.json.mdjs":"4MyP","./随想.mdjs":"WUj+"};function p(s){return a(e(s))}function e(s){var n=l[s];if(!(n+1))throw new Error("Cannot find module '"+s+"'.");return n}p.keys=function(){return Object.keys(l)},p.resolve=e,s.exports=p,p.id="xf8P"}});
//# sourceMappingURL=0.a7cac258cb5f06a9e7b6.js.map